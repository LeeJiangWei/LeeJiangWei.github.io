<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>鸡蛋掉落</title>
    <link href="/leetcode/fucking-algorithm/super-egg-drop/"/>
    <url>/leetcode/fucking-algorithm/super-egg-drop/</url>
    
    <content type="html"><![CDATA[<h1 id="鸡蛋掉落"><a href="#鸡蛋掉落" class="headerlink" title="鸡蛋掉落"></a>鸡蛋掉落</h1><p><a href="https://leetcode-cn.com/problems/super-egg-drop/">https://leetcode-cn.com/problems/super-egg-drop/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p><strong>状态</strong>：剩余鸡蛋数量 <code>eggs</code>，剩余未测楼层数 <code>floors</code>。随着鸡蛋数量的减少，剩下的楼层数就会减少。</p><p><strong>状态转移</strong>：假设当前剩余 <code>eggs</code> 个鸡蛋和 <code>floors</code> 层楼，去第 <code>i</code> 层扔一个鸡蛋，会有 2 种情况：</p><ul><li>如果鸡蛋没碎，可以排除这层楼及以下的楼层，剩余楼层数为 <code>floors - i</code>；</li><li>如果鸡蛋碎了，则排除这层楼及以上的楼层，剩余楼层数为 <code>i - 1</code>，且鸡蛋少了一个。</li></ul><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/%E6%89%94%E9%B8%A1%E8%9B%8B/1.jpg" alt="状态转移"></p><p>注意，只需要关注剩下几层楼没测，而不需要关注这层楼具体是多高，因为对于每层楼我们最终都会假设它碎或不碎两种情况，相当于是把所有可能性都尝试了一次。</p><p><code>i</code> 怎么取？也就是说去哪层开始扔？答案是都试一次，扔完一个后楼层减少，继续用一样的方法尝试。关注<strong>最坏情况</strong>下<em>最少的操作数</em>，最坏情况就是扔了一次鸡蛋后剩余的楼层数最多，最少的操作数就是从每个不同的楼层 <code>i</code> 开始扔，哪个用的次数最少。即:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-number">1</span> &lt;= i &lt;= floors:<br>    res = <span class="hljs-built_in">min</span>(res, <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<br>        dp(eggs, floors-i),  <span class="hljs-comment"># 鸡蛋没碎，剩余上面的楼层</span><br>        dp(eggs-<span class="hljs-number">1</span>, i-<span class="hljs-number">1</span>),     <span class="hljs-comment"># 鸡蛋碎了，剩余下面的楼层，鸡蛋减一</span><br>    ))<br></code></pre></td></tr></table></figure><p>最终用备忘录减少重复计算，代码写出来就是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">superEggDrop</span><span class="hljs-params">(k <span class="hljs-keyword">int</span>, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">return</span> dp(memo, k, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo <span class="hljs-keyword">map</span>[[2]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, eggs <span class="hljs-keyword">int</span>, floors <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case:</span><br>    <span class="hljs-keyword">if</span> floors == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> eggs == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> floors<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;eggs, floors&#125;]; ok &#123;<br>        <span class="hljs-keyword">return</span> v<br>    &#125;<br><br>    times := math.MaxInt16<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= floors; i++ &#123;<br>        times = min(times, max(dp(memo, eggs<span class="hljs-number">-1</span>, i<span class="hljs-number">-1</span>), dp(memo, eggs, floors-i)) + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;eggs, floors&#125;] = times<br>    <span class="hljs-keyword">return</span> times<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &lt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &gt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>但是 leetcode 会超时。</p><h2 id="用二分搜索优化"><a href="#用二分搜索优化" class="headerlink" title="用二分搜索优化"></a>用二分搜索优化</h2><p>上面的方法有个致命的缺点，就是每次搜索都是线性搜索，且都是从 1 开始到 N，这效率并不够高，leetcode 题直接超时了。需要改进上面的线性搜索，也就是这一部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= floors; i++ &#123;<br>    times = min(times, max(dp(memo, eggs<span class="hljs-number">-1</span>, i<span class="hljs-number">-1</span>), dp(memo, eggs, floors-i)) + <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们根据 <code>dp(K, N)</code> 数组的定义（有 K 个鸡蛋面对 N 层楼，最少需要扔几次），很容易知道 <code>K</code> 固定时，这个函数一定是单调递增的，无论你策略多聪明，随着总楼层增加，测试次数一定要增加。</p><p>那么注意 <code>dp(K - 1, i - 1)</code> 和 <code>dp(K, N - i)</code> 这两个函数，其中 i 是从 1 到 N 单增的，如果我们固定 <code>K</code> 和 <code>N</code>，把这两个函数看做关于 <code>i</code> 的函数，前者随着 <code>i</code> 的增加应该也是单调递增的，而后者随着 <code>i</code> 的增加应该是单调递减的：</p><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/%E6%89%94%E9%B8%A1%E8%9B%8B/2.jpg" alt="函数图像示意"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">superEggDrop</span><span class="hljs-params">(k <span class="hljs-keyword">int</span>, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">return</span> dp(memo, k, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo <span class="hljs-keyword">map</span>[[2]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, eggs <span class="hljs-keyword">int</span>, floors <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case:</span><br>    <span class="hljs-keyword">if</span> floors == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> eggs == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> floors<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;eggs, floors&#125;]; ok &#123;<br>        <span class="hljs-keyword">return</span> v<br>    &#125;<br><br>    times := math.MaxInt16<br><br>    <span class="hljs-comment">// 改进后的二分搜索</span><br>    low, high := <span class="hljs-number">1</span>, floors<br>    <span class="hljs-keyword">for</span> low &lt;= high &#123;<br>        mid := (low + high) / <span class="hljs-number">2</span><br><br>        brokenTimes := dp(memo, eggs<span class="hljs-number">-1</span>, mid<span class="hljs-number">-1</span>)      <span class="hljs-comment">// 蛋碎了</span><br>        noBrokenTimes := dp(memo, eggs, floors-mid) <span class="hljs-comment">// 蛋没碎</span><br><br>        <span class="hljs-keyword">if</span> brokenTimes &gt; noBrokenTimes &#123;<br>            high = mid - <span class="hljs-number">1</span><br>            times = min(times, brokenTimes + <span class="hljs-number">1</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = mid + <span class="hljs-number">1</span><br>            times = min(times, noBrokenTimes + <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br><br>    memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;eggs, floors&#125;] = times<br>    <span class="hljs-keyword">return</span> times<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &lt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>此时 leetcode 终于不超时了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零钱兑换 II</title>
    <link href="/leetcode/fucking-algorithm/coin-change-2/"/>
    <url>/leetcode/fucking-algorithm/coin-change-2/</url>
    
    <content type="html"><![CDATA[<h1 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a>零钱兑换 II</h1><p><a href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p><p>此题是完全背包问题，即物品数量是无限的。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>对于背包问题，DP 表 <code>dp[i][j]</code> 表示：若只使用 <code>coins</code> 中的前 <code>i</code> 个硬币的面值，若想凑出金额 <code>j</code>，有 <code>dp[i][j]</code> 种凑法。</p><ul><li>如果你不把这第 <code>i</code> 个物品装入背包，也就是说你不使用 <code>coins[i]</code> 这个面值的硬币，那么凑出面额 j 的方法数 <code>dp[i][j]</code> 应该等于 <code>dp[i-1][j]</code>，继承之前的结果。</li><li>如果你把这第 <code>i</code> 个物品装入了背包，也就是说你使用 <code>coins[i]</code> 这个面值的硬币，那么 <code>dp[i][j]</code> 应该等于 <code>dp[i][j-coins[i-1]]</code>。（注意这里是 dp[<strong>i</strong>][j-coins[i-1]] ，已经包括了再次重复使用这个硬币的情况）</li></ul><p>综上就是两种选择，而我们想求的 <code>dp[i][j]</code> 是「共有多少种凑法」，所以 <code>dp[i][j]</code> 的值应该是以上两种选择的结果之和：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>, coins []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(coins)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, amount + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// base case: 如果 amount 为 0，只有 1 种办法凑出（不放硬币）</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= amount; j++ &#123;<br>            <span class="hljs-keyword">if</span> j - coins[i<span class="hljs-number">-1</span>] &gt;= <span class="hljs-number">0</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j - coins[i<span class="hljs-number">-1</span>]]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][amount]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="压缩-DP-表"><a href="#压缩-DP-表" class="headerlink" title="压缩 DP 表"></a>压缩 DP 表</h2><p>可以看出 <code>dp[i][..]</code> 的状态总是且仅依赖于 <code>dp[i-1][..]</code> 的状态，因此可以只使用 1D 数组来完成， 每次在数组上迭代就相当于 <code>i</code> 的递增。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>, coins []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(coins)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, amount + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// base case: 如果 amount 为 0，只有 1 种办法凑出（不放硬币）</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= amount; j++ &#123;<br>            <span class="hljs-keyword">if</span> j - coins[i<span class="hljs-number">-1</span>] &gt;= <span class="hljs-number">0</span> &#123;<br>                dp[j] = dp[j] + dp[j - coins[i<span class="hljs-number">-1</span>]]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure><p>与 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/">分割等和子集</a> 不同，这里压缩 DP 表不需要从后遍历 <code>j</code>，因为观察压缩前的状态转移公式，<code>dp[i-1][j]</code> 只会用于更新 <code>dp[i][j]</code>，可以直接覆盖掉而不影响其它结果。</p><p>（在上一题中，<code>dp[i-1][j]</code> 可能会用于更新 <code>dp[i][j + nums[i]]</code> 的值，如果从头开始遍历，更新到 <code>dp[i-1][j + nums[i]]</code> 时，<code>dp[i-1][j]</code> 已经先于它更新了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分割等和子集</title>
    <link href="/leetcode/fucking-algorithm/partition-equal-subset-sum/"/>
    <url>/leetcode/fucking-algorithm/partition-equal-subset-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h1><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p><p>此问题可以转换为背包问题。首先对数组求和然后除以2，得出单个子集的总和 <code>sum/2</code>，显然问题就是要从数组中选出几个数使得总和为 <code>sum/2</code>。就类似于背包问题，在这里只需要把“背包”填满即可。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>对于背包问题，DP 表 <code>dp[i][w]</code> 表示：对于前 <code>i</code> 个物品，当前背包的容量为 <code>w</code> 时，这种情况下可以装下的最大价值是 <code>dp[i][w]</code>。</p><p>在遍历到 <code>i</code> 时，如果当前容量为 <code>w</code>，我们要么把物品 <code>i</code> 装入背包，要么不装。</p><ul><li>如果不装，则没有变化，<code>dp[i][w]</code> 继承 <code>dp[i-1][w]</code> 的值。</li><li>如果装入背包，则加上装入物品的价值，并且寻找背包容量 <code>w</code> 减少后能装入（之前的物品）的最大价值，即 <code>dp[i-1][w - weight[i]]</code>。这两项加起来就是装入这个物品后的最大价值，即<code>dp[i][j] = value[i] + dp[i-1][w - weight[i]]</code>。</li></ul><p>最后要寻求这两种情况下最大值，就是 <code>dp[i][w] = max(dp[i-1][w], dp[i-1][w - wt[i-1]] + val[i-1])</code>。</p><p>对于此题，不需要计算物品的价值，只需要知道能不能正好装满，DP 表中储存 <code>true</code> 和 <code>false</code> 即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += v<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 转换为背包问题</span><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    vol := <span class="hljs-keyword">int</span>(sum / <span class="hljs-number">2</span>)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">bool</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, vol + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// base cases</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= vol; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= vol; j++ &#123;<br>            <span class="hljs-keyword">if</span> j - nums[i<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-comment">// 背包容量 j 不足以装下重量为 nums[i-1] 的物品</span><br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 装或不装，选择能装的那个（有一个选择为 true 则为 true）</span><br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] || dp[i<span class="hljs-number">-1</span>][j-nums[i<span class="hljs-number">-1</span>]]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][vol]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="压缩-DP-表"><a href="#压缩-DP-表" class="headerlink" title="压缩 DP 表"></a>压缩 DP 表</h2><p>可以看出 <code>dp[i][..]</code> 的状态总是且仅依赖于 <code>dp[i-1][..]</code> 的状态，因此可以只使用 1D 数组来完成， 每次在数组上迭代就相当于 <code>i</code> 的递增。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += v<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 转换为背包问题</span><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    vol := <span class="hljs-keyword">int</span>(sum / <span class="hljs-number">2</span>)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, vol + <span class="hljs-number">1</span>)<br><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := vol; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            <span class="hljs-keyword">if</span> j - nums[i<span class="hljs-number">-1</span>] &gt;= <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-comment">// 装或不装，选择能装的那个（有一个选择为 true 则为 true）</span><br>                dp[j] = dp[j] || dp[j - nums[i<span class="hljs-number">-1</span>]]<br>            &#125;<br>            <span class="hljs-comment">// else: 如果不装，则什么也不用做</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[vol]<br>&#125;<br></code></pre></td></tr></table></figure><p>唯一需要注意的是 <code>j</code> 应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果。如果我们从小到大更新 <code>dp</code> 值，那么在计算 <code>dp[j]</code> 值的时候，<code>dp[j − nums[i]]</code> 已经是被更新过的状态，不再是上一行的 <code>dp</code> 值。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长回文子序列</title>
    <link href="/leetcode/fucking-algorithm/longest-palindromic-subsequence/"/>
    <url>/leetcode/fucking-algorithm/longest-palindromic-subsequence/</url>
    
    <content type="html"><![CDATA[<h1 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">https://leetcode-cn.com/problems/longest-palindromic-subsequence/</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>对于这种一个字符串，但是需要用到双向信息的题，需要一个二维的 DP 表来储存结果。</p><p>在子数组 <code>s[i..j]</code> 中，我们要求的子序列（最长回文子序列）的长度为 <code>dp[i][j]</code></p><p>先不去想怎么求出这个长度，用数学归纳法的思想，假设已经知道了它掐头去尾的子串 <code>s[i+1, ..., j-1]</code> 中最长回文子串的长度，如何求出 <code>dp[i][j]</code> 呢？</p><p>答案是看这两个新进来的字符 <code>s[i]</code> 和 <code>s[j]</code>，如果它们相等，那一定能拼出一个更长的回文串，则 <code>dp[i][j] = dp[i+1][j-1] + 2</code>。如果它们不相等，再去看它们只加进去 1 个字符后产生的回文串长度，即 <code>dp[i][j] = dp[i][j] = max(dp[i+1][j], dp[i][j-1])</code>。</p><p>考虑完递归条件，考虑 base case。显然 base case 就是只有一个字符串时回文长度就是 1，以及空字符串为 0。最后画出 DP 表，由于我们需要求整个序列的长度 <code>dp[0][n-1]</code>，从表中可以看出 base case 和最终状态的关系，按照合适的顺序遍历表计算结果即可。</p><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/4.jpg" alt="DP 表"></p><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/5.jpg" alt="DP 表的遍历顺序"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    &#125;<br><br>    <span class="hljs-comment">// base case: single char</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123; <br>        dp[i][i] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> res &lt; v &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 可变参数（...）</title>
    <link href="/programming/go-variadic-parameter/"/>
    <url>/programming/go-variadic-parameter/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-可变参数（点点点）"><a href="#Golang-可变参数（点点点）" class="headerlink" title="Golang 可变参数（点点点）"></a>Golang 可变参数（点点点）</h1><p>可变参数： variadic parameter</p><h2 id="在函数签名中使用"><a href="#在函数签名中使用" class="headerlink" title="在函数签名中使用"></a>在函数签名中使用</h2><p>只能用在最后一个参数的类型前，表示这个类型的参数可以有任意个。实际传入函数中的是一个切片:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(vals ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    total := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>        total += val<br>    &#125;<br>    <span class="hljs-keyword">return</span> total<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="传入函数参数时使用"><a href="#传入函数参数时使用" class="headerlink" title="传入函数参数时使用"></a>传入函数参数时使用</h2><p>如果需要传入这个函数的原始参数已经是切片了，则传入函数时在它的后面加上 <code>...</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">values := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>fmt.Println(sum(values...)) <span class="hljs-comment">// &quot;10&quot;</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://docs.hundan.org/gopl-zh/ch5/ch5-07.html">https://docs.hundan.org/gopl-zh/ch5/ch5-07.html</a></p></li><li><p><a href="https://stackoverflow.com/questions/23669720/meaning-of-interface-dot-dot-dot-interface/23669857">https://stackoverflow.com/questions/23669720/meaning-of-interface-dot-dot-dot-interface/23669857</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>俄罗斯套娃信封问题</title>
    <link href="/leetcode/fucking-algorithm/russian-doll-envelopes/"/>
    <url>/leetcode/fucking-algorithm/russian-doll-envelopes/</url>
    
    <content type="html"><![CDATA[<h1 id="俄罗斯套娃信封问题"><a href="#俄罗斯套娃信封问题" class="headerlink" title="俄罗斯套娃信封问题"></a>俄罗斯套娃信封问题</h1><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">https://leetcode-cn.com/problems/russian-doll-envelopes/</a></p><p>此题用 Golang DP 会超出时间限制（官方代码也是）。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>利用 sort 标准库，给二维切片一个类型别名，然后在此类型上定义 <code>sort.Sort()</code> 函数所需要的 3 个方法，在 <code>Less()</code> 方法种完成比较的逻辑。排序后套用 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a> 的解题方法。</p><p>参考：<a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(envelopes [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; <br>    sort.Sort(Envelopes(envelopes))<br>    <br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(envelopes))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> envelopes[j][<span class="hljs-number">1</span>] &lt; envelopes[i][<span class="hljs-number">1</span>] &#123;<br>                dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    res := math.MinInt16<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        res = max(res, dp[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-keyword">type</span> Envelopes [][]<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(envelopes Envelopes)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(envelopes)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(envelopes Envelopes)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> envelopes[i][<span class="hljs-number">0</span>] &lt; envelopes[j][<span class="hljs-number">0</span>] &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> envelopes[i][<span class="hljs-number">0</span>] == envelopes[j][<span class="hljs-number">0</span>] &amp;&amp; envelopes[i][<span class="hljs-number">1</span>] &gt; envelopes[j][<span class="hljs-number">1</span>] &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(envelopes Envelopes)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    envelopes[i], envelopes[j] = envelopes[j], envelopes[i]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划（官方）"><a href="#动态规划（官方）" class="headerlink" title="动态规划（官方）"></a>动态规划（官方）</h2><p>使用了 <code>sort.Slice()</code> 来对任何数据结构（空接口）的切片进行排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(envelopes [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(envelopes)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    sort.Slice(envelopes, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>        a, b := envelopes[i], envelopes[j]<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>] || a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] &amp;&amp; a[<span class="hljs-number">1</span>] &gt; b[<span class="hljs-number">1</span>]<br>    &#125;)<br><br>    f := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> f &#123;<br>        f[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> envelopes[j][<span class="hljs-number">1</span>] &lt; envelopes[i][<span class="hljs-number">1</span>] &#123;<br>                f[i] = max(f[i], f[j]+<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(f...)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := a[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a[<span class="hljs-number">1</span>:] &#123;<br>        <span class="hljs-keyword">if</span> v &gt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个字符串的最小ASCII删除和</title>
    <link href="/leetcode/fucking-algorithm/minimum-ascii-delete-sum-for-two-strings/"/>
    <url>/leetcode/fucking-algorithm/minimum-ascii-delete-sum-for-two-strings/</url>
    
    <content type="html"><![CDATA[<h1 id="两个字符串的最小ASCII删除和"><a href="#两个字符串的最小ASCII删除和" class="headerlink" title="两个字符串的最小ASCII删除和"></a>两个字符串的最小ASCII删除和</h1><p><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">https://leetcode-cn.com/problems/delete-operation-for-two-strings/</a></p><p>跟编辑距离几乎是一样的，只是把操作数换成 ASCII 码罢了。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumDeleteSum</span><span class="hljs-params">(s1 <span class="hljs-keyword">string</span>, s2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">len</span>(s1)<br>    n := <span class="hljs-built_in">len</span>(s2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + <span class="hljs-keyword">int</span>(s1[i<span class="hljs-number">-1</span>])<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-keyword">int</span>(s2[j<span class="hljs-number">-1</span>])<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> s1[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-keyword">int</span>(s1[i<span class="hljs-number">-1</span>]), dp[i][j<span class="hljs-number">-1</span>]+<span class="hljs-keyword">int</span>(s2[j<span class="hljs-number">-1</span>]))<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个字符串的删除操作</title>
    <link href="/leetcode/fucking-algorithm/delete-operation-for-two-strings/"/>
    <url>/leetcode/fucking-algorithm/delete-operation-for-two-strings/</url>
    
    <content type="html"><![CDATA[<h1 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h1><p><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">https://leetcode-cn.com/problems/delete-operation-for-two-strings/</a></p><p>跟编辑距离几乎是一样的，不过是只有删除操作。</p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>核心思想：如果字符串不匹配，2 种删除操作都试一遍（删除 s1 当前字符或 s2 当前字符），找出操作数最少的。</p><p>DP 函数定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">len</span>(word1)<br>    n := <span class="hljs-built_in">len</span>(word2)<br>    memo := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> memo &#123;<br>        memo[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> memo[i] &#123;<br>            memo[i][j] = <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp(memo, word1, word2, m<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo [][]<span class="hljs-keyword">int</span>, word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> j + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> j == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 查备忘录</span><br>    <span class="hljs-keyword">if</span> memo[i][j] != <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> memo[i][j]<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> word1[i] == word2[j] &#123;<br>        memo[i][j] = dp(memo, word1, word2, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> memo[i][j]<br>    &#125;<br><br>    memo[i][j] = min(dp(memo, word1, word2, i<span class="hljs-number">-1</span>, j)+<span class="hljs-number">1</span>, dp(memo, word1, word2,i,j<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> memo[i][j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>和编辑距离是一样的思路</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">len</span>(word1)<br>    n := <span class="hljs-built_in">len</span>(word2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// base cases</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    &#125;<br><br>    <span class="hljs-comment">// dp</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>, dp[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长公共子序列</title>
    <link href="/leetcode/fucking-algorithm/longest-common-subsequence/"/>
    <url>/leetcode/fucking-algorithm/longest-common-subsequence/</url>
    
    <content type="html"><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p><blockquote><p>子序列类型的问题，穷举出所有可能的结果都不容易，而动态规划算法做的就是穷举 + 剪枝，它俩天生一对儿。所以可以说只要涉及子序列问题，十有八九都需要动态规划来解决，往这方面考虑就对了。</p></blockquote><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>核心思想：如果两个字符串出现了一样的字符，那它必在 LCS 中。</p><p>用两个指针 <code>i</code> 和 <code>j</code> 从后往前遍历 s1 和 s2，如果 <code>s1[i]==s2[j]</code>，那么这个字符一定在 LCS 中；否则的话，<code>s1[i]</code> 和 <code>s2[j]</code> 这两个字符至少有一个不在 LCS 中，需要丢弃一个，即其中一个指针往前移。至于是哪个，答案是都试一次，然后取最大的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-keyword">string</span>, text2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">len</span>(text1)<br>    n := <span class="hljs-built_in">len</span>(text2)<br>    memo := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> memo &#123;<br>        memo[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> memo[i] &#123;<br>            memo[i][j] = <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp(memo, text1, text2, <span class="hljs-built_in">len</span>(text1)<span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(text2)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo [][]<span class="hljs-keyword">int</span>, text1 <span class="hljs-keyword">string</span>, text2 <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> || j == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// 查备忘录</span><br>    <span class="hljs-keyword">if</span> memo[i][j] != <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> memo[i][j]<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> text1[i] == text2[j] &#123;<br>        memo[i][j] = <span class="hljs-number">1</span> + dp(memo, text1, text2, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>) <span class="hljs-comment">// LCS 长度加1</span><br>        <span class="hljs-keyword">return</span> memo[i][j]<br>    &#125; <br>    memo[i][j] = max(dp(memo, text1, text2, i, j<span class="hljs-number">-1</span>), dp(memo, text1, text2, i<span class="hljs-number">-1</span>, j))<br>    <span class="hljs-keyword">return</span> memo[i][j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>字符串的 DP 表一般都是比字符串本身多出一位以表示处理完（空字符串）的情况，如图：</p><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/LCS/dp.png" alt="DP 表"></p><p><code>dp[i][j]</code> 的含义是：对于 <code>s1[1..i]</code> 和 <code>s2[1..j]</code>，它们的 LCS 长度是 <code>dp[i][j]</code>。当 i 或 j 为 0 时，空串和任何字符串的 LCS 显然都是 0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-keyword">string</span>, text2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">len</span>(text1)<br>    n := <span class="hljs-built_in">len</span>(text2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = <span class="hljs-number">1</span> + dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子数组和</title>
    <link href="/leetcode/fucking-algorithm/maximum-subarray/"/>
    <url>/leetcode/fucking-algorithm/maximum-subarray/</url>
    
    <content type="html"><![CDATA[<h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>构建 DP 数组：<code>dp[i]</code> 存储以 <code>nums[i]</code> 为结尾的最大子数组和，不用关心这个数组是从哪里开始的。如果 <code>nums[i-1]</code> 已被计算出，则对于 <code>nums[i]</code> 只有 2 种情况：要么连接上前面的子数组，要么自己成为一个子数组。取最大的即可。最后遍历 DP 数组，得到最大子序列长。</p><p>base case: 第一个元素前面没数组了，以它结尾的最大和就是它自己。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums))<br><br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment">// dp</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        dp[i] = max(dp[i<span class="hljs-number">-1</span>] + nums[i], nums[i])<br>    &#125;<br><br>    res := math.MinInt16<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> dp &#123;<br>        res = max(res, v)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下降路径最小和</title>
    <link href="/leetcode/fucking-algorithm/minimum-falling-path-sum/"/>
    <url>/leetcode/fucking-algorithm/minimum-falling-path-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a>下降路径最小和</h1><p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">https://leetcode-cn.com/problems/minimum-falling-path-sum/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>核心思想：下落到 <code>matrix[i][j]</code> 的最小路径，一定是 <code>matrix[i][j]</code> 自己的值，加上从它上面落下来的最小路径，即 <code>matrix[i-1][j-1]</code> <code>matrix[i-1][j]</code> <code>matrix[i-1][j+1]</code> 中最小的一个。</p><p>DP 函数定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>, i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 返回下落到 matrix[i][j] 的最小路径</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minFallingPathSum</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(matrix))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> memo &#123;<br>        memo[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> memo[i] &#123;<br>            memo[i][j] = <span class="hljs-number">66666</span><br>        &#125;<br>    &#125;<br>    res := math.MaxInt32<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]); j++ &#123;<br>        res = min(res, dp(memo, matrix, <span class="hljs-built_in">len</span>(matrix)<span class="hljs-number">-1</span>, j))<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo [][]<span class="hljs-keyword">int</span>, matrix [][]<span class="hljs-keyword">int</span>, i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// invalid matrix index</span><br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || j &gt;= <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">99999</span><br>    &#125;<br><br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> matrix[<span class="hljs-number">0</span>][j]<br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查备忘录</span><br>    <span class="hljs-keyword">if</span> memo[i][j] != <span class="hljs-number">66666</span> &#123;<br>        <span class="hljs-keyword">return</span> memo[i][j]<br>    &#125;<br>    v1 := dp(memo, matrix, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>)<br>    v2 := dp(memo, matrix, i<span class="hljs-number">-1</span>, j)<br>    v3 := dp(memo, matrix, i<span class="hljs-number">-1</span>, j+<span class="hljs-number">1</span>)<br><br>    v := min(v1, min(v2, v3))<br>    memo[i][j] = v + matrix[i][j]<br>    <span class="hljs-keyword">return</span> memo[i][j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>备忘录初始化：需要是一个不合法的值，题目给定了 <code>matrix</code> 最多是 100 x 100 的，元素在 [-100, 100] 之间，因此合法值范围为 [-10000, 10000]，备忘录初始化以及越界返回值都应该在此值之外。由于用了 <code>min()</code> 来找最小值，越界的话给一个很大的值即可。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>构建 DP 表：<code>dp[i][j]</code> 存储 下落到 <code>matrix[i][j]</code> 的最小路径和。特殊处理一下 j=0 和 j=n-1 的特殊情况即可，从第一行开始逐步往后加。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minFallingPathSum</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(matrix)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    &#125;<br><br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = matrix[<span class="hljs-number">0</span>][j]<br>    &#125;<br><br>    <span class="hljs-comment">// dp</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// j == 0 </span><br>        dp[i][<span class="hljs-number">0</span>] = matrix[i][<span class="hljs-number">0</span>] + min(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])<br><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; j++ &#123;<br>            dp[i][j] = matrix[i][j] + min(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], min(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>]))<br>        &#125;<br>        <br>        <span class="hljs-comment">// j == n-1</span><br>        dp[i][n<span class="hljs-number">-1</span>] = matrix[i][n<span class="hljs-number">-1</span>] + min(dp[i<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][n<span class="hljs-number">-2</span>])<br>    &#125;<br><br>    res := math.MaxInt32<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        res = min(res, dp[n<span class="hljs-number">-1</span>][j])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编辑距离</title>
    <link href="/leetcode/fucking-algorithm/edit-distance/"/>
    <url>/leetcode/fucking-algorithm/edit-distance/</url>
    
    <content type="html"><![CDATA[<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p><a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>核心思想：如果字符串不匹配，3 种编辑操作都试一遍，然后找出最小距离的</p><p>DP 函数定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>) <span class="hljs-comment">// 建立备忘录，以 array 为 key</span><br>    <span class="hljs-keyword">return</span> dp(memo, word1, word2, <span class="hljs-built_in">len</span>(word1)<span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(word2)<span class="hljs-number">-1</span>)<br>&#125;  <br><br><span class="hljs-comment">// DP 函数定义：两个字符串在 i 和 j 之前的编辑距离</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo <span class="hljs-keyword">map</span>[[2]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case: 已经处理完了其中一个字符，剩余编辑距离就是另一个字符未处理的长度</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> j + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> j == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 查备忘录</span><br>    <span class="hljs-keyword">if</span> val, ok := memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;]; ok &#123;<br>        <span class="hljs-keyword">return</span> val<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> word1[i] == word2[j] &#123; <br>        <span class="hljs-comment">// 字符相等，两个指针都往前走，编辑距离不变</span><br>        v := dp(memo, word1, word2, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>)<br>        memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;] = v<br><br>        <span class="hljs-keyword">return</span> v<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 字符不相等，则进行一次操作使得它们相等，编辑距离+1</span><br><br>        v1 := dp(memo, word1, word2, i, j<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>   <span class="hljs-comment">// 在 i 后插入字符，前移 j </span><br>        v2 := dp(memo, word1, word2, i<span class="hljs-number">-1</span>, j) + <span class="hljs-number">1</span>   <span class="hljs-comment">// 删除 i 处字符，并前移 i</span><br>        v3 := dp(memo, word1, word2, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span> <span class="hljs-comment">// 替换 i 处字符，前移两个指针</span><br><br>        v := min(v1, min(v2, v3))<br>        memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;] = v<br>        <br>        <span class="hljs-keyword">return</span> v<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>构建 DP 表：<code>dp[i-1][j-1]</code> 存储 <code>s1[0..i]</code> 和 <code>s2[0..j]</code> 的最小编辑距离</p><p>dp 函数的 base case 是 i,j 等于 -1，而数组索引至少是 0，所以 dp 数组的 index 会偏移一位，即 <code>dp[0][0]</code> 表示 s1 和 s2 都已经处理完的情况（i = -1, j = -1)，即剩余最小编辑距离为 0。</p><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/editDistance/dp.jpg" alt="DP 表"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 初始化 DP 表为 2D 切片</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(word1) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(word2) + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(word1); i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">len</span>(word2); j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    &#125;<br><br>    <span class="hljs-comment">// 构建 DP 表</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(word1); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">len</span>(word2); j++ &#123;<br>            <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>] &#123;  <span class="hljs-comment">// 注意这里对字符串的索引要减1</span><br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>, min(dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>))<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(word1)][<span class="hljs-built_in">len</span>(word2)]<br>&#125;  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长递增子序列</title>
    <link href="/leetcode/fucking-algorithm/longest-increasing-subsequence/"/>
    <url>/leetcode/fucking-algorithm/longest-increasing-subsequence/</url>
    
    <content type="html"><![CDATA[<h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>直接构建 DP 数组：<br><code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最长递增子序列长度。问题的答案就是找到这个数组中最大的元素。</p><p>知道了 <code>nums[5] = 3</code>，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// init</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums))<br><br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dp); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[j] &lt; nums[i] &#123;<br>                dp[i] = max(dp[i], <span class="hljs-number">1</span> + dp[j]) <br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// find biggest element</span><br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> dp &#123;<br>        res = max(res, v)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span> <span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零钱兑换</title>
    <link href="/leetcode/fucking-algorithm/coin-change/"/>
    <url>/leetcode/fucking-algorithm/coin-change/</url>
    
    <content type="html"><![CDATA[<h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><p><a href="https://leetcode-cn.com/problems/coin-change/">https://leetcode-cn.com/problems/coin-change/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-keyword">int</span>, amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    dict := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">return</span> dp(dict, coins, amount)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, coins[]<span class="hljs-keyword">int</span>, amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> amount &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// check memory if exists</span><br>    <span class="hljs-keyword">if</span> val, ok := memo[amount]; ok &#123;<br>        <span class="hljs-keyword">return</span> val<br>    &#125;<br><br>    res := math.MaxInt16<br><br>    <span class="hljs-keyword">for</span> _, coin := <span class="hljs-keyword">range</span> coins &#123;<br>        subproblem := dp(memo, coins, amount - coin)<br>        <span class="hljs-keyword">if</span> subproblem == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        res = min(res, <span class="hljs-number">1</span> + subproblem)<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> res == math.MaxInt16 &#123;<br>        res = <span class="hljs-number">-1</span><br>    &#125;<br><br>    memo[amount] = res<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>直接构建 DP 数组：<br><code>dp[i]</code> 表示数额为 i 时要的最少硬币个数。数组的索引就是变量，储存的值是需要计算的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-keyword">int</span>, amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// init</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, amount + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = math.MaxInt16<br>    &#125;<br><br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        <span class="hljs-keyword">for</span> _, coin := <span class="hljs-keyword">range</span> coins &#123;<br>            <span class="hljs-comment">// no solution</span><br>            <span class="hljs-keyword">if</span> i - coin &lt; <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            dp[i] = min(dp[i], <span class="hljs-number">1</span> + dp[i - coin])<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> dp[amount] == math.MaxInt16 &#123;<br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斐波那契数列</title>
    <link href="/leetcode/fucking-algorithm/fibonacci-number/"/>
    <url>/leetcode/fucking-algorithm/fibonacci-number/</url>
    
    <content type="html"><![CDATA[<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">https://leetcode-cn.com/problems/fibonacci-number/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> helper(memo, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(memo []<span class="hljs-keyword">int</span>, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    <span class="hljs-keyword">if</span> memo[n] != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> memo[n]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        memo[n] = helper(memo, n - <span class="hljs-number">1</span>) + helper(memo, n - <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> memo[n]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>直接构建 DP 数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(dp); i++ &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并两个有序数组</title>
    <link href="/leetcode/top-interview-questions-easy/merge-sorted-array/"/>
    <url>/leetcode/top-interview-questions-easy/merge-sorted-array/</url>
    
    <content type="html"><![CDATA[<h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>由于数组 <code>nums1</code> 的后面留够了足够的空位（<code>nums2</code> 元素的个数），如果从 <code>nums1</code> 的后面开始放入元素，可以保证 <code>nums1</code> 的元素在取出前不会被覆盖。</p><p>因此使用双指针，从后面开始填充  <code>nums1</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(nums1 []<span class="hljs-keyword">int</span>, m <span class="hljs-keyword">int</span>, nums2 []<span class="hljs-keyword">int</span>, n <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    pm := m - <span class="hljs-number">1</span><br>    pn := n - <span class="hljs-number">1</span><br>    curr := <span class="hljs-built_in">len</span>(nums1) - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> pm != <span class="hljs-number">-1</span> &amp;&amp; pn != <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">if</span> nums1[pm] &gt; nums2[pn] &#123;<br>            nums1[curr] = nums1[pm]<br>            pm--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums1[curr] = nums2[pn]<br>            pn--<br>        &#125;<br>        curr--<br>    &#125;<br>    <br>    <span class="hljs-comment">// 其中一个指针到达尽头后，将未到达尽头的那个数组填充完</span><br>    <span class="hljs-keyword">for</span> pm != <span class="hljs-number">-1</span> &#123;<br>        nums1[curr] = nums1[pm]<br>        curr--<br>        pm--<br>    &#125;<br>    <span class="hljs-keyword">for</span> pn != <span class="hljs-number">-1</span> &#123;<br>        nums1[curr] = nums2[pn]<br>        curr--<br>        pn--<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>排序和搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有序数组转换为平衡二叉树</title>
    <link href="/leetcode/top-interview-questions-easy/convert-sorted-array-to-binary-search-tree/"/>
    <url>/leetcode/top-interview-questions-easy/convert-sorted-array-to-binary-search-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="有序数组转换为平衡二叉树"><a href="#有序数组转换为平衡二叉树" class="headerlink" title="有序数组转换为平衡二叉树"></a>有序数组转换为平衡二叉树</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xninbt/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xninbt/</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>平衡的二叉树，对于「每个节点的左右两个子树的高度差的绝对值不超过 1 」，只要保证所有的内部节点的左右子树高度差在此范围内，就可以保证整棵树的平衡。</p><p>对于 BST 而言，每次取数组中间的值作为根节点，左右两边的值为左右子树的节点，然后递归地进行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := <span class="hljs-keyword">int</span>(<span class="hljs-built_in">len</span>(nums) / <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> &amp;TreeNode&#123;nums[mid], sortedArrayToBST(nums[:mid]), sortedArrayToBST(nums[mid+<span class="hljs-number">1</span>:])&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的层次遍历</title>
    <link href="/leetcode/top-interview-questions-easy/binary-tree-level-order-traversal/"/>
    <url>/leetcode/top-interview-questions-easy/binary-tree-level-order-traversal/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnldjj/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnldjj/</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/</a></p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>显然应该用广度优先搜索。由于返回的节点需要按层次分组，因此需要知道当前是在哪一层。</p><p><strong>解决方法</strong>：队列中存放一层的结点，每一次直接取一层的出来，并把下一层的放进去。这样实际上每一次都是把队列取空了，然后再填上。取之前先记录队列的元素个数，然后一个循环取出来就完事了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    queue := []*TreeNode&#123;root&#125;<br>    result := [][]<span class="hljs-keyword">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> || root != <span class="hljs-literal">nil</span> &#123;<br>        level := <span class="hljs-built_in">len</span>(queue)<br>        values := []<span class="hljs-keyword">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; level; i++ &#123;<br>            root = queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>                values = <span class="hljs-built_in">append</span>(values, root.Val)<br>                queue = <span class="hljs-built_in">append</span>(queue, root.Left)<br>                queue = <span class="hljs-built_in">append</span>(queue, root.Right)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(values) != <span class="hljs-number">0</span> &#123;<br>            result = <span class="hljs-built_in">append</span>(result, values)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称二叉树</title>
    <link href="/leetcode/top-interview-questions-easy/symmetric-tree/"/>
    <url>/leetcode/top-interview-questions-easy/symmetric-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn7ihv/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn7ihv/</a></p><p><a href="https://leetcode-cn.com/problems/symmetric-tree/solution/">https://leetcode-cn.com/problems/symmetric-tree/solution/</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>判断二叉树是否对称，就是判断根节点的左右子节点是否相同，且它们的后续子节点也是对称的。<br>即：<code>left.Left == right.Right &amp;&amp; left.Right == right.Left</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(root.Left, root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(left *TreeNode, right *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> left.Val != right.Val &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(left.Left, right.Right) &amp;&amp; helper(left.Right, right.Left)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>一样的思路，两个结点为一组进栈出栈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <br>    stack := []*TreeNode&#123;&#125;<br><br>    stack = <span class="hljs-built_in">append</span>(stack, root.Left)<br>    stack = <span class="hljs-built_in">append</span>(stack, root.Right)<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) != <span class="hljs-number">0</span> &#123;<br>        right := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        left := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-2</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-2</span>]<br><br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> || left.Val != right.Val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <br>        stack = <span class="hljs-built_in">append</span>(stack, left.Left)<br>        stack = <span class="hljs-built_in">append</span>(stack, right.Right)<br><br>        stack = <span class="hljs-built_in">append</span>(stack, right.Left)<br>        stack = <span class="hljs-built_in">append</span>(stack, left.Right)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="/leetcode/top-interview-questions-easy/validate-binary-search-tree/"/>
    <url>/leetcode/top-interview-questions-easy/validate-binary-search-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn08xg/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn08xg/</a></p><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/">https://leetcode-cn.com/problems/validate-binary-search-tree/solution/</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>注意，验证 BST 不能够只比较左右子节点与自己的值，而必须保证所有左侧的节点都要小于自己（右侧同理）。解决办法就是传入额外的上下界参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> helper(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(root *TreeNode, lower, upper <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt;= lower || root.Val &gt;= upper &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="遍历后判断"><a href="#遍历后判断" class="headerlink" title="遍历后判断"></a>遍历后判断</h2><p>BST 中序遍历的结果是升序列表。</p><p>前序遍历、中序遍历、后续遍历都是<strong>深度优先遍历</strong>，可以使用栈来实现（广度优先是队列）。</p><p>中序遍历时，先不停地把左子节点压入栈，然后执行访问操作，操作完后出栈。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    inorder := math.MinInt64<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> || root != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">for</span> root != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, root)<br>            root = root.Left<br>        &#125;<br>        root = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        <span class="hljs-keyword">if</span> root.Val &lt;= inorder &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        inorder = root.Val<br>        root = root.Right<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的最大深度</title>
    <link href="/leetcode/top-interview-questions-easy/maximum-depth-of-binary-tree/"/>
    <url>/leetcode/top-interview-questions-easy/maximum-depth-of-binary-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnd69e/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnd69e/</a></p><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/</a></p><h2 id="深度优先（递归）"><a href="#深度优先（递归）" class="headerlink" title="深度优先（递归）"></a>深度优先（递归）</h2><p>树的深度优先搜索算法一般用递归实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(maxDepth(root.Left), maxDepth(root.Right))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><p>一般用队列（数组）实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    queue := []*TreeNode&#123;&#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        sz := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> sz &gt; <span class="hljs-number">0</span> &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>            sz--<br>        &#125;<br>        ans++<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环形链表</title>
    <link href="/leetcode/top-interview-questions-easy/linked-list-cycle/"/>
    <url>/leetcode/top-interview-questions-easy/linked-list-cycle/</url>
    
    <content type="html"><![CDATA[<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希数据类型来记录节点是否存在过，key 可以是节点的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">bool</span>)<br><br>    curr := head<br><br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> m[curr] == <span class="hljs-literal">true</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        m[curr] = <span class="hljs-literal">true</span><br>        curr = curr.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>map</code> 类型要用 make 来初始化，如果不初始化它的值就是 <code>nil</code></li><li>函数参数中，<code>a &amp;int</code> 是按引用传递，<code>a *int</code> 是传递了一个指针，这个 <code>a</code> 的类型就是 <code>*int</code> （int 指针），指针类型可以用作 <code>map</code> 的 key。</li><li>因此在这个代码中，key 是 <code>*ListNode</code> 类型的，直接用变量 <code>curr</code> 就可以索引这个 map。</li></ul><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>如果链表有环，快慢指针最终会相遇。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    fast, slow := head, head<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;<br>        fast = fast.Next.Next<br>        slow = slow.Next<br>        <span class="hljs-keyword">if</span> fast == slow &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文链表</title>
    <link href="/leetcode/top-interview-questions-easy/palindrome-linked-list/"/>
    <url>/leetcode/top-interview-questions-easy/palindrome-linked-list/</url>
    
    <content type="html"><![CDATA[<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnv1oc/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnv1oc/</a></p><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/">https://leetcode-cn.com/problems/palindrome-linked-list/solution/</a></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>把所有值存到栈（数组）中，然后前后指针来检查是否为回文。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    values := []<span class="hljs-keyword">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        values = <span class="hljs-built_in">append</span>(values, head.Val)<br>        head = head.Next<br>    &#125;<br><br>    n := <span class="hljs-built_in">len</span>(values)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> values[:n/<span class="hljs-number">2</span>] &#123;<br>        <span class="hljs-keyword">if</span> v != values[n<span class="hljs-number">-1</span>-i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>使用快慢指针，慢指针走 1 步时快指针走 2 步，这样在快指针到达末尾时，慢指针恰好在链表的中间。</p><p>反转后半部分链表，然后检查是否是回文，这样时间复杂度还是 O(n)，空间复杂度只有 O(1)了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    fast, slow := head, head<br><br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> fast != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 奇数个节点</span><br>        slow = slow.Next <span class="hljs-comment">// 跳过节点中点，只逆转后半截</span><br>    &#125;<br><br>    revHead := reverse(slow)<br><br>    <span class="hljs-keyword">for</span> revHead != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> head.Val != revHead.Val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        head = head.Next<br>        revHead = revHead.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">var</span> prev *ListNode<br>    curr := head<br><br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        next := curr.Next<br>        curr.Next = prev<br>        prev = curr<br>        curr = next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>类似于二叉树的后序遍历，单链表也能从后往前遍历，只要在<strong>调用递归函数之后</strong>进行访问操作就可以了，例如：（JAVA）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printListNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    printListNode(head.next);<br>    System.out.println(head.val);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此也可以在递归中从后往前走的时候，用一个<strong>全局变量</strong>来储存从前往后走的指针，递归每走一步，这个指针也往前走一步，这样就能实现两头的访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> temp *ListNode<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    temp = head<br>    <span class="hljs-keyword">return</span> check(head)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(node *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    res := check(node.Next) &amp;&amp; node.Val == temp.Val<br>    temp = temp.Next<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>可以把递归视作函数调用栈，因此空间复杂度依然是 O(n)。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="/leetcode/top-interview-questions-easy/merge-two-sorted-lists/"/>
    <url>/leetcode/top-interview-questions-easy/merge-two-sorted-lists/</url>
    
    <content type="html"><![CDATA[<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnnbp2/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnnbp2/</a></p><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/</a></p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>哪个表的表头更小，就连上那个节点，并把对应的表头向后移动，直到有一方变成空的位置，连上另一个非空的表，完事。</p><p>dummy head 在这里很好用，这种需要返回链表头的，记得保存 head 变量用于返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    head := &amp;ListNode&#123;<span class="hljs-number">-999</span>, <span class="hljs-literal">nil</span>&#125;<br>    curr := head<br>    <br>    <span class="hljs-keyword">for</span> list1 != <span class="hljs-literal">nil</span> &amp;&amp; list2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>            curr.Next = list1<br>            list1 = list1.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            curr.Next = list2<br>            list2 = list2.Next<br>        &#125;<br>        curr = curr.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1 == <span class="hljs-literal">nil</span> &#123;<br>        curr.Next = list2<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        curr.Next = list1<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>关键难点是如何递归，返回什么，如何使用返回值。</p><ul><li>如何递归：小的那个节点，它的下一个节点是已经整理好的序列的头</li><li>返回什么：因为要返回整理好序列的头，这个小的节点就是，返回即可</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> list1 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list2<br>    &#125;<br>    <span class="hljs-keyword">if</span> list2 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list1<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>        list1.Next = mergeTwoLists(list1.Next, list2)<br>        <span class="hljs-keyword">return</span> list1<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        list2.Next = mergeTwoLists(list1, list2.Next)<br>        <span class="hljs-keyword">return</span> list2<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表</title>
    <link href="/leetcode/top-interview-questions-easy/reverse-linked-list/"/>
    <url>/leetcode/top-interview-questions-easy/reverse-linked-list/</url>
    
    <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnnhm6/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnnhm6/</a></p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/">https://leetcode-cn.com/problems/reverse-linked-list/solution/</a></p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>迭代进行中需要储存好前一个节点、当前节点、下一节点的指针，以便操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">var</span> prev *ListNode<br>    curr := head<br><br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        next := curr.Next<br>        curr.Next = prev<br>        prev = curr<br>        curr = next<br><br>        <span class="hljs-comment">// 或者利用平行赋值简写为一行</span><br>        <span class="hljs-comment">// curr.Next, prev, curr = prev, curr, curr.Next</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>主要在于如何返回反转后的头节点，答案就是记住它（变量 <code>p</code>），然后层层直接返回。</p><p>其中递归所需的空间复杂度是 O(n)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    p := reverseList(head.Next)<br><br>    head.Next.Next = head<br>    head.Next = <span class="hljs-literal">nil</span><br><br>    <span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <link href="/leetcode/top-interview-questions-easy/remove-nth-node-from-end-of-list/"/>
    <url>/leetcode/top-interview-questions-easy/remove-nth-node-from-end-of-list/</url>
    
    <content type="html"><![CDATA[<h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn2925/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn2925/</a></p><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/</a></p><h2 id="获取链表长度"><a href="#获取链表长度" class="headerlink" title="获取链表长度"></a>获取链表长度</h2><p>第一次遍历走到链表结尾，算出链表长度。第二次遍历到删除的节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-comment">// 计算链表长度</span><br>    counter := <span class="hljs-number">0</span><br>    curr := head<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        counter ++<br>        curr = curr.Next<br>    &#125;<br><br>    <span class="hljs-comment">// 移除链表头的情况</span><br>    <span class="hljs-keyword">if</span> counter == n &#123;<br>        <span class="hljs-keyword">return</span> head.Next<br>    &#125;<br><br>    curr = head<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; counter - n - <span class="hljs-number">1</span>; i++ &#123;<br>        curr = curr.Next<br>    &#125;<br>    curr.Next = curr.Next.Next<br><br>    <span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上给链表加一个假的头可以避免处理删除节点为头节点的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    dummyHead := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125; <span class="hljs-comment">// 加入假的头</span><br><br>    <span class="hljs-comment">// 计算链表长度</span><br>    counter := <span class="hljs-number">0</span><br>    curr := dummyHead<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        counter ++<br>        curr = curr.Next<br>    &#125;<br><br>    curr = dummyHead<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; counter - n - <span class="hljs-number">1</span>; i++ &#123;<br>        curr = curr.Next<br>    &#125;<br>    curr.Next = curr.Next.Next<br><br>    <span class="hljs-keyword">return</span> dummyHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>由于我们需要找到倒数第 n 个节点，因此我们可以使用两个指针 first 和 second 同时对链表进行遍历，并且 first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    dummyHead := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br><br>    first := dummyHead<br>    <span class="hljs-comment">// 移动 first 指针，使得它超前 second 指针 n 个节点</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        first = first.Next<br>    &#125;<br>    second := dummyHead<br><br>    <span class="hljs-comment">// 同时移动两个指针，直至 first 指针到最后一个节点，此时 second 指针就是要删除节点的前驱节点</span><br>    <span class="hljs-keyword">for</span> first.Next != <span class="hljs-literal">nil</span> &#123;<br>        first = first.Next<br>        second = second.Next<br>    &#125;<br><br>    second.Next = second.Next.Next <span class="hljs-comment">// 执行删除</span><br><br>    <span class="hljs-keyword">return</span> dummyHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>所有节点依次入栈，然后弹出第 n 个节点就是要删除的节点，且此时栈顶正好是它前一个节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br>    first, second := head, dummy<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        first = first.Next<br>    &#125;<br>    <span class="hljs-keyword">for</span> ; first != <span class="hljs-literal">nil</span>; first = first.Next &#123;<br>        second = second.Next<br>    &#125;<br>    second.Next = second.Next.Next<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个实现中，本质上是用的数组作为栈来储存遍历过的节点，第二次就无需再从头遍历。属于是用空间换时间。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
      <tag>双指针</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表中的节点</title>
    <link href="/leetcode/top-interview-questions-easy/delete-node-in-a-linked-list/"/>
    <url>/leetcode/top-interview-questions-easy/delete-node-in-a-linked-list/</url>
    
    <content type="html"><![CDATA[<h1 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnarn7/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnarn7/</a></p><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/">https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/</a></p><h2 id="狸猫换太子"><a href="#狸猫换太子" class="headerlink" title="狸猫换太子"></a>狸猫换太子</h2><p>无法获取链表的前一个节点，直接将自己复制成下一个节点，然后删除下一个节点，就相当于删除了自己</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(node *ListNode)</span></span> &#123;<br>    node.Val = node.Next.Val<br>    node.Next = node.Next.Next<br>&#125;<br></code></pre></td></tr></table></figure><p>目标：杀掉A</p><blockquote><p>正常杀手需要找到 A 的把柄才可以杀掉 A <br><br>可现在找到 A 本人后竟然没有可以获取 A 把柄的途径 <br><br>A 得知我们要杀他，心生一计，可助你完成任务 <br><br>A 说我有 B 的把柄，你杀了 B，我改头换面，以 B 的身份活着 <br><br>GC 也会自动清理掉 B 的尸体，没人会知道的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长公共前缀</title>
    <link href="/leetcode/top-interview-questions-easy/longest-common-prefix/"/>
    <url>/leetcode/top-interview-questions-easy/longest-common-prefix/</url>
    
    <content type="html"><![CDATA[<h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnmav1/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnmav1/</a></p><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/">https://leetcode-cn.com/problems/longest-common-prefix/solution/</a></p><h2 id="横向扫描"><a href="#横向扫描" class="headerlink" title="横向扫描"></a>横向扫描</h2><p>遍历所有字符串，计算并更新公共前缀。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(strs []<span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span></span> &#123;<br>    prefix = strs[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, str := <span class="hljs-keyword">range</span> strs &#123;<br>        prefix = LCP(prefix, str)<br>        <span class="hljs-keyword">if</span> prefix == <span class="hljs-string">&quot;&quot;</span> &#123;<br>            <span class="hljs-keyword">return</span> <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LCP</span><span class="hljs-params">(str1 <span class="hljs-keyword">string</span>, str2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    index := <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> index &lt; <span class="hljs-built_in">len</span>(str1) &amp;&amp; index &lt; <span class="hljs-built_in">len</span>(str2) &amp;&amp; str1[index] == str2[index] &#123;<br>        index++<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> str1[:index]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用字符切片来保存返回结果</li></ul><h2 id="纵向扫描"><a href="#纵向扫描" class="headerlink" title="纵向扫描"></a>纵向扫描</h2><p>遍历字符串相同位置的字母，例如对于 flow flower florance，取第一个 flow 作为基准，先检查 f，然后检查fl，然后检查 flo。<br>以此类推，直到某个单词读完了或者有不通过检查的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(strs []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sb strings.Builder<br>    flag := <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> strs[<span class="hljs-number">0</span>] &#123;<br>        <span class="hljs-keyword">for</span> _, rs := <span class="hljs-keyword">range</span> strs &#123;<br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(rs) || r != <span class="hljs-keyword">rune</span>(rs[i]) &#123;<br>                flag = <span class="hljs-literal">false</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> flag &#123;<br>           sb.WriteRune(r)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sb.String()<br>&#125;<br></code></pre></td></tr></table></figure><p>我的解法：用 <code>strings.Builder</code> 来拼接字符串，其实没有必要，对于这种不需要重新组装字符串的情况，直接用切片就行了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(strs []<span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(strs[<span class="hljs-number">0</span>]); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(strs); j++ &#123;<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(strs[j]) || strs[j][i] != strs[<span class="hljs-number">0</span>][i] &#123;<br>                <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>][:i]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外观数列</title>
    <link href="/leetcode/top-interview-questions-easy/count-and-say/"/>
    <url>/leetcode/top-interview-questions-easy/count-and-say/</url>
    
    <content type="html"><![CDATA[<h1 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnpvdm/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnpvdm/</a></p><p><a href="https://leetcode-cn.com/problems/count-and-say/">https://leetcode-cn.com/problems/count-and-say/</a></p><p>顺带一提，从今天开始用 Golang 刷题，以便掌握算法的同时熟悉语言特性。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countAndSay</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span><br>    &#125;<br><br>    str := countAndSay(n - <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">var</span> sb strings.Builder<br>    <br>    <span class="hljs-keyword">for</span> start, end := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>; start &lt; <span class="hljs-built_in">len</span>(str); start = end &#123;<br>        <span class="hljs-keyword">for</span> end &lt; <span class="hljs-built_in">len</span>(str) &amp;&amp; str[end] == str[start] &#123;<br>            end++<br>        &#125;<br>        sb.WriteString(strconv.Itoa(end - start))<br>        sb.WriteByte(str[start])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sb.String()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Note-of-Golang"><a href="#Note-of-Golang" class="headerlink" title="Note of Golang"></a>Note of Golang</h2><ul><li>用 <code>strings.Builder</code> 来拼接字符串，因为如果使用 <code>+=</code> 运算符的话会在不停分配新的内存导致效率变低。</li><li>Golang 中变量可以平行赋值，先计算等式右边的值，然后从左到右依次赋值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 部署 pytorch 应用</title>
    <link href="/essay/docker-deployment/"/>
    <url>/essay/docker-deployment/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-部署-pytorch-应用-GPU"><a href="#Docker-部署-pytorch-应用-GPU" class="headerlink" title="Docker 部署 pytorch 应用 (GPU)"></a>Docker 部署 pytorch 应用 (GPU)</h1><h2 id="拉取-python-3-8-镜像"><a href="#拉取-python-3-8-镜像" class="headerlink" title="拉取 python 3.8 镜像"></a>拉取 python 3.8 镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull python:3.8.12<br></code></pre></td></tr></table></figure><p>buster, bullseye 等的区别：<a href="https://stackoverflow.com/questions/52083380/in-docker-image-names-what-is-the-difference-between-alpine-jessie-stretch-an">In Docker image names what is the difference between Alpine, Jessie, Stretch, and Buster?</a></p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><h3 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写  Dockerfile"></a>编写  Dockerfile</h3><p>RUN 命令可以根据情况随意更改，这里是安装 GPU 版的 pytorch 以及其他 python 依赖。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.8</span>.<span class="hljs-number">12</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><br><br><span class="hljs-keyword">ADD</span><span class="bash"> . /app</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> git reset HEAD --hard</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="hljs-keyword">RUN</span><span class="bash"> pip install torch==1.10.1+cu113 torchvision==0.11.2+cu113 torchaudio===0.10.1+cu113 -f https://download.pytorch.org/whl/cu113/torch_stable.html</span><br><span class="hljs-keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span><br><br><span class="hljs-keyword">CMD</span><span class="bash"> python serve_pytorch.py <span class="hljs-comment"># optional</span></span><br></code></pre></td></tr></table></figure><h3 id="从-Dockerfile-构建镜像"><a href="#从-Dockerfile-构建镜像" class="headerlink" title="从 Dockerfile 构建镜像"></a>从 Dockerfile 构建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t target_name .<br></code></pre></td></tr></table></figure><h2 id="允许容器访问-GPU"><a href="#允许容器访问-GPU" class="headerlink" title="允许容器访问 GPU"></a>允许容器访问 GPU</h2><p>参考：<a href="https://github.com/NVIDIA/nvidia-container-runtime">https://github.com/NVIDIA/nvidia-container-runtime</a></p><ol><li><p>安装 nvidia-container-runtime <a href="https://nvidia.github.io/nvidia-container-runtime/">https://nvidia.github.io/nvidia-container-runtime/</a></p></li><li><p>修改 /etc/docker/daemon.json</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;runtimes&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;nvidia&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;/usr/bin/nvidia-container-runtime&quot;</span>,<br>            <span class="hljs-attr">&quot;runtimeArgs&quot;</span>: []<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>新建并运行容器</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --gpus all image_name bash<br></code></pre></td></tr></table></figure></li></ol><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="列出本地镜像"><a href="#列出本地镜像" class="headerlink" title="列出本地镜像"></a>列出本地镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker image ls<br></code></pre></td></tr></table></figure><h3 id="从镜像启动新的容器"><a href="#从镜像启动新的容器" class="headerlink" title="从镜像启动新的容器"></a>从镜像启动新的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run image_name<br></code></pre></td></tr></table></figure><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it container_name bash<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yeasy.gitbook.io/docker_practice/">Docker 从入门到实践</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将 transformers 模型转换为 ONNX 格式并用 TensorRT 加速</title>
    <link href="/nlp/convert-transformers-to-onnx/"/>
    <url>/nlp/convert-transformers-to-onnx/</url>
    
    <content type="html"><![CDATA[<h1 id="将-transformers-模型转换为-ONNX-格式并用-TensorRT-加速"><a href="#将-transformers-模型转换为-ONNX-格式并用-TensorRT-加速" class="headerlink" title="将 transformers 模型转换为 ONNX 格式并用 TensorRT 加速"></a>将 transformers 模型转换为 ONNX 格式并用 TensorRT 加速</h1><p>然后就可以优化模型，加速推理了。这里以 BERT 为例。</p><h2 id="转换-ONNX-文件"><a href="#转换-ONNX-文件" class="headerlink" title="转换 ONNX 文件"></a>转换 ONNX 文件</h2><p>运行 transformers 官方提供的脚本 <a href="https://github.com/huggingface/transformers/blob/master/src/transformers/convert_graph_to_onnx.py">convert_graph_to_onnx.py</a> ，直接得到转换好格式的 ONNX 模型。（或者直接 import 进来，调用里面的 convert() 方法。）</p><p>注意 pipeline 要跟自己的模型任务对应上，否则无法正常工作。例如这里我用的是 <code>BertForSequenceClassification</code> ，pipeline 就选 <code>sentiment-analysis</code> （等价于 <code>TextClassificationPipeline</code>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m transformers.convert_graph_to_onnx --pipeline sentiment-analysis --framework pt --model &quot;./models/chinese-bert-wwm-ext_2021-12-06_11-33-24&quot; --check-loading --quantize &quot;./models/onnx/chinese-bert-wwm-ext/model.onnx&quot;<br></code></pre></td></tr></table></figure><p>注意模型转换时控制台的打印信息，确定模型的输入输出跟原来的 forward() 函数一致。<code>--model</code> 参数就是用 save_pretrained() 方法保存的模型。指定 <code>--quantize</code> 参数会生成 optimize 和 quantize 后的模型。脚本运行完后，我的目录结构如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 1c">models<br><span class="hljs-string">| chinese-bert-wwm-ext_2021-12-06_11-33-24</span><br><span class="hljs-string">| added_tokens.json</span><br><span class="hljs-string">| config.json</span><br><span class="hljs-string">| pytorch_model.bin</span><br><span class="hljs-string">| tokenizer.json</span><br><span class="hljs-string">| tokenizer_config.json</span><br><span class="hljs-string">| special_tokens_map.json</span><br><span class="hljs-string">| vocab.txt</span><br><span class="hljs-string">| onnx</span><br><span class="hljs-string">| chinese-bert-wwm-ext</span><br><span class="hljs-string">| model.onnx</span><br><span class="hljs-string">| model-optimized.onnx</span><br><span class="hljs-string">| model-optimized-quantized.onnx</span><br></code></pre></td></tr></table></figure><h2 id="在-CPU-上进行推理"><a href="#在-CPU-上进行推理" class="headerlink" title="在 CPU 上进行推理"></a>在 CPU 上进行推理</h2><p>至此已经可以用 ONNX 进行推理了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> onnxruntime <span class="hljs-keyword">as</span> ort<br><span class="hljs-keyword">from</span> transformers.models.bert <span class="hljs-keyword">import</span> BertTokenizerFast<br><br>model_path = <span class="hljs-string">&quot;./models/chinese-bert-wwm-ext_2021-12-06_11-33-24&quot;</span><br>onnx_path = <span class="hljs-string">&quot;./models/onnx/chinese-bert-wwm-ext/model.onnx&quot;</span><br>tokenizer = BertTokenizerFast.from_pretrained(model_path)<br><br>ort_session = ort.InferenceSession(onnx_path)<br><br>inputs = tokenizer([<span class="hljs-string">&quot;hello&quot;</span>], [<span class="hljs-string">&quot;motherfucker&quot;</span>])<br>outputs = ort_session.run(<span class="hljs-literal">None</span>, <span class="hljs-built_in">dict</span>(inputs))<br><br><span class="hljs-comment"># outputs: [array([[ 3.5934877, -3.5006552]], dtype=float32)]</span><br></code></pre></td></tr></table></figure><p>run() 方法中需要传入对应名字的参数。</p><h2 id="下载并安装-TensorRT"><a href="#下载并安装-TensorRT" class="headerlink" title="下载并安装 TensorRT"></a>下载并安装 TensorRT</h2><p>ONNX 本身也会加速推理，但是可以利用 TensorRT 进一步加速 GPU 上的推理速度。CPU 上也有类似的加速框架 openvino。这些是特定硬件平台（nvidia 和 intel）自家的加速引擎。</p><p>去英伟达官网 <a href="https://developer.nvidia.com/zh-cn/tensorrt">NVIDIA TensorRT</a> 下载 TensorRT。</p><p><strong>重要</strong>：TensorRT 版本要和 CUDA、cuBLAS、cuDNN、onnx runtime 的版本都对应上，见 <a href="https://onnxruntime.ai/docs/execution-providers/TensorRT-ExecutionProvider.html#requirements">Requirements</a> 。一个版本号会有两种版本，EA (early access) 和 GA (general availability)，选 GA 就好。</p><blockquote><p>Ensure that you have the following dependencies installed.</p><ul><li><a href="https://docs.nvidia.com/cuda/archive/10.2/index.html">CUDA 10.2</a>, <a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#cuda-whats-new-11Upd1">11.0 update 1</a>, <a href="https://developer.nvidia.com/cuda-toolkit-archive">11.1 update 1</a>, <a href="https://developer.nvidia.com/cuda-toolkit-archive">11.2 update 2</a>, <a href="https://developer.nvidia.com/cuda-toolkit-archive">11.3 update 1</a>, or <a href="https://developer.nvidia.com/cuda-toolkit-archive">11.4 update 2</a></li><li><a href="https://docs.nvidia.com/deeplearning/cudnn/release-notes/rel_8.html#rel-821">cuDNN 8.2.1</a></li></ul></blockquote><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>这里我的版本是 8.2 GA。Windows 平台下载下来的是一个 zip 文件，安装说明见 <a href="https://docs.nvidia.com/deeplearning/tensorrt/install-guide/index.html#installing-zip">4.7. Zip File Installation</a> 。实际就是把 lib 目录下的一堆 dll 文件扔进 CUDA 的 bin 目录下，然后 pip install 几个本地的包。安装完成后尝试 import tensorrt 验证一下是否安装成功。（官方说是用 visual studio 编译几个示例项目）</p><h2 id="在-GPU-上进行推理"><a href="#在-GPU-上进行推理" class="headerlink" title="在 GPU 上进行推理"></a>在 GPU 上进行推理</h2><p>代码跟之前几乎没区别，就是添加了个 providers 参数。也可以不用 TensorRT 只用 CUDA，把 <code>TensorrtExecutionProvider</code> 去掉即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> onnxruntime <span class="hljs-keyword">as</span> ort<br><span class="hljs-keyword">from</span> transformers.models.bert <span class="hljs-keyword">import</span> BertTokenizerFast<br><br>model_path = <span class="hljs-string">&quot;./models/chinese-bert-wwm-ext_2021-12-06_11-33-24&quot;</span><br>onnx_path = <span class="hljs-string">&quot;./models/onnx/chinese-bert-wwm-ext/model.onnx&quot;</span><br>tokenizer = BertTokenizerFast.from_pretrained(model_path)<br><br>ort_session = ort.InferenceSession(onnx_path, providers=[<span class="hljs-string">&#x27;TensorrtExecutionProvider&#x27;</span>, <span class="hljs-string">&#x27;CUDAExecutionProvider&#x27;</span>])<br><span class="hljs-comment"># ort_session = ort.InferenceSession(onnx_path, providers=[&#x27;CUDAExecutionProvider&#x27;])  # CUDA only</span><br><span class="hljs-comment"># ort_session = ort.InferenceSession(onnx_path, providers=[&#x27;CPUExecutionProvider&#x27;])  # CPU</span><br><br>inputs = tokenizer([<span class="hljs-string">&quot;hello&quot;</span>], [<span class="hljs-string">&quot;motherfucker&quot;</span>])<br>outputs = ort_session.run(<span class="hljs-literal">None</span>, <span class="hljs-built_in">dict</span>(inputs))<br><br><span class="hljs-comment"># outputs: [array([[ 3.5934877, -3.5006552]], dtype=float32)]</span><br></code></pre></td></tr></table></figure><h3 id="报警告"><a href="#报警告" class="headerlink" title="报警告"></a>报警告</h3><p>实际使用中，不报错误就算成功，但是可能会报如下警告：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">15</span>:<span class="hljs-number">13</span>:<span class="hljs-number">31.6350799</span> [W:onnxruntime:<span class="hljs-keyword">Default</span>, tensorrt_execution_provider.h:<span class="hljs-number">53</span> onnxruntime::TensorrtLogger::<span class="hljs-keyword">log</span>] [<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">07</span>:<span class="hljs-number">13</span>:<span class="hljs-number">31</span> <span class="hljs-built_in">WARNING</span>] D:\a\_work\<span class="hljs-number">1</span>\s\cmake\<span class="hljs-keyword">external</span>\onnx-tensorrt\onnx2trt_utils.cpp:<span class="hljs-number">364</span>: Your ONNX model has been <span class="hljs-keyword">generated</span> <span class="hljs-keyword">with</span> INT64 weights, <span class="hljs-keyword">while</span> TensorRT does <span class="hljs-keyword">not</span> natively support INT64. Attempting <span class="hljs-keyword">to</span> <span class="hljs-keyword">cast</span> down <span class="hljs-keyword">to</span> INT32.<br><br><span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">15</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50.2068278</span> [W:onnxruntime:<span class="hljs-keyword">Default</span>, tensorrt_execution_provider.h:<span class="hljs-number">53</span> onnxruntime::TensorrtLogger::<span class="hljs-keyword">log</span>] [<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">07</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> <span class="hljs-built_in">WARNING</span>] TensorRT was linked against cuBLAS/cuBLAS LT <span class="hljs-number">11.6</span><span class="hljs-number">.3</span> but loaded cuBLAS/cuBLAS LT <span class="hljs-number">11.3</span><span class="hljs-number">.0</span><br><span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">15</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50.2080023</span> [W:onnxruntime:<span class="hljs-keyword">Default</span>, tensorrt_execution_provider.h:<span class="hljs-number">53</span> onnxruntime::TensorrtLogger::<span class="hljs-keyword">log</span>] [<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">07</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> <span class="hljs-built_in">WARNING</span>] TensorRT was linked against cuDNN <span class="hljs-number">8.2</span><span class="hljs-number">.1</span> but loaded cuDNN <span class="hljs-number">8.0</span><span class="hljs-number">.5</span><br></code></pre></td></tr></table></figure><p>只要不报错误，无视即可，实际上不影响性能（大概）。</p><p>报了 3 个错误：</p><ol><li>ONNX 模型由 INT64 生成</li><li>cuBLAS 版本不对</li><li>cuDNN 版本不对</li></ol><p>第 2，3 点原因应该是是跟 pytorch 共用了一个 conda 环境，而 pytorch 本身硬编码了 cudnn 的链接，所以导致 cuda 和 cudnn 版本不符合。建议创建一个推理专用环境，跟 torch 的环境分开。可以在 <a href="https://docs.nvidia.com/cuda/archive">archieve</a> 的 release note 中查看不同 cuda 版本的子组件版本，例如：<a href="https://docs.nvidia.com/cuda/archive/11.3.1/cuda-toolkit-release-notes/index.html#cuda-major-component-versions">1.1. CUDA Toolkit Major Component Versions</a> 中的 cuBLAS 版本就是 11.5.1.109，可以根据这个选择合适的 TensorRT 版本。</p><h3 id="TensorRT-加载、推理速度比-CPU-还慢"><a href="#TensorRT-加载、推理速度比-CPU-还慢" class="headerlink" title="TensorRT 加载、推理速度比 CPU 还慢"></a>TensorRT 加载、推理速度比 CPU 还慢</h3><p>正常现象，跟 TensorRT 本身的机制有关，加载模型、第一次推理速度会特别慢，但是后面的就会很快了。参见：<a href="https://github.com/microsoft/onnxruntime/issues/7230#issuecomment-814619248">https://github.com/microsoft/onnxruntime/issues/7230#issuecomment-814619248</a></p><p>参考时间差异（batch_size = 1）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Load time:  <span class="hljs-number">14.695685863494873</span><br>Run time:  <span class="hljs-number">6.2073938846588135</span><br>Second run time:  <span class="hljs-number">0.23337483406066895</span><br></code></pre></td></tr></table></figure><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>torch == 1.8.0</p><p>transformers == 4.12.5</p><p>onnx == 1.10.2</p><p>onnxruntime-gpu == 1.10.0</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>CUDA：11.1.1_456.81_win10</p><p>cudnn：11.3-windows-x64-v8.2.1.32</p><p>TensorRT：8.2.1.8</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>pipeline 有哪些：<a href="https://huggingface.co/docs/transformers/master/en/main_classes/pipelines#pipelines">Pipelines</a> </p><p>哪些 pipeline 可以直接用官方脚本转换（直接看 help 信息）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">SUPPORTED_PIPELINES = [<br>    <span class="hljs-string">&quot;feature-extraction&quot;</span>,<br>    <span class="hljs-string">&quot;ner&quot;</span>,<br>    <span class="hljs-string">&quot;sentiment-analysis&quot;</span>,<br>    <span class="hljs-string">&quot;fill-mask&quot;</span>,<br>    <span class="hljs-string">&quot;question-answering&quot;</span>,<br>    <span class="hljs-string">&quot;text-generation&quot;</span>,<br>    <span class="hljs-string">&quot;translation_en_to_fr&quot;</span>,<br>    <span class="hljs-string">&quot;translation_en_to_de&quot;</span>,<br>    <span class="hljs-string">&quot;translation_en_to_ro&quot;</span>,<br>]<br></code></pre></td></tr></table></figure><p>transformers 官方文档：<a href="https://huggingface.co/docs/transformers/master/en/serialization#exporting-transformers-models">Exporting transformers models</a></p><p>官方博客：<a href="https://medium.com/microsoftazure/accelerate-your-nlp-pipelines-using-hugging-face-transformers-and-onnx-runtime-2443578f4333">Accelerate your NLP pipelines using Hugging Face Transformers and ONNX Runtime</a></p><p>PyTorch <a href="https://pytorch.org/docs/stable/onnx.html#">torch.onnx</a></p><p>一个也许有用的 GitHub issue：<a href="https://github.com/huggingface/transformers/issues/4825">Onnx converted model has its output shape modified when compared to original (finetuned) model</a></p><p>TensorRT 安装指南 <a href="https://docs.nvidia.com/deeplearning/tensorrt/install-guide/index.html">Install Guide</a></p><p>ONNX runtime 对 TensorRT 的支持：<a href="https://onnxruntime.ai/docs/execution-providers/TensorRT-ExecutionProvider.html">TensorRT Execution Provider</a>  其中，对于 CUDA 版本要求为 11.4 的，11.x都可以兼容。</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
      <category>transformers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
      <tag>transformers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对 HuggingFace Transformers 模型进行后训练</title>
    <link href="/nlp/postrain_transformers/"/>
    <url>/nlp/postrain_transformers/</url>
    
    <content type="html"><![CDATA[<h1 id="对-HuggingFace-Transformers-模型进行预训练-post-train-further-pretrain"><a href="#对-HuggingFace-Transformers-模型进行预训练-post-train-further-pretrain" class="headerlink" title="对 HuggingFace Transformers 模型进行预训练 (post-train / further pretrain)"></a>对 HuggingFace Transformers 模型进行预训练 (post-train / further pretrain)</h1><p>这几天需要对 BERT 进行进一步的预训练，而且是 MLM 和 NSP 两个任务一起。但是 transformers 官方只提供了 MLM 任务的训练例子。（可能是因为 RoBERTa 原论文中认为 NSP 任务没用）</p><p>后来终于在 stackoverflow 上找到了<a href="https://stackoverflow.com/questions/65646925/how-to-train-bert-from-scratch-on-a-new-domain-for-both-mlm-and-nsp">解决方法</a>。在自己的数据集上试验有效后记录于此。</p><h2 id="产生任务对应的标注数据"><a href="#产生任务对应的标注数据" class="headerlink" title="产生任务对应的标注数据"></a>产生任务对应的标注数据</h2><h3 id="使用-TextDatasetForNextSentencePrediction-构造-NSP-任务-Dataset"><a href="#使用-TextDatasetForNextSentencePrediction-构造-NSP-任务-Dataset" class="headerlink" title="使用 TextDatasetForNextSentencePrediction 构造 NSP 任务 Dataset"></a>使用 <code>TextDatasetForNextSentencePrediction</code> 构造 NSP 任务 Dataset</h3><p>文档：官方文档没写，需要阅读<a href="https://github.com/huggingface/transformers/blob/9f72e8f4e1e767c5f608dd135199e592255b8a69/src/transformers/data/datasets/language_modeling.py">源代码</a>。</p><p>数据格式：一行一句话，不同的文档之间空一行。</p><blockquote><ol><li>One sentence per line. These should ideally be actual sentences, not entire paragraphs or arbitrary spans of text. (Because we use the sentence boundaries for the “next sentence prediction” task).</li><li>Blank lines between documents. Document boundaries are needed so that the “next sentence prediction” task doesn’t span between documents.</li></ol></blockquote><p>输入例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">I am very happy.<br>Here is the second sentence.<br><br>A new document.<br></code></pre></td></tr></table></figure><h3 id="使用-DataCollatorForLanguageModeling-对数据进行-MLM-标注"><a href="#使用-DataCollatorForLanguageModeling-对数据进行-MLM-标注" class="headerlink" title="使用 DataCollatorForLanguageModeling 对数据进行 MLM 标注"></a>使用 <code>DataCollatorForLanguageModeling</code> 对数据进行 MLM 标注</h3><p>文档：<a href="https://huggingface.co/docs/transformers/main_classes/data_collator#transformers.DataCollatorForLanguageModeling">DataCollatorForLanguageModeling</a></p><p>注：无法使用 WWM （<a href="https://huggingface.co/docs/transformers/main_classes/data_collator#transformers.DataCollatorForWholeWordMask">DataCollatorForWholeWordMask</a>），因为它的实现中会丢弃掉 NSP Dataset 返回的一些值，只保留了 <code>input_ids</code> 和 <code>labels</code> 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>模型（使用专门的 <a href="https://huggingface.co/docs/transformers/master/en/model_doc/bert#transformers.BertForPreTraining">BertForPreTraining</a> 预训练类）、分词器定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers.models.bert <span class="hljs-keyword">import</span> BertTokenizerFast, BertForPreTraining<br><br>tokenizer = BertTokenizerFast.from_pretrained(model_name)<br>model = BertForPreTraining.from_pretrained(model_name)<br></code></pre></td></tr></table></figure><p>给分词器加入新的 token 并 resize 词表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenizer.add_tokens([<span class="hljs-string">&quot;[name]&quot;</span>, <span class="hljs-string">&quot;[gender]&quot;</span>])<br>tokenizer.add_special_tokens(&#123;<span class="hljs-string">&quot;eos_token&quot;</span>: <span class="hljs-string">&quot;[EOT]&quot;</span>&#125;)<br>model.resize_token_embeddings(<span class="hljs-built_in">len</span>(tokenizer))<br></code></pre></td></tr></table></figure><p>定义 dataset 和 collator。dataset 返回的样本会以字典形式传入到模型的 <code>__call__()</code> 方法（forward）中，因此需要检查是否构建了正确的数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers.data <span class="hljs-keyword">import</span> DataCollatorForLanguageModeling<br><span class="hljs-keyword">from</span> transformers.data.datasets <span class="hljs-keyword">import</span> TextDatasetForNextSentencePrediction<br><br>dataset = TextDatasetForNextSentencePrediction(tokenizer, <span class="hljs-string">&quot;./dataset_v2/pretrain.txt&quot;</span>, block_size=<span class="hljs-number">256</span>)<br>collator = DataCollatorForLanguageModeling(tokenizer, mlm=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>定义 <a href="https://huggingface.co/docs/transformers/master/en/main_classes/trainer#transformers.TrainingArguments">TrainingArgument</a> 以及 <a href="https://huggingface.co/docs/transformers/master/en/main_classes/trainer#transformers.Trainer">Trainer</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers.trainer <span class="hljs-keyword">import</span> TrainingArguments, Trainer<br><br>training_args = TrainingArguments(<br>    output_dir=out_dir,<br>    overwrite_output_dir=<span class="hljs-literal">True</span>,<br>    num_train_epochs=num_epochs,<br>    per_device_train_batch_size=<span class="hljs-number">64</span>,<br>    save_strategy=<span class="hljs-string">&quot;epoch&quot;</span><br>)<br><br>trainer = Trainer(<br>    model=model,<br>    args=training_args,<br>    data_collator=collator,<br>    train_dataset=dataset<br>)<br>trainer.train()<br></code></pre></td></tr></table></figure><p>最后保存模型以及分词器就完成了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenizer.save_pretrained(out_dir)<br>trainer.save_model()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
      <category>transformers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
      <tag>transformers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日阅读论文记录</title>
    <link href="/essay/paper-reading-record/"/>
    <url>/essay/paper-reading-record/</url>
    
    <content type="html"><![CDATA[<h1 id="每日阅读论文记录"><a href="#每日阅读论文记录" class="headerlink" title="每日阅读论文记录"></a>每日阅读论文记录</h1><h2 id="9-月"><a href="#9-月" class="headerlink" title="9 月"></a>9 月</h2><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>09/15</td><td>A Short Review: Deep Retrieval-Based Dialogue Systems</td><td></td></tr><tr><td>09/16</td><td>Improved Deep Learning Baselines for Ubuntu Corpus Dialogs</td><td>UDC</td></tr><tr><td>09/16</td><td>Sequential Attention-based Network for Noetic End-to-End Response Selection</td><td>ESIM</td></tr><tr><td>09/23</td><td>Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks</td><td>SBERT</td></tr><tr><td>09/24</td><td>Augmented SBERT: Data Augmentation Method for Improving Bi-Encoders for Pairwise Sentence Scoring Tasks</td><td></td></tr><tr><td>09/25</td><td>Supervised Learning of Universal Sentence Representations from Natural Language Inference Data</td><td>InferSent</td></tr><tr><td>09/26</td><td>Learning Semantic Textual Similarity from Conversations</td><td>USE</td></tr><tr><td>09/27</td><td>A SIMPLE BUT TOUGH-TO-BEAT BASELINE FOR SENTENCE EMBEDDINGS (undone)</td><td></td></tr><tr><td>09/27</td><td>An Effective Domain Adaptive Post-Training Method for BERT in Response Selection</td><td>BERT-VFT</td></tr><tr><td>09/28</td><td>Sequential Matching Network: A New Architecture for Multi-turn Response Selection in Retrieval-Based Chatbots</td><td>SMN</td></tr><tr><td>09/29</td><td>APPLYING DEEP LEARNING TO ANSWER SELECTION: A STUDY AND AN OPEN TASK</td><td>Siam-CNN</td></tr></tbody></table><h2 id="10-月"><a href="#10-月" class="headerlink" title="10 月"></a>10 月</h2><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>10/06</td><td>Learning an Effective Context-Response Matching Model with Self-Supervised Tasks for Retrieval-based Dialogues</td><td>BERT-SL</td></tr><tr><td>10/07</td><td>Pre-train, Prompt, and Predict: A Systematic Survey of Prompting Methods in Natural Language Processing</td><td></td></tr><tr><td>10/08</td><td>Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</td><td>PET</td></tr><tr><td>10/09</td><td>GPT Understands, Too</td><td>P-Tuning</td></tr><tr><td>10/09</td><td>SimCSE: Simple Contrastive Learning of Sentence Embeddings</td><td>SimCSE</td></tr><tr><td>10/10</td><td>Structural Pre-training for Dialogue Comprehension</td><td>SPIDER</td></tr><tr><td>10/11</td><td>What Makes for Good Views for Contrastive Learning?</td><td></td></tr><tr><td>10/21</td><td>ConSERT: A Contrastive Framework for Self-Supervised Sentence Representation Transfer</td><td>ConSERT</td></tr><tr><td>10/23</td><td>Fine-grained Post-training for Improving Retrieval-based Dialogue Systems</td><td>BERT-FP</td></tr><tr><td>10/26</td><td>SEMANTIC RE-TUNING WITH CONTRASTIVE TENSION</td><td>CT</td></tr><tr><td>10/27</td><td>PRE-TRAINING TASKS FOR EMBEDDING-BASED LARGE-SCALE RETRIEVAL</td><td></td></tr></tbody></table><h2 id="11-月"><a href="#11-月" class="headerlink" title="11 月"></a>11 月</h2><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>11/3</td><td>Building an Efficient and Effective Retrieval-based Dialogue System</td><td>BE/CE</td></tr></tbody></table><h2 id="12-月"><a href="#12-月" class="headerlink" title="12 月"></a>12 月</h2><p>才发现自己已经摆烂一个多月了。接下来重点放在代码实现上，读完论文一定要看代码。</p><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>12/6</td><td>Prompt Tuning Can Be Comparable to Fine-tuning Universally Across Scales and Tasks</td><td>P-Tuning v2</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PyMongo 基本概念和操作</title>
    <link href="/mongo/pymongo-basic/"/>
    <url>/mongo/pymongo-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="PyMongo-基本概念和操作"><a href="#PyMongo-基本概念和操作" class="headerlink" title="PyMongo 基本概念和操作"></a>PyMongo 基本概念和操作</h1><p>最近尝试用数据库来给数据集提前储存 encode 好的 embeddings，原本想用 Sqlite 的，但是想到各种储存列表、大数值向量都很麻烦，于是去试了试非关系型数据库 MongoDB，发现用的是真的方便真的爽。</p><p>本文通过 MongoDB 的 python 接口例子来说明常用的一些使用方法。</p><h2 id="MongoDB-基本概念"><a href="#MongoDB-基本概念" class="headerlink" title="MongoDB 基本概念"></a>MongoDB 基本概念</h2><p>一篇写的不错的知乎文章：<a href="https://zhuanlan.zhihu.com/p/87722764">https://zhuanlan.zhihu.com/p/87722764</a></p><h3 id="数据库基本模型"><a href="#数据库基本模型" class="headerlink" title="数据库基本模型"></a>数据库基本模型</h3><table><thead><tr><th>MongoDB 概念</th><th>对应的 SQL 概念</th><th>备注</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>一个数据库包含多个集合（collection）</td></tr><tr><td>collection</td><td>table</td><td>可以储存多个文档，且没有模式限制</td></tr><tr><td>document</td><td>row</td><td>由多个字段表示，使用的 BSON 格式（类似 JSON）</td></tr><tr><td>field</td><td>column</td><td>字段可储存任意数据格式，如列表</td></tr></tbody></table><h3 id="BSON-数据类型"><a href="#BSON-数据类型" class="headerlink" title="BSON 数据类型"></a>BSON 数据类型</h3><p>BSON，Binary JSON，不能说跟 JSON 很像，只能说是一模一样。（并不，实际上多了索引等数据，且支持的数据类型也更多）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;_id&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<span class="hljs-attr">&quot;first&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">&quot;last&quot;</span>: <span class="hljs-string">&quot;Backus&quot;</span>&#125;,<br>    <span class="hljs-attr">&quot;contribs&quot;</span>: [<span class="hljs-string">&quot;Fortran&quot;</span>, <span class="hljs-string">&quot;ALGOL&quot;</span>, <span class="hljs-string">&quot;Backus-Naur Form&quot;</span>, <span class="hljs-string">&quot;FP&quot;</span>],<br>    <span class="hljs-attr">&quot;awards&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;award&quot;</span>: <span class="hljs-string">&quot;W.W. McDowell Award&quot;</span>,<br>            <span class="hljs-attr">&quot;year&quot;</span>: <span class="hljs-number">1967</span>,<br>            <span class="hljs-attr">&quot;by&quot;</span>: <span class="hljs-string">&quot;IEEE Computer Society&quot;</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;award&quot;</span>: <span class="hljs-string">&quot;Draper Prize&quot;</span>,<br>            <span class="hljs-attr">&quot;year&quot;</span>: <span class="hljs-number">1993</span>,<br>            <span class="hljs-attr">&quot;by&quot;</span>: <span class="hljs-string">&quot;National Academy of Engineering&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>_id</code> 字段是一条记录的主键，在 collection 中是唯一的，可以由系统自动生成（类型为 <code>ObjectId</code>），也可以自己指定。</p><h2 id="PyMongo-基本操作"><a href="#PyMongo-基本操作" class="headerlink" title="PyMongo 基本操作"></a>PyMongo 基本操作</h2><p>记得先安装并 import 哦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<br></code></pre></td></tr></table></figure><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="连接数据库服务器（无密码）"><a href="#连接数据库服务器（无密码）" class="headerlink" title="连接数据库服务器（无密码）"></a>连接数据库服务器（无密码）</h4><p>默认端口号是 27017</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client = pymongo.MongoClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">27017</span>)<br></code></pre></td></tr></table></figure><h4 id="获取具体的数据库、集合"><a href="#获取具体的数据库、集合" class="headerlink" title="获取具体的数据库、集合"></a>获取具体的数据库、集合</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">client = pymongo.MongoClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">27017</span>)<br><br><span class="hljs-comment"># 获取名字为 udc 的数据库</span><br>db = client[<span class="hljs-string">&quot;udc&quot;</span>]<br><br><span class="hljs-comment"># 获取数据库中两个集合</span><br>example_collection = db[<span class="hljs-string">&quot;example&quot;</span>]<br>candidate_collection = db[<span class="hljs-string">&quot;candidate&quot;</span>]<br></code></pre></td></tr></table></figure><p>如果数据库或集合未被创建，则会新建一个。（实际的创建行为会在写入第一个记录时才发生）</p><h3 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h3><p>以在某个 collection 上的查询为例子，操作非常简单，指定对应的字段名即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">example_collection.find_one(&#123;<span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-number">100012</span>&#125;)<br></code></pre></td></tr></table></figure><p>其他具体操作请查阅 MongoDB 官方文档：<a href="https://docs.mongodb.com/manual/crud/">https://docs.mongodb.com/manual/crud/</a></p><p>以及 pymongo 的示例：<a href="https://pymongo.readthedocs.io/en/stable/tutorial.html">https://pymongo.readthedocs.io/en/stable/tutorial.html</a></p><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>聚合（aggregation）稍微复杂，重要的<strong>关联查询</strong>就是使用这种操作完成的。MongoDB 中，可以给一系列的聚合操作定义一个 pipeline，像流水线一样层层过滤和组装，得到最终结果。</p><p>流水线通常是一个字典列表， 列表中每一个字典都是一个聚合操作，字典的 key 就是下面这些 $ 开头的字符串，对应的 value 是具体的参数字典。PyMongo 的一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">pipeline = [<br>    &#123;<br>        <span class="hljs-string">&quot;$sample&quot;</span>: &#123;   <span class="hljs-comment"># 操作名称为 $sample</span><br>            <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">3</span>  <span class="hljs-comment"># 参数名 size 的值为 3</span><br>        &#125;<br>    &#125;,<br>    ...<br>]<br></code></pre></td></tr></table></figure><h4 id="常用的一些聚合操作类型"><a href="#常用的一些聚合操作类型" class="headerlink" title="常用的一些聚合操作类型"></a>常用的一些聚合操作类型</h4><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>$project</td><td>指定输出文档中的字段</td></tr><tr><td>$match</td><td>相当于 query 语句</td></tr><tr><td>$limit</td><td>限制传递给下一步的文档数量</td></tr><tr><td>$lookup</td><td>多表关联查询</td></tr><tr><td>$sample</td><td>随机取样</td></tr><tr><td>$group</td><td>根据 key 分组文档</td></tr><tr><td>$sort</td><td>根据指定的字段排序文档</td></tr></tbody></table><p>具体见：</p><ul><li><a href="https://docs.mongodb.com/manual/core/aggregation-pipeline/">https://docs.mongodb.com/manual/core/aggregation-pipeline/</a></li><li><a href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/">https://docs.mongodb.com/manual/meta/aggregation-quick-reference/</a></li></ul><h4 id="关联查询-lookup"><a href="#关联查询-lookup" class="headerlink" title="关联查询 $lookup"></a>关联查询 <code>$lookup</code></h4><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;$lookup&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;from&quot;</span>: <span class="hljs-string">&quot;candidate&quot;</span>,<br>    <span class="hljs-attr">&quot;localField&quot;</span>: <span class="hljs-string">&quot;candidate_ids&quot;</span>,<br>    <span class="hljs-attr">&quot;foreignField&quot;</span>: <span class="hljs-string">&quot;_id&quot;</span>,<br>    <span class="hljs-attr">&quot;as&quot;</span>: <span class="hljs-string">&quot;candidates&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>from</td><td>关联的外表</td></tr><tr><td>localField</td><td>本表的关联字段</td></tr><tr><td>foreignField</td><td>外表的关联字段</td></tr><tr><td>as</td><td>输出的字段值</td></tr></tbody></table><p>所以上面的语句就是我现在在 <code>example</code> 集合（本表）中，跑去看名为 <code>candidate</code> 的集合（外表），将本表中 <code>candidates_ids</code> 字段中与外表的 <code>_id</code> 字段进行关联，相同的值的外表文档输出到一个列表里，插入到本表文档中，字段名为 <code>candidates</code> 。</p><p>在我的例子中，我的 <code>candidates_ids </code> 本身就是一个列表，里面仅储存了另一个集合的主键（相当于外键），因此关联后返回一个列表，里面的元素是外表中的文档。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">_id:<span class="hljs-number">1100142</span><br>tag:<span class="hljs-string">&quot;dev&quot;</span><br>context:Array<br>response_id:<span class="hljs-string">&quot;9ZOANIYSNBUL&quot;</span><br>candidate_ids:Array<br>cadidates:Array<br></code></pre></td></tr></table></figure><h4 id="PyMongo-使用流水线进行聚合的示例"><a href="#PyMongo-使用流水线进行聚合的示例" class="headerlink" title="PyMongo 使用流水线进行聚合的示例"></a>PyMongo 使用流水线进行聚合的示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">pipeline = [<br>        &#123;<br>            <span class="hljs-string">&quot;$match&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-number">1105000</span><br>            &#125;<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;$sample&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">5</span><br>            &#125;<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;$lookup&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-string">&quot;candidate&quot;</span>,<br>                <span class="hljs-string">&quot;localField&quot;</span>: <span class="hljs-string">&quot;candidate_ids&quot;</span>,<br>                <span class="hljs-string">&quot;foreignField&quot;</span>: <span class="hljs-string">&quot;_id&quot;</span>,<br>                <span class="hljs-string">&quot;as&quot;</span>: <span class="hljs-string">&quot;candidates&quot;</span><br>            &#125;<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;$lookup&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-string">&quot;candidate&quot;</span>,<br>                <span class="hljs-string">&quot;localField&quot;</span>: <span class="hljs-string">&quot;response_id&quot;</span>,<br>                <span class="hljs-string">&quot;foreignField&quot;</span>: <span class="hljs-string">&quot;_id&quot;</span>,<br>                <span class="hljs-string">&quot;as&quot;</span>: <span class="hljs-string">&quot;response&quot;</span><br>            &#125;<br>        &#125;<br>    ]<br><br>    <span class="hljs-keyword">with</span> example_collection.aggregate(pipeline, batchSize=batch_size) <span class="hljs-keyword">as</span> cursor:<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cursor:<br>            <span class="hljs-built_in">print</span>(item[<span class="hljs-string">&quot;tag&quot;</span>])<br></code></pre></td></tr></table></figure><p>定义 <code>pipeline</code> 为聚合操作的列表，然后在 <code>example_collection</code> 集合上进行关联查询，返回一个 <code>cursor</code> 对象。可以直接遍历这个对象拿到值。</p><h3 id="cursor-对象"><a href="#cursor-对象" class="headerlink" title="cursor 对象"></a><code>cursor</code> 对象</h3><p>实际上是一个用于遍历 MongoDB 查询结果的工具。详见：<a href="https://pymongo.readthedocs.io/en/stable/api/pymongo/cursor.html">https://pymongo.readthedocs.io/en/stable/api/pymongo/cursor.html</a></p><p>具体用法有空另开一篇写，这篇就先到这儿了。</p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go build 命令用法</title>
    <link href="/programming/go-build/"/>
    <url>/programming/go-build/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-build-命令用法"><a href="#Go-build-命令用法" class="headerlink" title="Go build 命令用法"></a>Go build 命令用法</h1><h2 id="按文件打包"><a href="#按文件打包" class="headerlink" title="按文件打包"></a>按文件打包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build main.go utils.go<br></code></pre></td></tr></table></figure><h2 id="按包名打包"><a href="#按包名打包" class="headerlink" title="按包名打包"></a>按包名打包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build go-message-pusher<br></code></pre></td></tr></table></figure><h2 id="打包到不同操作系统"><a href="#打包到不同操作系统" class="headerlink" title="打包到不同操作系统"></a>打包到不同操作系统</h2><p>设置两个环境变量：</p><ul><li><code>GOARCH</code> = amd64</li><li><code>GOOS</code> = linux | windows</li></ul><h2 id="其他附加参数"><a href="#其他附加参数" class="headerlink" title="其他附加参数"></a>其他附加参数</h2><table><thead><tr><th>参数</th><th>备注</th></tr></thead><tbody><tr><td>-o</td><td>指定编译输出的名称</td></tr><tr><td>-i</td><td>安装作为目标依赖的包</td></tr><tr><td>-v</td><td>编译时显示包名</td></tr><tr><td>-p n</td><td>开启并发编译，默认情况下该值为 CPU 逻辑核数</td></tr><tr><td>-a</td><td>强制重新构建</td></tr><tr><td>-x</td><td>打印编译时会用到的所有命令</td></tr><tr><td>-n</td><td>打印编译时会用到的所有命令，但不真正执行</td></tr><tr><td>-race</td><td>开启竞态检测</td></tr></tbody></table><h2 id="GoLand-中的设置示例"><a href="#GoLand-中的设置示例" class="headerlink" title="GoLand 中的设置示例"></a>GoLand 中的设置示例</h2><p><img src="https://i.loli.net/2021/08/21/peVkNE19O4GwClj.png"></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串转换整数</title>
    <link href="/leetcode/top-interview-questions-easy/string-to-integer-atoi/"/>
    <url>/leetcode/top-interview-questions-easy/string-to-integer-atoi/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnoilh/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnoilh/</a></p><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p><h2 id="有限状态机-FSM"><a href="#有限状态机-FSM" class="headerlink" title="有限状态机 (FSM)"></a>有限状态机 (FSM)</h2><p>字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码。臃肿还是其次，一堆 if-else 各种边界条件严格的想吐。。</p><p>使用有限状态机实现各种状态之间的转移。根据题目，容易画出来状态机图：</p><p><img src="https://i.loli.net/2021/08/06/3OLdx5pKkloamte.png"></p><p>状态机可以用一个状态转移表来实现。如图所示，行头是当前状态，列头是下一个输入，表中内容是跳转至的状态。直接将这个表编码进程序中，在状态为 in_number 时计数。</p><p><img src="https://i.loli.net/2021/08/06/XTm849u6plGHdSt.png"></p><p>对于 C++，居然可以用 long long 类型来计数，再去判断它跟 INT_MAX 和 INT_MIN 谁大谁小，属实有点无语。自己写程序的时候搞了半天。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Automaton</span> &#123;</span><br>    string state = <span class="hljs-string">&quot;start&quot;</span>;<br>    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;<br>        &#123;<span class="hljs-string">&quot;start&quot;</span>, &#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;signed&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;in_number&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;end&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_col</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>        state = table[state][<span class="hljs-built_in">get_col</span>(c)];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-string">&quot;in_number&quot;</span>) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            ans = sign == <span class="hljs-number">1</span> ? <span class="hljs-built_in">min</span>(ans, (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MAX) : <span class="hljs-built_in">min</span>(ans, -(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MIN);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == <span class="hljs-string">&quot;signed&quot;</span>)<br>            sign = c == <span class="hljs-string">&#x27;+&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        Automaton automaton;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str)<br>            automaton.<span class="hljs-built_in">get</span>(c);<br>        <span class="hljs-keyword">return</span> automaton.sign * automaton.ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证回文串</title>
    <link href="/leetcode/top-interview-questions-easy/valid-palindrome/"/>
    <url>/leetcode/top-interview-questions-easy/valid-palindrome/</url>
    
    <content type="html"><![CDATA[<h1 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xne8id/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xne8id/</a></p><p><a href="https://leetcode-cn.com/problems/valid-palindrome/">https://leetcode-cn.com/problems/valid-palindrome/</a></p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>左右指针，移动到合法位置（只能是字母、数字）后比较字符是否相同。</p><p>时间复杂度：<code>O(n)</code></p><p>空间复杂度：<code>O(1)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isalnum</span>(s[l])) &#123;<br>            ++l;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isalnum</span>(s[r])) &#123;<br>            --r;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">tolower</span>(s[l]) != <span class="hljs-built_in">tolower</span>(s[r])) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ++l;<br>        --r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛选-判断"><a href="#筛选-判断" class="headerlink" title="筛选 + 判断"></a>筛选 + 判断</h2><p>比较蠢的方法，就不谈了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩 MineCraft 的 Fabric 服务器</title>
    <link href="/essay/minecraft-fabric-server/"/>
    <url>/essay/minecraft-fabric-server/</url>
    
    <content type="html"><![CDATA[<h1 id="玩-MineCraft-的-Fabric-服务器"><a href="#玩-MineCraft-的-Fabric-服务器" class="headerlink" title="玩 MineCraft 的 Fabric 服务器"></a>玩 MineCraft 的 Fabric 服务器</h1><p>MineCraft Java 版有两种常见的非官方服务器，Forge 和 Fabric，相当于是提供了官方接口之上再次的封装，让 mod 开发者更加方便编程。</p><p>网上有说法称 Fabric 服务器更小巧，且 Forge 已经比较老了，故最终选择了 Fabric。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="安装-Fabric-服务器"><a href="#安装-Fabric-服务器" class="headerlink" title="安装 Fabric 服务器"></a>安装 Fabric 服务器</h3><p>可以完全参照 Fabric 官网的文档：<a href="https://fabricmc.net/wiki/player:tutorials:install_server">Installing a Fabric Server without a GUI</a>，按部就班即可。</p><p>注意，在按照文档的示例一通命名改名操作后，启动命令是<code>java -jar server.jar</code>，而非<code>java -jar vanilla.jar</code>，后者相当于原版服务器，mod 不会生效。</p><p>可以使用与官方服务器相同的参数来指定使用的内存大小。例如：<code>java -Xms1024M -Xmx1024M -jar server.jar</code></p><h3 id="安装-Mod"><a href="#安装-Mod" class="headerlink" title="安装 Mod"></a>安装 Mod</h3><p>一些 mod 是要求在服务器上安装，另一些则是需要在本地客户端上安装，还有一些是两者都要。安装 mod 时需要看清 mod 本身的说明。</p><p>服务端安装 mod，将 mod 的 jar 包直接放入游戏根目录的 <code>mods</code> 目录下，重启服务器即可。mod 本身可能会有设置，对应的配置文件在 <code>config</code> 目录中。</p><p><img src="https://i.loli.net/2021/08/04/Gh38n2fHJq6d9OK.png" alt="mods 和 config 目录示意图"></p><p>目前我在服务端安装的 mod：（1.17.1 版本可用）</p><ul><li>Fabric API</li><li>修改苦力怕爆炸的行为（environmentalcreepers）</li><li>一键砍树（FallingTree）</li><li>连锁挖矿（diggusmaximus）（客户端服务器都要装）</li></ul><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="安装-Fabric-客户端"><a href="#安装-Fabric-客户端" class="headerlink" title="安装 Fabric 客户端"></a>安装 Fabric 客户端</h3><p>在这里下载 Fabric Installer：<a href="https://fabricmc.net/use/">Installation for: Minecraft Launcher</a></p><p>对于我用的 Windows 系统，jar 包和 .exe 文件都可以，运行后按提示安装即可。最好使用默认目录，防止自己忘记。</p><h3 id="安装-Mod-1"><a href="#安装-Mod-1" class="headerlink" title="安装 Mod"></a>安装 Mod</h3><p>直接将jar包放到这个目录中：<code>C:\Users\你的用户名\AppData\Roaming\.minecraft\mods</code></p><p>目前我在客户端安装的 mod：（1.17.1 版本可用）</p><ul><li>Fabric API</li><li>钓鱼自动收杆（Autofish）</li><li>连锁挖矿（diggusmaximus）（客户端服务器都要装）</li><li>小地图（voxel map）（非常好用！！）</li><li>mod 管理菜单（mod menu）</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MineCraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效字母异位词</title>
    <link href="/leetcode/top-interview-questions-easy/valid-anagram/"/>
    <url>/leetcode/top-interview-questions-easy/valid-anagram/</url>
    
    <content type="html"><![CDATA[<h1 id="有效字母异位词"><a href="#有效字母异位词" class="headerlink" title="有效字母异位词"></a>有效字母异位词</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn96us/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn96us/</a></p><p><a href="https://leetcode-cn.com/problems/valid-anagram/">https://leetcode-cn.com/problems/valid-anagram/</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>用一个哈希表储存字母出现次数。在字符串 <code>s</code> 中出现的 +1，在 <code>t</code> 中出现的 -1，最后看是不是全为 0 即可。</p><p>时间复杂度：<code>O(n)</code></p><p>空间复杂度：<code>O(|Σ|)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; m;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> &amp;c: s) &#123;<br>        m[c] += <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> &amp;c: t) &#123;<br>        m[c] -= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> curr = m.<span class="hljs-built_in">begin</span>(); curr != m.<span class="hljs-built_in">end</span>(); ++curr) &#123;<br>        <span class="hljs-keyword">if</span> (curr -&gt; second != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序后比较"><a href="#排序后比较" class="headerlink" title="排序后比较"></a>排序后比较</h2><p>排序后比较字符串是否相等。</p><p>时间复杂度：快速排序平均复杂度为 <code>O(nlogn)</code></p><p>空间复杂度：排序所需要的空间为 <code>O(logn)</code></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个唯一字符</title>
    <link href="/leetcode/top-interview-questions-easy/first-unique-character-in-a-string/"/>
    <url>/leetcode/top-interview-questions-easy/first-unique-character-in-a-string/</url>
    
    <content type="html"><![CDATA[<h1 id="第一个唯一字符"><a href="#第一个唯一字符" class="headerlink" title="第一个唯一字符"></a>第一个唯一字符</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn5z8r/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn5z8r/</a></p><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></p><h2 id="哈希表储存出现次数"><a href="#哈希表储存出现次数" class="headerlink" title="哈希表储存出现次数"></a>哈希表储存出现次数</h2><p>第一次遍历用哈希表统计出现次数，第二次遍历找到第一个出现次数为 1 的字符。</p><p>时间复杂度：<code>O(n)</code></p><p>空间复杂度：<code>O(|Σ|)</code> （需要最大为词表大小的空间来储存哈希表）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; m;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c: s) &#123;<br>        m[c] += <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (m[s[i]] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表储存出现的索引"><a href="#哈希表储存出现的索引" class="headerlink" title="哈希表储存出现的索引"></a>哈希表储存出现的索引</h2><p>第一次遍历用哈希表储存索引，如果已经存在，就将索引值设为 -1 。第二次遍历，找出索引值最小的，返回。</p><p>时间、空间复杂度与上一个方法相同。</p><h2 id="哈希表储存出现索引-队列"><a href="#哈希表储存出现索引-队列" class="headerlink" title="哈希表储存出现索引 + 队列"></a>哈希表储存出现索引 + 队列</h2><p>用和方法二一样的哈希表储存索引值，用一个队列来跟踪哪些字符是只出现一次的。</p><p>在插入字符时，如果不存在（第一次出现），将插入的字符及其索引加入到队列尾。而如果插入了一个已经出现过的字符时，从头开始检查队列，如果头元素出现过多次（在哈希表中对应的值为 -1），就弹出。</p><p>其实就是使用队列来维持字符原本的顺序，如果队列头的字符出现了多次就踢掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; position;<br>    queue&lt;pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;&gt; q;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (!position.<span class="hljs-built_in">count</span>(s[i])) &#123;<br>            position[s[i]] = i;<br>            q.<span class="hljs-built_in">emplace</span>(s[i], i);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            position[s[i]] = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; position[q.<span class="hljs-built_in">front</span>().first] == <span class="hljs-number">-1</span>) &#123;<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : q.<span class="hljs-built_in">front</span>().second;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：遍历字符串 <code>O(n)</code> + 队列操作 <code>O(|Σ|)</code>  = <code>O(n)</code></p><p>空间复杂度：<code>O(|Σ|)</code></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>干掉 Disqus 评论区广告</title>
    <link href="/blog/fuck-disqus-ads/"/>
    <url>/blog/fuck-disqus-ads/</url>
    
    <content type="html"><![CDATA[<h1 id="干掉Disqus评论区广告"><a href="#干掉Disqus评论区广告" class="headerlink" title="干掉Disqus评论区广告"></a>干掉Disqus评论区广告</h1><p>这 Disqus 评论区的广告真是越来越离谱了，虽然内容看着还行，但是评论上面六个大图下面也六个大图，都™要比我博客本身的内容还多了，不治治它它就真不知道什么是黑手。</p><p><img src="https://i.loli.net/2021/07/20/ATIczgZXp7SwLPf.png" alt="我啪的一下就点进去看了，很快啊"></p><p>这些广告会延迟加载，直接使用 css 隐藏的方法不好用。一般这个 ID 为 disqus_thread 的 div 通常有 2 到 3 个 iframe，一般第一个和第三个都是广告。这个函数会等待两秒，等广告加载出来后再把它隐藏掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> disqus = jQuery(<span class="hljs-string">&#x27;#disqus_thread&#x27;</span>);<br><br>disqus.ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (disqus.children().length &gt;= <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">const</span> comments = disqus.find(<span class="hljs-string">&#x27;iframe:nth-child(2)&#x27;</span>).detach();<br>      disqus.empty().append(comments);<br>    &#125;<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>最后将这段脚本插入到自定义 js 中。对于我的 Fluid 主题，把 js 文件放在 source 文件夹下的任意地方，然后在配置文件中指定就好了。</p>]]></content>
    
    
    <categories>
      
      <category>博客建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>个人域名绑定 Github pages</title>
    <link href="/blog/add-domain/"/>
    <url>/blog/add-domain/</url>
    
    <content type="html"><![CDATA[<h1 id="个人域名绑定-Github-pages"><a href="#个人域名绑定-Github-pages" class="headerlink" title="个人域名绑定 Github pages"></a>个人域名绑定 Github pages</h1><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>我是在腾讯云上买的域名，按照指示按部就班就好，各种实名认证都搞好，审核速度还是挺快的。</p><h2 id="添加-DNS-解析记录"><a href="#添加-DNS-解析记录" class="headerlink" title="添加 DNS 解析记录"></a>添加 DNS 解析记录</h2><p>来到腾讯云的控制台，添加类型为 CNAME 的记录，指向自己原来的 GitHub Page 名<code>xxx.github.io</code>。</p><p>这里我添加的是 blog 子域名，记录值如下图所示。</p><p><img src="https://i.loli.net/2021/07/19/NXI9p5ymYvCxhBf.png" alt="这里我只用了 blog 子域名而没有直接解析主域名(@)"></p><h2 id="GitHub-pages相关设置"><a href="#GitHub-pages相关设置" class="headerlink" title="GitHub pages相关设置"></a>GitHub pages相关设置</h2><h3 id="添加-CNAME-文件"><a href="#添加-CNAME-文件" class="headerlink" title="添加 CNAME 文件"></a>添加 CNAME 文件</h3><p><strong>在博客源分支的<code>source</code>目录下创建名为 CNAME 的文件</strong>，内容为刚才添加了解析规则的域名。例如我的是：blog.gentlecomet.com。</p><p>由于我的博客使用的是 Hexo 以及 GitHub action 的自动部署，如果直接放在部署分支中，会在 push 源分支的时候被自动删掉，必须放在源分支的<code>source</code>目录下才行，这样部署的时候这个文件也会被正确地放到部署的分支中。</p><h3 id="设置-pages"><a href="#设置-pages" class="headerlink" title="设置 pages"></a>设置 pages</h3><p>在仓库的 Settings 里找到 Pages 选项卡，设置 custom domain 为 CNAME 中的域名，save 即可。最后把强制 HTTPS 打开就好了。</p><p><img src="https://i.loli.net/2021/07/19/RAjPHGbsDiNFzE2.png"></p><p>注意这一步实际上会自动添加一个 CNAME 文件在部署分支里。</p><h2 id="关于我的域名"><a href="#关于我的域名" class="headerlink" title="关于我的域名"></a>关于我的域名</h2><p>有选择困难症，想域名的时候想了好久。最后选了这个 gentle comet，neta 了我很喜欢的 YOASOBI 的一首歌 <strong>優しい彗星</strong> 的英文翻译，意为”温柔的彗星“。</p>]]></content>
    
    
    <categories>
      
      <category>博客建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>整数反转</title>
    <link href="/leetcode/top-interview-questions-easy/reverse-integer/"/>
    <url>/leetcode/top-interview-questions-easy/reverse-integer/</url>
    
    <content type="html"><![CDATA[<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnx13t/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnx13t/</a></p><p><a href="https://leetcode-cn.com/problems/reverse-integer/">https://leetcode-cn.com/problems/reverse-integer/</a></p><h2 id="逐位运算"><a href="#逐位运算" class="headerlink" title="逐位运算"></a>逐位运算</h2><p>使用<code>x % 10</code>取得个位数的值，将它加到临时值<code>ret</code>中，并且让<code>ret</code>倍增10。</p><p>使用<code>x /= 10</code>来去掉个位（C++）。</p><p><strong>用<code>INT_MIN / 10</code>和<code>INT_MAX / 10</code>来提前判断是否会越界</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ret &lt; INT_MIN / <span class="hljs-number">10</span> || ret &gt; INT_MAX / <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> last = x % <span class="hljs-number">10</span>;<br>        x /= <span class="hljs-number">10</span>;<br>        ret = <span class="hljs-number">10</span> * ret + last;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串</title>
    <link href="/leetcode/top-interview-questions-easy/reverse-string/"/>
    <url>/leetcode/top-interview-questions-easy/reverse-string/</url>
    
    <content type="html"><![CDATA[<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhbqj/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhbqj/</a></p><p><a href="https://leetcode-cn.com/problems/reverse-string/">https://leetcode-cn.com/problems/reverse-string/</a></p><h2 id="直接交换"><a href="#直接交换" class="headerlink" title="直接交换"></a>直接交换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n/<span class="hljs-number">2</span> ; ++i) &#123;<br>        <span class="hljs-built_in">swap</span>(s[i], s[n<span class="hljs-number">-1</span>-i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>官方题解是双指针，其实是差不多的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>; left &lt; right; ++left, --right) &#123;<br>        <span class="hljs-built_in">swap</span>(s[left], s[right]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署自己的 MineCraft 服务器</title>
    <link href="/essay/deploy-minecraft-server/"/>
    <url>/essay/deploy-minecraft-server/</url>
    
    <content type="html"><![CDATA[<h1 id="部署自己的-MineCraft-服务器"><a href="#部署自己的-MineCraft-服务器" class="headerlink" title="部署自己的 MineCraft 服务器"></a>部署自己的 MineCraft 服务器</h1><p>放假在家突然想玩新版MC，买了个Java版和朋友联机玩。记录一下折腾过程。</p><h2 id="服务器的配置要求"><a href="#服务器的配置要求" class="headerlink" title="服务器的配置要求"></a>服务器的配置要求</h2><p>原本在朋友1核2G的服务器上玩，遇到了第三个玩家加入就会被踢出去的问题，而服务器内存和CPU并未过载，推测是带宽不足（为128KB）。可能出现的错误信息有：</p><ul><li>登入失败：身份验证目前正在停机维护</li><li>lost connection：timed out</li></ul><p><img src="https://i.loli.net/2021/07/19/NsQHjSEZBkLTnOz.png" alt="错误信息"></p><p>为了能愉快地玩耍，在阿里云上买了个所谓的轻量应用服务器，2核2G内存，关键是峰值带宽为5M。搞定以后解决了所有问题，3个人玩的很流畅。虽然每月限流1000GB，但还是完全够用。一年99，并且再续费一年似乎也是99，感觉挺不错的。</p><p><img src="https://i.loli.net/2021/07/19/LaSM8ypwVfiJmAI.png" alt="我买的服务器的配置"></p><h2 id="开放服务器端口"><a href="#开放服务器端口" class="headerlink" title="开放服务器端口"></a>开放服务器端口</h2><p>在阿里云的服务器控制台中设置防火墙规则，开放MC要用的<code>25565</code>端口。</p><p><img src="https://i.loli.net/2021/07/19/5x8Vbvz1nkrqmPf.png" alt="不知道用的是TCP还是UDP，那就全部开放"></p><h2 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h2><h3 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install openjdk-16-jre-headless<br></code></pre></td></tr></table></figure><h3 id="安装screen"><a href="#安装screen" class="headerlink" title="安装screen"></a>安装screen</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install screen<br></code></pre></td></tr></table></figure><h3 id="下载MC服务器程序"><a href="#下载MC服务器程序" class="headerlink" title="下载MC服务器程序"></a>下载MC服务器程序</h3><p>下载地址见：<a href="https://www.minecraft.net/en-us/download/server">DOWNLOAD THE MINECRAFT: JAVA EDITION SERVER</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://launcher.mojang.com/v1/objects/a16d67e5807f57fc4e550299cf20226194497dc2/server.jar<br></code></pre></td></tr></table></figure><p>就是一个jar包，用Java运行这个包就启动了服务器。</p><h2 id="启动游戏服务器"><a href="#启动游戏服务器" class="headerlink" title="启动游戏服务器"></a>启动游戏服务器</h2><h3 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h3><p>创建了名为mc的会话。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S mc<br></code></pre></td></tr></table></figure><h3 id="运行游戏服务器"><a href="#运行游戏服务器" class="headerlink" title="运行游戏服务器"></a>运行游戏服务器</h3><p>两个参数<code>-Xmx</code>和<code>-Xms</code>分别指定了最大内存和最小内存。（均为1024M）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx1024M -Xms1024M -jar minecraft_server.1.17.1.jar nogui<br></code></pre></td></tr></table></figure><p>成功启动后就能看到各种提示信息，此时可以输入各种服务器命令了。</p><p><img src="https://i.loli.net/2021/07/19/MOFGxlQfTH5X3gd.png" alt="启动成功"></p><h3 id="保留Screen并退出"><a href="#保留Screen并退出" class="headerlink" title="保留Screen并退出"></a>保留Screen并退出</h3><p><code>ctrl + A + D</code></p><h3 id="再次进入"><a href="#再次进入" class="headerlink" title="再次进入"></a>再次进入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -r mc<br></code></pre></td></tr></table></figure><h3 id="强行杀死"><a href="#强行杀死" class="headerlink" title="强行杀死"></a>强行杀死</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S mc -X quit<br></code></pre></td></tr></table></figure><p>更多screen的用法详见：<a href="https://www.huaweicloud.com/articles/6d91932d9a65d3cb45101886ac6fe53a.html">linux中screen命令的用法</a></p><h2 id="MineCraft服务器属性"><a href="#MineCraft服务器属性" class="headerlink" title="MineCraft服务器属性"></a>MineCraft服务器属性</h2><p>详见：<a href="https://minecraft.fandom.com/zh/wiki/Server.properties?variant=zh#Java.E7.89.88_3">Minecraft服务器属性</a></p><p>编辑<code>server.properties</code>文件。</p><h2 id="MineCraft后台命令"><a href="#MineCraft后台命令" class="headerlink" title="MineCraft后台命令"></a>MineCraft后台命令</h2><p>详见：<a href="https://minecraft.fandom.com/zh/wiki/%E5%91%BD%E4%BB%A4?variant=zh#.E5.91.BD.E4.BB.A4.E5.88.97.E8.A1.A8.E5.8F.8A.E5.85.B6.E6.A6.82.E8.BF.B0">命令列表及其概述</a></p><p>启动服务器后直接输入命令即可，无需以<code>/</code>开头。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MineCraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转图像</title>
    <link href="/leetcode/top-interview-questions-easy/rotate-image/"/>
    <url>/leetcode/top-interview-questions-easy/rotate-image/</url>
    
    <content type="html"><![CDATA[<h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhhkv/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhhkv/</a></p><p><a href="https://leetcode-cn.com/problems/rotate-image/">https://leetcode-cn.com/problems/rotate-image/</a></p><h2 id="使用临时矩阵"><a href="#使用临时矩阵" class="headerlink" title="使用临时矩阵"></a>使用临时矩阵</h2><p>注意到旋转后元素位置和原位置的关系：</p><ul><li>原本在第n行，旋转后变成倒数第n列</li><li>原本在第m列，旋转后变成第m行</li></ul><p>即：<code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code></p><p>使用一个临时数组，利用上面这个规律更新临时数组。最后再将原数组换成临时数组，达到“原地修改”的目的。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间空间复杂度都是<code>O(n^2)​</code></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> temp = matrix;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; n; ++row) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; ++col) &#123;<br>            temp[col][n<span class="hljs-number">-1</span>-row] = matrix[row][col];<br>        &#125;<br>    &#125;<br><br>    matrix.<span class="hljs-built_in">swap</span>(temp);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原地旋转"><a href="#原地旋转" class="headerlink" title="原地旋转"></a>原地旋转</h2><p>直接在原地将每一个元素移动到它应该在的地方，并且把要被覆盖的元素也移动走。容易发现旋转一次，一个位置的元素对应了4个位置的变化，且它们之间组成一个环。因此用temp保存最后一个被覆盖的值，然后依次移动并覆盖即可。</p><p>这4个元素旋转一次后，<strong>相对于上一个位置</strong>的关系都是<code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code>。转换成<strong>相对于第一个位置</strong>（绝对位置）的关系：</p><ol><li><code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code></li><li><code>matrix[col][n-1-row] -&gt; matrix_new[n-1-row][n-1-col]</code></li><li><code>matrix[n-1-row][n-1-col] -&gt; matrix_new[n-1-col][row]</code></li><li><code>matrix[n-1-col][row] -&gt; matrix_new[row][col]</code></li></ol><p>如同上面说的，组成了一个循环。用一个<code>temp</code>变量保 存第一个丢失的值<code>matrix[row][col]</code>即可。</p><p>还有一个问题：需要遍历矩阵中的哪些元素？显然，一次这样的操作移动好了4个元素，因此当边长n为偶数时，可以将矩阵分成一样大小的4块，只需操作其中一块；</p><p><img src="https://i.loli.net/2021/07/17/zgGOmqE2jDtAr8P.png"></p><p>对于左上角的这一块，它的范围是：</p><ul><li>行：n/2</li><li>列：n/2</li></ul><p>如果边长n为奇数的时候呢？使用这种巧妙的方法：</p><p><img src="https://i.loli.net/2021/07/17/b9NjW7KMGdnDQt3.png"></p><p>对于左上角这一块，它的范围是：</p><ul><li>行：<code>n/2</code></li><li>列：<code>n/2 + 1</code></li></ul><p>综合起来可以写成：</p><ul><li>行：<code>n/2</code></li><li>列：<code>n/2 + n%2</code> （或者<code>(n+1)/2</code>）</li></ul><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(1)</code></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 注意for循环的范围</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; n/<span class="hljs-number">2</span>; ++row) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n/<span class="hljs-number">2</span> + n%<span class="hljs-number">2</span>; ++col) &#123;<br>            <span class="hljs-keyword">int</span> temp = matrix[row][col];<br>            matrix[row][col] = matrix[n<span class="hljs-number">-1</span>-col][row];<br>            matrix[n<span class="hljs-number">-1</span>-col][row] = matrix[n<span class="hljs-number">-1</span>-row][n<span class="hljs-number">-1</span>-col];<br>            matrix[n<span class="hljs-number">-1</span>-row][n<span class="hljs-number">-1</span>-col] = matrix[col][n<span class="hljs-number">-1</span>-row];<br>            matrix[col][n<span class="hljs-number">-1</span>-row] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用翻转来代替旋转"><a href="#使用翻转来代替旋转" class="headerlink" title="使用翻转来代替旋转"></a>使用翻转来代替旋转</h2><p>上下翻转，然后主对角线翻转，就能得到答案。</p><p><img src="https://i.loli.net/2021/07/17/xn5CS9HVprRDQMl.png"></p><p>这是根据之前的那个关键公式推断的：<code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code>。观察这个公式，主要是两点：</p><ol><li><code>row</code>变成了<code>n-1-row</code>（正数变成倒数）</li><li><code>row</code>和<code>col</code>交换（转置）</li></ol><p>而1可以用上下翻转得到，这样正数第n行就变成了倒数第n行；2可以通过转置得到，即行号变成列号。</p><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(1)</code></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 水平翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[n - i - <span class="hljs-number">1</span>][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 主对角线翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效的数独</title>
    <link href="/leetcode/top-interview-questions-easy/valid-sudoku/"/>
    <url>/leetcode/top-interview-questions-easy/valid-sudoku/</url>
    
    <content type="html"><![CDATA[<h1 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2f9gg/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2f9gg/</a></p><p><a href="https://leetcode-cn.com/problems/valid-sudoku">https://leetcode-cn.com/problems/valid-sudoku</a></p><h2 id="我的方法"><a href="#我的方法" class="headerlink" title="我的方法"></a>我的方法</h2><p>容易想到的是使用哈希表来记录一行/一列/一个方格内是否出现了重复值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = board.<span class="hljs-built_in">size</span>();<br>    unordered_set&lt;<span class="hljs-keyword">char</span>&gt; row, col, grid;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(row.<span class="hljs-built_in">insert</span>(board[i][j]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (board[j][i] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(col.<span class="hljs-built_in">insert</span>(board[j][i]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span> &amp;&amp; j%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">3</span>; ++x) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-number">3</span>; ++y) &#123;<br>                        <span class="hljs-keyword">if</span> (board[i+x][j+y] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(grid.<span class="hljs-built_in">insert</span>(board[i+x][j+y]).second)) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            grid.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        row.<span class="hljs-built_in">clear</span>();<br>        col.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一行和每一列是否有重复值比较好搞，但是如何在一次遍历中就记录方格里的值呢？</p><p>我的方法是判断遍历到的值是不是方格左上角的元素，是的话再遍历整个方格。这样实际上多了不必要的访问。</p><h2 id="更好的方法"><a href="#更好的方法" class="headerlink" title="更好的方法"></a>更好的方法</h2><p>如何在一次遍历就访问到方格里的元素呢？大家可能很好奇如何在一次遍历就访问到方格里的元素。方法就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> m = j / <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> n = j % <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>小编也很奇怪，为什么可以这样呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = board.<span class="hljs-built_in">size</span>();<br>    unordered_set&lt;<span class="hljs-keyword">char</span>&gt; row, col, grid;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(row.<span class="hljs-built_in">insert</span>(board[i][j]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (board[j][i] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(col.<span class="hljs-built_in">insert</span>(board[j][i]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> m = j / <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">int</span> n = j % <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">if</span> (board[m][n] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(grid.<span class="hljs-built_in">insert</span>(board[m][n]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        row.<span class="hljs-built_in">clear</span>();<br>        col.<span class="hljs-built_in">clear</span>();<br>        grid.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/leetcode/top-interview-questions-easy/two-sum/"/>
    <url>/leetcode/top-interview-questions-easy/two-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2jrse/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2jrse/</a></p><p><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>双重循环遍历，时间复杂度显然是<code>O(n^2)</code></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>在暴力法中，对于每一个<code>x</code>，都需要遍历一次整个数组来寻找<code>target - x</code>。</p><p>如何加快<code>target - x</code>的寻找速度？答案就是使用哈希表来储存<code>target - x</code>的值，这样寻找<code>target - x</code>的时间复杂度只有<code>O(1)</code>，总时间复杂度为<code>O(n)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">auto</span> p = m.<span class="hljs-built_in">find</span>(nums[i]);<br>        <span class="hljs-keyword">if</span> (p == m.<span class="hljs-built_in">end</span>()) &#123;<br>            m.<span class="hljs-built_in">insert</span>(&#123;target-nums[i], i&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;i, p -&gt; second&#125;;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><p>这里使用了 C++ 11的新特性列表初始化 (initialiser_list)，可以用花括号来初始化vector、作为函数参数使用、直接返回。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化</span><br>std::vector&lt;std::string&gt; words = &#123;<span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-string">&quot;mortar&quot;</span>, <span class="hljs-string">&quot;holding&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;together&quot;</span>&#125;; <br><br><span class="hljs-built_in">twoSum</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;, <span class="hljs-number">7</span>); <span class="hljs-comment">// 作为参数</span><br><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">numbers</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;  <span class="hljs-comment">// 作为返回值</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动零</title>
    <link href="/leetcode/top-interview-questions-easy/move-zeros/"/>
    <url>/leetcode/top-interview-questions-easy/move-zeros/</url>
    
    <content type="html"><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2ba4i/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2ba4i/</a></p><p><a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>使用左右两个指针，右指针一直移动，当指向的数非0时，与左指针交换，并移动左指针一次。</p><ul><li>左右指针一开始会在一起，如果当前的数非 0 ，它们交换也不会有变化</li><li>当遇到为 0 的数时，左指针停在 0 上，右指针会继续走，并将另一个非 0 的数交换过来</li></ul><p><strong>不会存在这样的情况</strong>：左右指针都非 0，交换导致相对顺序改变，因为右指针只会在遇到 0 的时候超越左指针，即左指针要么和右指针在一起，要么左指针指的是 0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (nums[right] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[left], nums[right]);<br>            ++left;<br>        &#125;<br>        ++right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加一</title>
    <link href="/leetcode/top-interview-questions-easy/plus-one/"/>
    <url>/leetcode/top-interview-questions-easy/plus-one/</url>
    
    <content type="html"><![CDATA[<h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2cv1c/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2cv1c/</a></p><p><a href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></p><h2 id="严密的逻辑"><a href="#严密的逻辑" class="headerlink" title="严密的逻辑"></a>严密的逻辑</h2><p>考虑所有可能的情况即可：</p><ol><li>不用进位，直接加一</li><li>需要进位，非最高位，则置为 0 并执行高一位的操作</li><li>需要进位，是最高位，则置为 0 并在前面插入一个 1，直接返回</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; digits)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> curr = digits.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (curr; curr &gt;= <span class="hljs-number">0</span>; --curr) &#123;<br>        <span class="hljs-keyword">if</span> (digits[curr] + <span class="hljs-number">1</span> == <span class="hljs-number">10</span>) &#123;<br>            digits[curr] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (curr == <span class="hljs-number">0</span>) &#123;<br>                digits.<span class="hljs-built_in">insert</span>(digits.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> digits;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            digits[curr] += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> digits;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用标准库容器</title>
    <link href="/programming/cpp-stl-containers/"/>
    <url>/programming/cpp-stl-containers/</url>
    
    <content type="html"><![CDATA[<h1 id="C-常用标准库容器"><a href="#C-常用标准库容器" class="headerlink" title="C++常用标准库容器"></a>C++常用标准库容器</h1><p><a href="https://www.geeksforgeeks.org/containers-cpp-stl/">https://www.geeksforgeeks.org/containers-cpp-stl/</a></p><h2 id="顺序容器-sequence-containers"><a href="#顺序容器-sequence-containers" class="headerlink" title="顺序容器 (sequence containers)"></a>顺序容器 (sequence containers)</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>可以动态扩展的列表</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br></code></pre></td></tr></table></figure><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th></tr></thead><tbody><tr><td>插入</td><td>v.insert(v.begin(), 3)</td></tr><tr><td>插入到最后面<br />插入到最前面</td><td>v.push_back(3)<br />v.push_front(3)</td></tr><tr><td>删除</td><td>v.erase(v.begin())<br />v.erase(v.begin(), v.end())</td></tr><tr><td>删除尾元素<br />删除头元素</td><td>v.pop_back()<br />v.pop_front()</td></tr><tr><td>计数</td><td>v.count(3)</td></tr></tbody></table><h2 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h2><p>关联容器可能会使用到的数据类型，定义在头文件<code>utility</code>中。具有两个数据成员，名字为<code>first</code>以及<code>second</code>。</p><h2 id="关联容器-associative-containers"><a href="#关联容器-associative-containers" class="headerlink" title="关联容器 (associative containers)"></a>关联容器 (associative containers)</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>map&lt;string, <span class="hljs-keyword">int</span>&gt; map;<br></code></pre></td></tr></table></figure><h4 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>插入</td><td>map.insert({“word”, 1})<br />map.insert(make_pair(“word”, 1))<br />map.insert(pair&lt;string, size_t&gt;(“word”, 1))</td><td></td></tr><tr><td>删除</td><td>map.erase(“word”)<br />map.erase(iterator)</td><td></td></tr><tr><td>查找</td><td>map.find(“word”)</td><td>返回指向第一个找到元素的迭代器<br />迭代器指向的类型为pair<br />若未找到，则返回尾后迭代器</td></tr><tr><td>计数</td><td>map.count(“word”)</td><td>计数值</td></tr></tbody></table><h4 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h4><p>map（以及unordered_map）可以使用下标运算符，获取关键字对应的<strong>值</strong>。</p><p>如果关键字不存在，会用这个关键字创建一个新的元素，并对关联的值初始化。因此不应该直接用下标操作来进行查找，应该使用<code>find()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">map[<span class="hljs-string">&quot;hello&quot;</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 会插入一个关键字为hello的元素，且值为1</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：map 的<strong>下标操作</strong>返回的是关键字对应的值，而<strong>解引用 map 迭代器</strong>返回的是一个 <strong><code>pair</code></strong> 对象。</p><h2 id="无序关联容器-unordered-associative-containers"><a href="#无序关联容器-unordered-associative-containers" class="headerlink" title="无序关联容器 (unordered associative containers)"></a>无序关联容器 (unordered associative containers)</h2><p>使用哈希函数组织的关联容器，查找速度更快，时间复杂度平均<code>O(1)</code>，最坏<code>O(n)</code>。在关键字类型元素没有明显有序关系时，可以使用无序容器。</p><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_set&lt;<span class="hljs-keyword">int</span>&gt; uset;<br></code></pre></td></tr></table></figure><h4 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>插入</td><td>uset.insert(5)</td><td>一个pair，first成员为指向插入元素的迭代器；second指示是否成功插入，true为成功插入，false为不成功（已经存在一样的元素）</td></tr><tr><td>清空</td><td>uset.clear()</td><td>void</td></tr><tr><td>查询</td><td>uset.find(key)</td><td>指向找到元素的迭代器，或者尾后迭代器（没找到）</td></tr></tbody></table><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>无序键值对</p><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; umap;<br></code></pre></td></tr></table></figure><h4 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>插入</td><td>umap.insert({“word”, 1})<br />umap.insert(make_pair(“word”, 1))<br />umap.insert(pair&lt;string, size_t&gt;(“word”, 1))</td><td></td></tr><tr><td>查询</td><td>umap.find(“word”)</td><td></td></tr><tr><td>计数</td><td>umap.count(“word”)</td><td></td></tr></tbody></table><h2 id="容器适配器-container-adapters"><a href="#容器适配器-container-adapters" class="headerlink" title="容器适配器 (container adapters)"></a>容器适配器 (container adapters)</h2>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用泛型算法</title>
    <link href="/programming/cpp-generic-algorithms/"/>
    <url>/programming/cpp-generic-algorithms/</url>
    
    <content type="html"><![CDATA[<h1 id="C-常用泛型算法"><a href="#C-常用泛型算法" class="headerlink" title="C++常用泛型算法"></a>C++常用泛型算法</h1><p><a href="https://www.geeksforgeeks.org/c-magicians-stl-algorithms/">https://www.geeksforgeeks.org/c-magicians-stl-algorithms/</a></p><p><a href="https://en.cppreference.com/w/cpp/algorithm">https://en.cppreference.com/w/cpp/algorithm</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// 泛型算法</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span>   <span class="hljs-comment">// 数值泛型算法</span></span><br></code></pre></td></tr></table></figure><h2 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h2><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>查找</td><td>find(v.begin(), v.end(), value)</td><td>满足条件的迭代器，找不到则为尾后</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="写容器算法"><a href="#写容器算法" class="headerlink" title="写容器算法"></a>写容器算法</h2><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>交换元素</td><td>swap(v.begin(), v.end())</td><td>void</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="重排容器算法"><a href="#重排容器算法" class="headerlink" title="重排容器算法"></a>重排容器算法</h2><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>排序</td><td>sort(v.begin(), v.end())</td><td>void</td></tr><tr><td>将不重复的排在前面</td><td>unique(v.begin(), v.end())</td><td>一个指向不重复值范围末尾的迭代器</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个数组的交集 II</title>
    <link href="/leetcode/top-interview-questions-easy/intersection-of-two-arrays-ii/"/>
    <url>/leetcode/top-interview-questions-easy/intersection-of-two-arrays-ii/</url>
    
    <content type="html"><![CDATA[<h1 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/</a></p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>将数组排序后，使用双指针，值相同则加入并集，否则向后移动<strong>值比较小</strong>的那个指针，直到其中一方越界。</p><p>时间复杂度：排序为<code>O(nlogn + mlogm)</code>，双指针移动为<code>O(n + m)</code>，加起来就是<code>O(nlogn + mlogm)</code></p><p>空间复杂度：由于<code>vector</code>的大小是动态改变的，复杂度为<code>O(1)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; intersection;<br><br>    <span class="hljs-keyword">int</span> n1 = <span class="hljs-number">0</span>, n2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> ( n1 != nums1.<span class="hljs-built_in">size</span>() &amp;&amp; n2 != nums2.<span class="hljs-built_in">size</span>() ) &#123;<br>        <span class="hljs-keyword">if</span> (nums1[n1] == nums2[n2]) &#123;<br>            intersection.<span class="hljs-built_in">push_back</span>(nums1[n1]);<br>            ++n1;<br>            ++n2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[n1] &gt; nums2[n2]) &#123;<br>            ++n2;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++n1;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> intersection;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希表来记录数字以及出现的次数。</p><ol><li>遍历较短的数组，依次将数字插入哈希表。</li><li>遍历较长的数组，查询哈希表中是否已有该元素。如果有，就将它加入并集中，并将哈希表中的计数减一；如果没有则无需采取任何操作。</li></ol><p>时间复杂度：遍历两个数组所用的时间<code>O(m + n)</code>，哈希表的插入和查询平均都是<code>O(1)</code>。</p><p>空间复杂度：创建了大小为较短数组长度的哈希表，因此是<code>O(min(m, n))</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() &lt; nums2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersect</span>(nums2, nums1);<br><br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; intersection;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums1) &#123;<br>        ++m[x];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums2) &#123;<br>        <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(x) != m.<span class="hljs-built_in">end</span>() &amp;&amp; (m.<span class="hljs-built_in">find</span>(x) -&gt; second) &gt; <span class="hljs-number">0</span>) &#123;<br>            --m[x];<br>            intersection.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> intersection;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现时，可以不用<code>find(x)</code>来查找，直接利用<code>count(x)</code>来判断表中是否存该数字，计数减一后判断计数值是不是变成0了，是的话就从表中删去此元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>只出现一次的数字</title>
    <link href="/leetcode/top-interview-questions-easy/single-number/"/>
    <url>/leetcode/top-interview-questions-easy/single-number/</url>
    
    <content type="html"><![CDATA[<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/</a></p><p><a href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希表，如果放入元素时候已经有了，就删掉它。最后剩下的就是只出现一次的元素。时间复杂度是<code>O(n)</code>，空间复杂度也是<code>O(n)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(x)) &#123;<br>            s.<span class="hljs-built_in">erase</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            s.<span class="hljs-built_in">insert</span>(x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *(s.<span class="hljs-built_in">begin</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>数字按位进行异或运算。基于以下几点事实：</p><ul><li>任何数和自己做异或运算，结果为 0，即 a ⊕ a = 0 。</li><li>任何数和 0 做异或运算，结果还是自己，即 a ⊕ 0 = 0 。</li><li>异或运算中，满足交换律和结合律，a ⊕ b ⊕ a = b ⊕ a ⊕ a = b ⊕ ( a ⊕ a ) = b ⊕ 0 = b 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: nums) ret ^= e;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-的位和逻辑运算操作符"><a href="#C-的位和逻辑运算操作符" class="headerlink" title="C++的位和逻辑运算操作符"></a>C++的位和逻辑运算操作符</h2><table><thead><tr><th>运算</th><th>位运算操作符 (bitwise)</th><th>逻辑运算符(logical)</th></tr></thead><tbody><tr><td>AND</td><td>&amp;</td><td>&amp;&amp;</td></tr><tr><td>OR</td><td>|</td><td>||</td></tr><tr><td>XOR</td><td>^</td><td></td></tr><tr><td>NOT</td><td>~</td><td>!</td></tr><tr><td>left shift</td><td>&lt;&lt;</td><td></td></tr><tr><td>right shift</td><td>&gt;&gt;</td><td></td></tr></tbody></table><p>参考链接：<a href="https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/">https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存在重复元素</title>
    <link href="/leetcode/top-interview-questions-easy/contain-duplicates/"/>
    <url>/leetcode/top-interview-questions-easy/contain-duplicates/</url>
    
    <content type="html"><![CDATA[<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/</a><br><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p><h2 id="排序后比较"><a href="#排序后比较" class="headerlink" title="排序后比较"></a>排序后比较</h2><p>先排序，然后比较相邻元素即可。使用C++的排序泛型算法<code>sort()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>将元素插入哈希表，如果插入时发现重复了，就可以返回了。</p><p>C++中，类似的功能可以用关联容器<code>unordered_set</code>实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(x) != s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        s.<span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转数组</title>
    <link href="/leetcode/top-interview-questions-easy/rotate-array/"/>
    <url>/leetcode/top-interview-questions-easy/rotate-array/</url>
    
    <content type="html"><![CDATA[<h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/</a><br><a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></p><h2 id="临时数组"><a href="#临时数组" class="headerlink" title="临时数组"></a>临时数组</h2><p>最简单的方法，但是空间复杂为<code>O(n)</code>。</p><h2 id="环状替换"><a href="#环状替换" class="headerlink" title="环状替换"></a>环状替换</h2><p>如果直接将每个数字放至它<strong>最后的位置</strong>，这样被放置位置的元素会被覆盖从而丢失。</p><p>解决方法：从位置 0 开始，将它放到正确的位置（向右 k 位），然后<strong>把被覆盖的元素保存下来</strong>，再将它放到正确的位置（再向右 k 位），循环往复。</p><p>容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到（当 nums.length % k = 0 时，只会遍历偶数位置然后回到开头），此时应该跳到下一个位置然后继续。至于怎么判断该不该跳，我还不是很懂，详见<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/">题解</a>。</p><h2 id="数组翻转"><a href="#数组翻转" class="headerlink" title="数组翻转"></a>数组翻转</h2><p><img src="https://i.loli.net/2021/07/17/xNXsC3YdFDwPa8O.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[start], nums[end]);<br>            start += <span class="hljs-number">1</span>;<br>            end -= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        k %= nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums, k, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机 II</title>
    <link href="/leetcode/top-interview-questions-easy/best-time-to-buy-and-sell-stock-ii/"/>
    <url>/leetcode/top-interview-questions-easy/best-time-to-buy-and-sell-stock-ii/</url>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/</a><br><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>只看相邻的两天，只要后一天比前一天高，就是收益，非常简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> curr = prices.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>; curr != prices.<span class="hljs-built_in">end</span>(); ++curr) &#123;<br>        <span class="hljs-keyword">if</span> (*curr &gt; *(curr - <span class="hljs-number">1</span>))<br>            result += *curr - *(curr - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>刚做完一个双指针，指魔怔了，嗯是搞了个双指针。其实就是找到每一段递增区间的起点和终点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">auto</span> min = prices.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">auto</span> max = min;<br>    <span class="hljs-keyword">auto</span> end = prices.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (min != end &amp;&amp; max != end) &#123;<br>        <span class="hljs-keyword">while</span> ((min+<span class="hljs-number">1</span>) != end &amp;&amp; *min &gt; *(min + <span class="hljs-number">1</span>))<br>            ++min;<br>        max = min;<br>        <span class="hljs-keyword">while</span> ((max+<span class="hljs-number">1</span>) != end &amp;&amp; *max &lt; *(max + <span class="hljs-number">1</span>))<br>            ++max;<br>        result += *(max) - *(min);<br>        <span class="hljs-keyword">if</span> (min != end &amp;&amp; max != end) &#123;<br>            ++max;<br>            min = max;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何制作 Unravel 和 damedane 的 Deepfake 换脸视频</title>
    <link href="/essay/make-deepfake-meme/"/>
    <url>/essay/make-deepfake-meme/</url>
    
    <content type="html"><![CDATA[<h1 id="如何制作-Unravel-和-damedane-换脸视频"><a href="#如何制作-Unravel-和-damedane-换脸视频" class="headerlink" title="如何制作 Unravel 和 damedane 换脸视频"></a>如何制作 Unravel 和 damedane 换脸视频</h1><p>虽然这梗已经火了好久了，但是最近看多了，自己也想试着搞一个。奇怪的是知乎和B站居然搜不到教程，而上外网一下就找到了，于是写一个博客记录一下，顺便帮助有需要的人（虽然应该不会有人看我的博客）。</p><h2 id="准备照片和视频"><a href="#准备照片和视频" class="headerlink" title="准备照片和视频"></a>准备照片和视频</h2><h3 id="人脸照片"><a href="#人脸照片" class="headerlink" title="人脸照片"></a>人脸照片</h3><p>准备一张人脸照片（受害人），裁剪为长宽比例1：1，人脸最好在中间。这里请出明日方舟的制作人海猫络合物先生。<br><img src="/img/deepfake/oceancat.png" alt="Ocean Cat"></p><h3 id="母体视频"><a href="#母体视频" class="headerlink" title="母体视频"></a>母体视频</h3><p>如果是要制作damedane的，就不需要自己准备了，代码里已经预设好了。<br>Unravel的视频模板在这：<a href="https://www.kapwing.com/explore/unravel-tokyo-ghoul-meme-template">Unravel模板</a>，直接下载下来一会儿用。</p><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>这个翻唱Unravel的小姐姐YouTube视频在<a href="https://www.youtube.com/watch?v=Dsd9X_7WSd4">这里</a>，下面的评论都在感谢她提供了这么好的deepfake模板，真是令人哭笑不得。但是有一说一还是唱的挺好听的，就是不知道为什么一看她闭眼就想笑。<br><img src="/img/deepfake/comment.png" alt="thank you for the great deepfake template"></p><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><p>打开这个链接：<a href="https://colab.research.google.com/github/AliaksandrSiarohin/first-order-model/blob/master/demo.ipynb">Deepfake代码</a><br>依次点击两个代码块左边的运行按钮，滚动到页面底部，等待一会儿后就会出来图像界面。<br><img src="/img/deepfake/run_script.png" alt="依次点这两个播放按钮"><br>根据图形界面的指示，上传刚才准备好的图片和视频，点击<code>Generate</code>按钮就可以生成换脸视频了，需要等几分钟。如图所示，damedane的原版视频有预设了（奥巴马左边那位）。<br><img src="/img/deepfake/gui2.png" alt="海猫填充完毕"><br>生成完成后，下载下来即可。<br><img src="/img/deepfake/compare.png" alt="海猫的痛，你们懂吗"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>YouTube一搜Unravel就会有一个教程视频，然后找到了对应的文章。不过这个教程是快一年前的了，现在deepfake的脚本已经更新过了，不用这么麻烦了。<br><a href="https://www.youtube.com/watch?v=MXNBtws35WE&amp;t=518s">https://www.youtube.com/watch?v=MXNBtws35WE&amp;t=518s</a><br><a href="https://www.kapwing.com/resources/how-to-make-the-unravel-tokyo-ghoul-deepfake-meme/">https://www.kapwing.com/resources/how-to-make-the-unravel-tokyo-ghoul-deepfake-meme/</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>删除排序数组中的重复项</title>
    <link href="/leetcode/top-interview-questions-easy/remove-duplicates-from-sorted-array/"/>
    <url>/leetcode/top-interview-questions-easy/remove-duplicates-from-sorted-array/</url>
    
    <content type="html"><![CDATA[<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/</a><br><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">auto</span> iter_first = a.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> iter_second = iter_first + <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以直接对迭代器加减，得到指向下一个位置的迭代器</span><br><span class="hljs-keyword">auto</span> iter_last = a.<span class="hljs-built_in">end</span>();<br><br><span class="hljs-keyword">int</span> str = *iter_first;             <span class="hljs-comment">// 解引用迭代器得到它指向的值</span><br></code></pre></td></tr></table></figure><h3 id="遍历vector容器"><a href="#遍历vector容器" class="headerlink" title="遍历vector容器"></a>遍历<code>vector</code>容器</h3><p>范围<code>for</code>循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v: nums) &#123;<br>    v *= <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code>循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">auto</span> current = nums.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-keyword">while</span> (current != nums.<span class="hljs-built_in">end</span>()) &#123;    <span class="hljs-comment">// 使用!=号来比较迭代器，&gt;或&lt;号不一定都有实现</span><br>    ++current;                     <span class="hljs-comment">// 使用前置++来递增迭代器</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>使用左右两个指针，前后两两比较，在重复值的位置替换成不重复的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) <span class="hljs-comment">// i是右指针，j是左指针</span><br><span class="hljs-keyword">if</span> (nums[j] != nums[i]) nums[++j] = nums[i];<br><span class="hljs-keyword">return</span> ++j;<br>&#125;<br></code></pre></td></tr></table></figure><p>右指针一直右移，遇到和左指针不同的，就将它的值赋给左指针，并使左指针移动到下一位。</p><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>遇见重复的元素就用<code>erase()</code>直接删除了，也是太简单粗暴了，感觉智商被题解碾压了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> curr = nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (curr != nums.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (*curr == *(curr<span class="hljs-number">-1</span>)) &#123;<br>            curr = nums.<span class="hljs-built_in">erase</span>(curr);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++curr;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意增加或删除vector中的元素会改变end迭代器的值，所以<code>nums.end()</code>需要写在循环条件里，每次循环都调用。</p><h3 id="使用标准库函数std-unique-（作弊）"><a href="#使用标准库函数std-unique-（作弊）" class="headerlink" title="使用标准库函数std::unique()（作弊）"></a>使用标准库函数<code>std::unique()</code>（作弊）</h3><p><code>std::unique()</code>接受一对迭代器，将这两个迭代器范围内的元素不重复的排到前面，然后返回不重复区域的下一个位置的迭代器。最后用<code>erase()</code>将此位置到末尾的元素都删除即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    nums.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">unique</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将 Hexo 部署到 Github 上</title>
    <link href="/blog/deploy-hexo-on-github/"/>
    <url>/blog/deploy-hexo-on-github/</url>
    
    <content type="html"><![CDATA[<h2 id="主要参考"><a href="#主要参考" class="headerlink" title="主要参考"></a>主要参考</h2><ul><li><a href="https://hexo.io/docs/github-pages">GitHub Pages</a></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h4 id="博客目录创建git仓库，推送至source分支"><a href="#博客目录创建git仓库，推送至source分支" class="headerlink" title="博客目录创建git仓库，推送至source分支"></a>博客目录创建git仓库，推送至source分支</h4><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ps">git init<br>git add .<br>git commit<br>git branch <span class="hljs-literal">-M</span> source<br>git push origin source<br></code></pre></td></tr></table></figure><h4 id="更改-github-workflows-pages-yml"><a href="#更改-github-workflows-pages-yml" class="headerlink" title="更改.github/workflows/pages.yml"></a>更改<code>.github/workflows/pages.yml</code></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">source</span>  <span class="hljs-comment"># 监听push事件的分支，是博客源文件的分支</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">12.</span><span class="hljs-string">x</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;12.x&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">NPM</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.OS</span> <span class="hljs-string">&#125;&#125;-npm-cache</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br>          <span class="hljs-attr">publish_branch:</span> <span class="hljs-string">master</span>  <span class="hljs-comment"># 部署的分支，是Github Pages对应的目录</span><br></code></pre></td></tr></table></figure><p>注意一下分支名字即可。</p><h4 id="更改项目Github-Pages的源目录"><a href="#更改项目Github-Pages的源目录" class="headerlink" title="更改项目Github Pages的源目录"></a>更改项目Github Pages的源目录</h4><p>在项目的<code>Settings</code>页的<code>Pages</code>标签里，将源目录改为<code>master</code>，保存就好了。</p><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><p>这两个是Fluid主题给的教程，但是不太看得懂到底部署到哪儿去了，最后没有用。</p><ul><li><a href="https://hexo.fluid-dev.com/posts/actions-deploy/">利用 GitHub Actions 自动部署 Hexo 博客</a></li><li><a href="https://zkqiang.cn/posts/e8ed6836/">编写自己的 GitHub Action，体验自动化部署</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客，不知道起什么标题好</title>
    <link href="/essay/first-blog/"/>
    <url>/essay/first-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客，不知道起什么标题好"><a href="#第一篇博客，不知道起什么标题好" class="headerlink" title="第一篇博客，不知道起什么标题好"></a>第一篇博客，不知道起什么标题好</h1><p>总之就先随便写写吧。</p><h2 id="2021-年-6-月-8-日"><a href="#2021-年-6-月-8-日" class="headerlink" title="2021 年 6 月 8 日"></a>2021 年 6 月 8 日</h2><p>今天是 2021 年 6 月 8 日，是高考的最后一天。1461天之前的我，现在可能正在考场里检查着自己的英语试卷吧。四年时光如同白驹过隙，转眼间就已经快要毕业了。</p><h2 id="突然开始写博客"><a href="#突然开始写博客" class="headerlink" title="突然开始写博客"></a>突然开始写博客</h2><p>作为一个计算机系的学生，居然在临近毕业的时候才开始捣鼓博客，属实有些贻笑大方。无论如何，算是个开始吧。研究生的生活已经开始，希望这个博客能够多少留下一点印迹吧。</p><h2 id="Be-Happy"><a href="#Be-Happy" class="headerlink" title="Be Happy"></a>Be Happy</h2><p>算是人生信条吧，做人最重要就是开心。当然，也要为了以后能一直开心下去。</p><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>其实本科四年最大的遗憾就是并没有真正地学好一门技术。原以为只需要按部就班做好课内的工作就可以了，结果来说确实做的还可以，各种考试成绩都还行，但是除此以外好像也就没了。要说四年里最大的收获，可能就是我明白了自己真正喜欢什么、不喜欢什么。</p><p>大三与大四之间的暑假，在保研名额还没完全决定的时候，其实为找工作焦虑过一小段时间。编程语言没深入过，没有什么项目，学院给的实习机会也没有报名。</p><p>后来决定要了这个保研名额，其实也是走了一个退路。希望多出来的这两年时间，能够让我为工作做好充足的准备吧。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>希望以后还是能在离家近的地方工作，所以 TX 是个不错的目标。由于研究方向与算法岗完全不搭边儿，可以安心地准备找开发岗的工作了。先把 C++ 和 Go 学好吧。</p><p>当然，考公才是我心中最佳的选择，无奈考公也卷，而且考不上就是考不上了，不像给资本家打工那样可以退而求其次。所以只能做两手准备了，现在先把字练好吧。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我自认为自己是典型的三分钟热度，只希望这不是最后一篇博客，无论写点什么，都能够坚持下去。就酱。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
