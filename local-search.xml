<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++常用标准库容器</title>
    <link href="/programming/cpp-stl-containers/"/>
    <url>/programming/cpp-stl-containers/</url>
    
    <content type="html"><![CDATA[<h1 id="C-常用标准库容器"><a href="#C-常用标准库容器" class="headerlink" title="C++常用标准库容器"></a>C++常用标准库容器</h1><p><a href="https://www.geeksforgeeks.org/containers-cpp-stl/">https://www.geeksforgeeks.org/containers-cpp-stl/</a></p><h2 id="顺序容器-sequence-containers"><a href="#顺序容器-sequence-containers" class="headerlink" title="顺序容器 (sequence containers)"></a>顺序容器 (sequence containers)</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>可以动态扩展的列表</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br></code></pre></td></tr></table></figure><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th></tr></thead><tbody><tr><td>插入</td><td>v.insert(v.begin(), 3)</td></tr><tr><td>插入到最后面<br />插入到最前面</td><td>v.push_back(3)<br />v.push_front(3)</td></tr><tr><td>删除</td><td>v.erase(v.begin())<br />v.erase(v.begin(), v.end())</td></tr><tr><td>删除尾元素<br />删除头元素</td><td>v.pop_back()<br />v.pop_front()</td></tr><tr><td>计数</td><td>v.count(3)</td></tr></tbody></table><h2 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h2><p>关联容器可能会使用到的数据类型，定义在头文件<code>utility</code>中。具有两个数据成员，名字为<code>first</code>以及<code>second</code>。</p><h2 id="关联容器-associative-containers"><a href="#关联容器-associative-containers" class="headerlink" title="关联容器 (associative containers)"></a>关联容器 (associative containers)</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>map&lt;string, <span class="hljs-keyword">int</span>&gt; map;<br></code></pre></td></tr></table></figure><h4 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>插入</td><td>map.insert({“word”, 1})<br />map.insert(make_pair(“word”, 1))<br />map.insert(pair&lt;string, size_t&gt;(“word”, 1))</td><td></td></tr><tr><td>删除</td><td>map.erase(“word”)<br />map.erase(iterator)</td><td></td></tr><tr><td>查找</td><td>map.find(“word”)</td><td>返回指向第一个找到元素的迭代器<br />迭代器指向的类型为pair<br />若未找到，则返回尾后迭代器</td></tr><tr><td>计数</td><td>map.count(“word”)</td><td>计数值</td></tr></tbody></table><h4 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h4><p>map（以及unordered_map）可以使用下标运算符，获取关键字对应的值。</p><p>如果关键字不存在，会用这个关键字创建一个新的元素，并对关联的值初始化。因此不应该直接用下标操作来进行查找，应该使用<code>find()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">map[<span class="hljs-string">&quot;hello&quot;</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 会插入一个关键字为hello的元素，且值为1</span><br></code></pre></td></tr></table></figure><h2 id="无序关联容器-unordered-associative-containers"><a href="#无序关联容器-unordered-associative-containers" class="headerlink" title="无序关联容器 (unordered associative containers)"></a>无序关联容器 (unordered associative containers)</h2><p>使用哈希函数组织的关联容器，查找速度更快，时间复杂度平均<code>O(1)</code>，最坏<code>O(n)</code>。在关键字类型元素没有明显有序关系时，可以使用无序容器。</p><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>无序键值对</p><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; umap;<br></code></pre></td></tr></table></figure><h4 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>插入</td><td>umap.insert({“word”, 1})<br />umap.insert(make_pair(“word”, 1))<br />umap.insert(pair&lt;string, size_t&gt;(“word”, 1))</td><td></td></tr><tr><td>查询</td><td>umap.find(“word”)</td><td></td></tr><tr><td>计数</td><td>umap.count(“word”)</td><td></td></tr></tbody></table><h2 id="容器适配器-container-adapters"><a href="#容器适配器-container-adapters" class="headerlink" title="容器适配器 (container adapters)"></a>容器适配器 (container adapters)</h2>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用泛型算法</title>
    <link href="/programming/cpp-generic-algorithms/"/>
    <url>/programming/cpp-generic-algorithms/</url>
    
    <content type="html"><![CDATA[<h1 id="C-常用泛型算法"><a href="#C-常用泛型算法" class="headerlink" title="C++常用泛型算法"></a>C++常用泛型算法</h1>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个数组的交集 II</title>
    <link href="/leetcode/intersection-of-two-arrays-ii/"/>
    <url>/leetcode/intersection-of-two-arrays-ii/</url>
    
    <content type="html"><![CDATA[<h1 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/</a></p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>将数组排序后，使用双指针，值相同则加入并集，否则向后移动<strong>值比较小</strong>的那个指针，直到其中一方越界。</p><p>时间复杂度：排序为<code>O(nlogn + mlogm)</code>，双指针移动为<code>O(n + m)</code>，加起来就是<code>O(nlogn + mlogm)</code></p><p>空间复杂度：由于<code>vector</code>的大小是动态改变的，复杂度为<code>O(1)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; intersection;<br><br>    <span class="hljs-keyword">int</span> n1 = <span class="hljs-number">0</span>, n2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> ( n1 != nums1.<span class="hljs-built_in">size</span>() &amp;&amp; n2 != nums2.<span class="hljs-built_in">size</span>() ) &#123;<br>        <span class="hljs-keyword">if</span> (nums1[n1] == nums2[n2]) &#123;<br>            intersection.<span class="hljs-built_in">push_back</span>(nums1[n1]);<br>            ++n1;<br>            ++n2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[n1] &gt; nums2[n2]) &#123;<br>            ++n2;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++n1;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> intersection;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希表来记录数字以及出现的次数。</p><ol><li>遍历较短的数组，依次将数字插入哈希表。</li><li>遍历较长的数组，查询哈希表中是否已有该元素。如果有，就将它加入并集中，并将哈希表中的计数减一；如果没有则无需采取任何操作。</li></ol><p>时间复杂度：遍历两个数组所用的时间<code>O(m + n)</code>，哈希表的插入和查询平均都是<code>O(1)</code>。</p><p>空间复杂度：创建了大小为较短数组长度的哈希表，因此是<code>O(min(m, n))</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() &lt; nums2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersect</span>(nums2, nums1);<br><br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; intersection;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums1) &#123;<br>        ++m[x];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums2) &#123;<br>        <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(x) != m.<span class="hljs-built_in">end</span>() &amp;&amp; (m.<span class="hljs-built_in">find</span>(x) -&gt; second) &gt; <span class="hljs-number">0</span>) &#123;<br>            --m[x];<br>            intersection.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> intersection;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现时，可以不用<code>find(x)</code>来查找，直接利用<code>count(x)</code>来判断表中是否存该数字，计数减一后判断计数值是不是变成0了，是的话就从表中删去此元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>C++</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>只出现一次的数字</title>
    <link href="/leetcode/single-number/"/>
    <url>/leetcode/single-number/</url>
    
    <content type="html"><![CDATA[<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/</a></p><p><a href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希表，如果放入元素时候已经有了，就删掉它。最后剩下的就是只出现一次的元素。时间复杂度是<code>O(n)</code>，空间复杂度也是<code>O(n)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(x)) &#123;<br>            s.<span class="hljs-built_in">erase</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            s.<span class="hljs-built_in">insert</span>(x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *(s.<span class="hljs-built_in">begin</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>数字按位进行异或运算。基于以下几点事实：</p><ul><li>任何数和自己做异或运算，结果为 0，即 a ⊕ a = 0 。</li><li>任何数和 0 做异或运算，结果还是自己，即 a ⊕ 0 = 0 。</li><li>异或运算中，满足交换律和结合律，a ⊕ b ⊕ a = b ⊕ a ⊕ a = b ⊕ ( a ⊕ a ) = b ⊕ 0 = b 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: nums) ret ^= e;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-的位和逻辑运算操作符"><a href="#C-的位和逻辑运算操作符" class="headerlink" title="C++的位和逻辑运算操作符"></a>C++的位和逻辑运算操作符</h2><table><thead><tr><th>运算</th><th>位运算操作符 (bitwise)</th><th>逻辑运算符(logical)</th></tr></thead><tbody><tr><td>AND</td><td>&amp;</td><td>&amp;&amp;</td></tr><tr><td>OR</td><td>|</td><td>||</td></tr><tr><td>XOR</td><td>^</td><td></td></tr><tr><td>NOT</td><td>~</td><td>!</td></tr><tr><td>left shift</td><td>&lt;&lt;</td><td></td></tr><tr><td>right shift</td><td>&gt;&gt;</td><td></td></tr></tbody></table><p>参考链接：<a href="https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/">https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>C++</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存在重复元素</title>
    <link href="/leetcode/contain-duplicates/"/>
    <url>/leetcode/contain-duplicates/</url>
    
    <content type="html"><![CDATA[<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/</a><br><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p><h2 id="排序后比较"><a href="#排序后比较" class="headerlink" title="排序后比较"></a>排序后比较</h2><p>先排序，然后比较相邻元素即可。使用C++的排序泛型算法<code>sort()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>将元素插入哈希表，如果插入时发现重复了，就可以返回了。</p><p>C++中，类似的功能可以用关联容器<code>unordered_set</code>实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(x) != s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        s.<span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>C++</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转数组</title>
    <link href="/leetcode/rotate-array/"/>
    <url>/leetcode/rotate-array/</url>
    
    <content type="html"><![CDATA[<h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/</a><br><a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></p><h2 id="临时数组"><a href="#临时数组" class="headerlink" title="临时数组"></a>临时数组</h2><p>最简单的方法，但是空间复杂为<code>O(n)</code>。</p><h2 id="环状替换"><a href="#环状替换" class="headerlink" title="环状替换"></a>环状替换</h2><p>如果直接将每个数字放至它<strong>最后的位置</strong>，这样被放置位置的元素会被覆盖从而丢失。</p><p>解决方法：从位置 0 开始，将它放到正确的位置（向右 k 位），然后<strong>把被覆盖的元素保存下来</strong>，再将它放到正确的位置（再向右 k 位），循环往复。</p><p>容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到（当 nums.length % k = 0 时，只会遍历偶数位置然后回到开头），此时应该跳到下一个位置然后继续。至于怎么判断该不该跳，我还不是很懂，详见<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/">题解</a>。</p><h2 id="数组翻转"><a href="#数组翻转" class="headerlink" title="数组翻转"></a>数组翻转</h2><p><img src="https://pic.leetcode-cn.com/1610072480-yiAYFw-image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[start], nums[end]);<br>            start += <span class="hljs-number">1</span>;<br>            end -= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        k %= nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums, k, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机 II</title>
    <link href="/leetcode/best-time-to-buy-and-sell-stock-ii/"/>
    <url>/leetcode/best-time-to-buy-and-sell-stock-ii/</url>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/</a><br><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>只看相邻的两天，只要后一天比前一天高，就是收益，非常简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> curr = prices.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>; curr != prices.<span class="hljs-built_in">end</span>(); ++curr) &#123;<br>        <span class="hljs-keyword">if</span> (*curr &gt; *(curr - <span class="hljs-number">1</span>))<br>            result += *curr - *(curr - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>刚做完一个双指针，指魔怔了，嗯是搞了个双指针。其实就是找到每一段递增区间的起点和终点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">auto</span> min = prices.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">auto</span> max = min;<br>    <span class="hljs-keyword">auto</span> end = prices.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (min != end &amp;&amp; max != end) &#123;<br>        <span class="hljs-keyword">while</span> ((min+<span class="hljs-number">1</span>) != end &amp;&amp; *min &gt; *(min + <span class="hljs-number">1</span>))<br>            ++min;<br>        max = min;<br>        <span class="hljs-keyword">while</span> ((max+<span class="hljs-number">1</span>) != end &amp;&amp; *max &lt; *(max + <span class="hljs-number">1</span>))<br>            ++max;<br>        result += *(max) - *(min);<br>        <span class="hljs-keyword">if</span> (min != end &amp;&amp; max != end) &#123;<br>            ++max;<br>            min = max;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>贪心算法</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何制作Unravel和damedane的Deepfake换脸视频</title>
    <link href="/essay/make-deepfake-meme/"/>
    <url>/essay/make-deepfake-meme/</url>
    
    <content type="html"><![CDATA[<h1 id="如何制作Unravel和damedane换脸视频"><a href="#如何制作Unravel和damedane换脸视频" class="headerlink" title="如何制作Unravel和damedane换脸视频"></a>如何制作Unravel和damedane换脸视频</h1><p>虽然这梗已经火了好久了，但是最近看多了，自己也想试着搞一个。奇怪的是知乎和B站居然搜不到教程，而上外网一下就找到了，于是写一个博客记录一下，顺便帮助有需要的人（虽然应该不会有人看我的博客）。</p><h2 id="准备照片和视频"><a href="#准备照片和视频" class="headerlink" title="准备照片和视频"></a>准备照片和视频</h2><h3 id="人脸照片"><a href="#人脸照片" class="headerlink" title="人脸照片"></a>人脸照片</h3><p>准备一张人脸照片（受害人），裁剪为长宽比例1：1，人脸最好在中间。这里请出明日方舟的制作人海猫络合物先生。<br><img src="/img/deepfake/oceancat.png" alt="Ocean Cat"></p><h3 id="母体视频"><a href="#母体视频" class="headerlink" title="母体视频"></a>母体视频</h3><p>如果是要制作damedane的，就不需要自己准备了，代码里已经预设好了。<br>Unravel的视频模板在这：<a href="https://www.kapwing.com/explore/unravel-tokyo-ghoul-meme-template">Unravel模板</a>，直接下载下来一会儿用。</p><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>这个翻唱Unravel的小姐姐YouTube视频在<a href="https://www.youtube.com/watch?v=Dsd9X_7WSd4">这里</a>，下面的评论都在感谢她提供了这么好的deepfake模板，真是令人哭笑不得。但是有一说一还是唱的挺好听的，就是不知道为什么一看她闭眼就想笑。<br><img src="/img/deepfake/comment.png" alt="thank you for the great deepfake template"></p><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><p>打开这个链接：<a href="https://colab.research.google.com/github/AliaksandrSiarohin/first-order-model/blob/master/demo.ipynb">Deepfake代码</a><br>依次点击两个代码块左边的运行按钮，滚动到页面底部，等待一会儿后就会出来图像界面。<br><img src="/img/deepfake/run_script.png" alt="依次点这两个播放按钮"><br>根据图形界面的指示，上传刚才准备好的图片和视频，点击<code>Generate</code>按钮就可以生成换脸视频了，需要等几分钟。如图所示，damedane的原版视频有预设了（奥巴马左边那位）。<br><img src="/img/deepfake/gui2.png" alt="海猫填充完毕"><br>生成完成后，下载下来即可。<br><img src="/img/deepfake/compare.png" alt="海猫的痛，你们懂吗"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>YouTube一搜Unravel就会有一个教程视频，然后找到了对应的文章。不过这个教程是快一年前的了，现在deepfake的脚本已经更新过了，不用这么麻烦了。<br><a href="https://www.youtube.com/watch?v=MXNBtws35WE&amp;t=518s">https://www.youtube.com/watch?v=MXNBtws35WE&amp;t=518s</a><br><a href="https://www.kapwing.com/resources/how-to-make-the-unravel-tokyo-ghoul-deepfake-meme/">https://www.kapwing.com/resources/how-to-make-the-unravel-tokyo-ghoul-deepfake-meme/</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>删除排序数组中的重复项</title>
    <link href="/leetcode/remove-duplicates-from-sorted-array/"/>
    <url>/leetcode/remove-duplicates-from-sorted-array/</url>
    
    <content type="html"><![CDATA[<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/</a><br><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">auto</span> iter_first = a.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> iter_second = iter_first + <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以直接对迭代器加减，得到指向下一个位置的迭代器</span><br><span class="hljs-keyword">auto</span> iter_last = a.<span class="hljs-built_in">end</span>();<br><br><span class="hljs-keyword">int</span> str = *iter_first;             <span class="hljs-comment">// 解引用迭代器得到它指向的值</span><br></code></pre></td></tr></table></figure><h3 id="遍历vector容器"><a href="#遍历vector容器" class="headerlink" title="遍历vector容器"></a>遍历<code>vector</code>容器</h3><p>范围<code>for</code>循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v: nums) &#123;<br>    v *= <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code>循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">auto</span> current = nums.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-keyword">while</span> (current != nums.<span class="hljs-built_in">end</span>()) &#123;    <span class="hljs-comment">// 使用!=号来比较迭代器，&gt;或&lt;号不一定都有实现</span><br>    ++current;                     <span class="hljs-comment">// 使用前置++来递增迭代器</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>使用左右两个指针，前后两两比较，在重复值的位置替换成不重复的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) <span class="hljs-comment">// i是右指针，j是左指针</span><br><span class="hljs-keyword">if</span> (nums[j] != nums[i]) nums[++j] = nums[i];<br><span class="hljs-keyword">return</span> ++j;<br>&#125;<br></code></pre></td></tr></table></figure><p>右指针一直右移，遇到和左指针不同的，就将它的值赋给左指针，并使左指针移动到下一位。</p><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>遇见重复的元素就用<code>erase()</code>直接删除了，也是太简单粗暴了，感觉智商被题解碾压了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> curr = nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (curr != nums.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (*curr == *(curr<span class="hljs-number">-1</span>)) &#123;<br>            curr = nums.<span class="hljs-built_in">erase</span>(curr);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++curr;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意增加或删除vector中的元素会改变end迭代器的值，所以<code>nums.end()</code>需要写在循环条件里，每次循环都调用。</p><h3 id="使用标准库函数std-unique-（作弊）"><a href="#使用标准库函数std-unique-（作弊）" class="headerlink" title="使用标准库函数std::unique()（作弊）"></a>使用标准库函数<code>std::unique()</code>（作弊）</h3><p><code>std::unique()</code>接受一对迭代器，将这两个迭代器范围内的元素不重复的排到前面，然后返回不重复区域的下一个位置的迭代器。最后用<code>erase()</code>将此位置到末尾的元素都删除即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    nums.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">unique</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>C++</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将Hexo部署到Github上</title>
    <link href="/blog/deploy-hexo-on-github/"/>
    <url>/blog/deploy-hexo-on-github/</url>
    
    <content type="html"><![CDATA[<h2 id="主要参考"><a href="#主要参考" class="headerlink" title="主要参考"></a>主要参考</h2><ul><li><a href="https://hexo.io/docs/github-pages">GitHub Pages</a></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h4 id="博客目录创建git仓库，推送至source分支"><a href="#博客目录创建git仓库，推送至source分支" class="headerlink" title="博客目录创建git仓库，推送至source分支"></a>博客目录创建git仓库，推送至source分支</h4><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ps">git init<br>git add .<br>git commit<br>git branch <span class="hljs-literal">-M</span> source<br>git push origin source<br></code></pre></td></tr></table></figure><h4 id="更改-github-workflows-pages-yml"><a href="#更改-github-workflows-pages-yml" class="headerlink" title="更改.github/workflows/pages.yml"></a>更改<code>.github/workflows/pages.yml</code></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">source</span>  <span class="hljs-comment"># 监听push事件的分支，是博客源文件的分支</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">12.</span><span class="hljs-string">x</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;12.x&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">NPM</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.OS</span> <span class="hljs-string">&#125;&#125;-npm-cache</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br>          <span class="hljs-attr">publish_branch:</span> <span class="hljs-string">master</span>  <span class="hljs-comment"># 部署的分支，是Github Pages对应的目录</span><br></code></pre></td></tr></table></figure><p>注意一下分支名字即可。</p><h4 id="更改项目Github-Pages的源目录"><a href="#更改项目Github-Pages的源目录" class="headerlink" title="更改项目Github Pages的源目录"></a>更改项目Github Pages的源目录</h4><p>在项目的<code>Settings</code>页的<code>Pages</code>标签里，将源目录改为<code>master</code>，保存就好了。</p><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><p>这两个是Fluid主题给的教程，但是不太看得懂到底部署到哪儿去了，最后没有用。</p><ul><li><a href="https://hexo.fluid-dev.com/posts/actions-deploy/">利用 GitHub Actions 自动部署 Hexo 博客</a></li><li><a href="https://zkqiang.cn/posts/e8ed6836/">编写自己的 GitHub Action，体验自动化部署</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客，不知道起什么标题好</title>
    <link href="/essay/first-blog/"/>
    <url>/essay/first-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客，不知道起什么标题好"><a href="#第一篇博客，不知道起什么标题好" class="headerlink" title="第一篇博客，不知道起什么标题好"></a>第一篇博客，不知道起什么标题好</h1><p>总之就先随便写写吧。</p><h2 id="2021年6月8日"><a href="#2021年6月8日" class="headerlink" title="2021年6月8日"></a>2021年6月8日</h2><p>今天是2021年6月8日，是高考的最后一天。1461天之前的我，现在可能正在考场里检查着自己的英语试卷吧。四年时光如同白驹过隙，转眼间就已经快要毕业了。</p><h2 id="突然开始写博客"><a href="#突然开始写博客" class="headerlink" title="突然开始写博客"></a>突然开始写博客</h2><p>作为一个计算机系的学生，居然在临近毕业的时候才开始捣鼓博客，属实有些贻笑大方。无论如何，算是个开始吧。研究生的生活已经开始，希望这个博客能够多少留下一点印迹吧。</p><h2 id="Be-Happy"><a href="#Be-Happy" class="headerlink" title="Be Happy"></a>Be Happy</h2><p>算是人生信条吧，做人最重要就是开心。当然，也要为了以后能一直开心下去。</p><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>其实本科四年最大的遗憾就是并没有真正地学好一门技术。原以为只需要按部就班做好课内的工作就可以了，结果来说确实做的还可以，各种考试成绩都还行，但是除此以外好像也就没了。要说四年里最大的收获，可能就是我明白了自己真正喜欢什么、不喜欢什么。</p><p>大三与大四之间的暑假，在保研名额还没完全决定的时候，其实为找工作焦虑过一小段时间。编程语言没深入过，没有什么项目，学院给的实习机会也没有报名。</p><p>后来决定要了这个保研名额，其实也是走了一个退路。希望多出来的这两年时间，能够让我为工作做好充足的准备吧。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>希望以后还是能在离家近的地方工作，所以TX是个不错的目标。由于研究方向与算法岗完全不搭边儿，可以安心地准备找开发岗的工作了。先把C++和Go学好吧。</p><p>当然，考公才是我心中最佳的选择，无奈考公也卷，而且考不上就是考不上了，不像给资本家打工那样可以退而求其次。所以只能做两手准备了，现在先把字练好吧。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我自认为自己是典型的三分钟热度，只希望这不是最后一篇博客，无论写点什么，都能够坚持下去。就酱。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
