<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>每日阅读论文记录</title>
    <link href="/essay/paper-reading-record/"/>
    <url>/essay/paper-reading-record/</url>
    
    <content type="html"><![CDATA[<h1 id="每日阅读论文记录"><a href="#每日阅读论文记录" class="headerlink" title="每日阅读论文记录"></a>每日阅读论文记录</h1><h2 id="9-月"><a href="#9-月" class="headerlink" title="9 月"></a>9 月</h2><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>09/15</td><td>A Short Review: Deep Retrieval-Based Dialogue Systems</td><td></td></tr><tr><td>09/16</td><td>Improved Deep Learning Baselines for Ubuntu Corpus Dialogs</td><td>UDC</td></tr><tr><td>09/16</td><td>Sequential Attention-based Network for Noetic End-to-End Response Selection</td><td>ESIM</td></tr><tr><td>09/23</td><td>Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks</td><td>SBERT</td></tr><tr><td>09/24</td><td>Augmented SBERT: Data Augmentation Method for Improving Bi-Encoders for Pairwise Sentence Scoring Tasks</td><td></td></tr><tr><td>09/25</td><td>Supervised Learning of Universal Sentence Representations from Natural Language Inference Data</td><td>InferSent</td></tr><tr><td>09/26</td><td>Learning Semantic Textual Similarity from Conversations</td><td>USE</td></tr><tr><td>09/27</td><td>A SIMPLE BUT TOUGH-TO-BEAT BASELINE FOR SENTENCE EMBEDDINGS (undone)</td><td></td></tr><tr><td>09/27</td><td>An Effective Domain Adaptive Post-Training Method for BERT in Response Selection</td><td>BERT-VFT</td></tr><tr><td>09/28</td><td>Sequential Matching Network: A New Architecture for Multi-turn Response Selection in Retrieval-Based Chatbots</td><td>SMN</td></tr><tr><td>09/29</td><td>APPLYING DEEP LEARNING TO ANSWER SELECTION: A STUDY AND AN OPEN TASK</td><td>Siam-CNN</td></tr></tbody></table><h2 id="10-月"><a href="#10-月" class="headerlink" title="10 月"></a>10 月</h2><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>10/06</td><td>Learning an Effective Context-Response Matching Model with Self-Supervised Tasks for Retrieval-based Dialogues</td><td>BERT-SL</td></tr><tr><td>10/07</td><td>Pre-train, Prompt, and Predict: A Systematic Survey of Prompting Methods in Natural Language Processing</td><td></td></tr><tr><td>10/08</td><td>Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</td><td>PET</td></tr><tr><td>10/09</td><td>GPT Understands, Too</td><td>P-Tuning</td></tr><tr><td>10/09</td><td>SimCSE: Simple Contrastive Learning of Sentence Embeddings</td><td>SimCSE</td></tr><tr><td>10/10</td><td>Structural Pre-training for Dialogue Comprehension</td><td>SPIDER</td></tr><tr><td>10/11</td><td>What Makes for Good Views for Contrastive Learning?</td><td></td></tr><tr><td>10/21</td><td>ConSERT: A Contrastive Framework for Self-Supervised Sentence Representation Transfer</td><td>ConSERT</td></tr><tr><td>10/23</td><td>Fine-grained Post-training for Improving Retrieval-based Dialogue Systems</td><td>BERT-FP</td></tr><tr><td>10/26</td><td>SEMANTIC RE-TUNING WITH CONTRASTIVE TENSION</td><td>CT</td></tr><tr><td>10/27</td><td>PRE-TRAINING TASKS FOR EMBEDDING-BASED LARGE-SCALE RETRIEVAL</td><td></td></tr></tbody></table><h2 id="11-月"><a href="#11-月" class="headerlink" title="11 月"></a>11 月</h2><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>11/3</td><td>Building an Efficient and Effective Retrieval-based Dialogue System</td><td>BE/CE</td></tr></tbody></table><h2 id="12-月"><a href="#12-月" class="headerlink" title="12 月"></a>12 月</h2><p>才发现自己已经摆烂一个多月了。接下来重点放在代码实现上，读完论文一定要看代码。</p><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>12/6</td><td>Prompt Tuning Can Be Comparable to Fine-tuning Universally Across Scales and Tasks</td><td>P-Tuning v2</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PyMongo 基本概念和操作</title>
    <link href="/mongo/pymongo-basic/"/>
    <url>/mongo/pymongo-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="PyMongo-基本概念和操作"><a href="#PyMongo-基本概念和操作" class="headerlink" title="PyMongo 基本概念和操作"></a>PyMongo 基本概念和操作</h1><p>最近尝试用数据库来给数据集提前储存 encode 好的 embeddings，原本想用 Sqlite 的，但是想到各种储存列表、大数值向量都很麻烦，于是去试了试非关系型数据库 MongoDB，发现用的是真的方便真的爽。</p><p>本文通过 MongoDB 的 python 接口例子来说明常用的一些使用方法。</p><h2 id="MongoDB-基本概念"><a href="#MongoDB-基本概念" class="headerlink" title="MongoDB 基本概念"></a>MongoDB 基本概念</h2><p>一篇写的不错的知乎文章：<a href="https://zhuanlan.zhihu.com/p/87722764">https://zhuanlan.zhihu.com/p/87722764</a></p><h3 id="数据库基本模型"><a href="#数据库基本模型" class="headerlink" title="数据库基本模型"></a>数据库基本模型</h3><table><thead><tr><th>MongoDB 概念</th><th>对应的 SQL 概念</th><th>备注</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>一个数据库包含多个集合（collection）</td></tr><tr><td>collection</td><td>table</td><td>可以储存多个文档，且没有模式限制</td></tr><tr><td>document</td><td>row</td><td>由多个字段表示，使用的 BSON 格式（类似 JSON）</td></tr><tr><td>field</td><td>column</td><td>字段可储存任意数据格式，如列表</td></tr></tbody></table><h3 id="BSON-数据类型"><a href="#BSON-数据类型" class="headerlink" title="BSON 数据类型"></a>BSON 数据类型</h3><p>BSON，Binary JSON，不能说跟 JSON 很像，只能说是一模一样。（并不，实际上多了索引等数据，且支持的数据类型也更多）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;_id&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<span class="hljs-attr">&quot;first&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">&quot;last&quot;</span>: <span class="hljs-string">&quot;Backus&quot;</span>&#125;,<br>    <span class="hljs-attr">&quot;contribs&quot;</span>: [<span class="hljs-string">&quot;Fortran&quot;</span>, <span class="hljs-string">&quot;ALGOL&quot;</span>, <span class="hljs-string">&quot;Backus-Naur Form&quot;</span>, <span class="hljs-string">&quot;FP&quot;</span>],<br>    <span class="hljs-attr">&quot;awards&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;award&quot;</span>: <span class="hljs-string">&quot;W.W. McDowell Award&quot;</span>,<br>            <span class="hljs-attr">&quot;year&quot;</span>: <span class="hljs-number">1967</span>,<br>            <span class="hljs-attr">&quot;by&quot;</span>: <span class="hljs-string">&quot;IEEE Computer Society&quot;</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;award&quot;</span>: <span class="hljs-string">&quot;Draper Prize&quot;</span>,<br>            <span class="hljs-attr">&quot;year&quot;</span>: <span class="hljs-number">1993</span>,<br>            <span class="hljs-attr">&quot;by&quot;</span>: <span class="hljs-string">&quot;National Academy of Engineering&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>_id</code> 字段是一条记录的主键，在 collection 中是唯一的，可以由系统自动生成（类型为 <code>ObjectId</code>），也可以自己指定。</p><h2 id="PyMongo-基本操作"><a href="#PyMongo-基本操作" class="headerlink" title="PyMongo 基本操作"></a>PyMongo 基本操作</h2><p>记得先安装并 import 哦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<br></code></pre></td></tr></table></figure><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="连接数据库服务器（无密码）"><a href="#连接数据库服务器（无密码）" class="headerlink" title="连接数据库服务器（无密码）"></a>连接数据库服务器（无密码）</h4><p>默认端口号是 27017</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client = pymongo.MongoClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">27017</span>)<br></code></pre></td></tr></table></figure><h4 id="获取具体的数据库、集合"><a href="#获取具体的数据库、集合" class="headerlink" title="获取具体的数据库、集合"></a>获取具体的数据库、集合</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">client = pymongo.MongoClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">27017</span>)<br><br><span class="hljs-comment"># 获取名字为 udc 的数据库</span><br>db = client[<span class="hljs-string">&quot;udc&quot;</span>]<br><br><span class="hljs-comment"># 获取数据库中两个集合</span><br>example_collection = db[<span class="hljs-string">&quot;example&quot;</span>]<br>candidate_collection = db[<span class="hljs-string">&quot;candidate&quot;</span>]<br></code></pre></td></tr></table></figure><p>如果数据库或集合未被创建，则会新建一个。（实际的创建行为会在写入第一个记录时才发生）</p><h3 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h3><p>以在某个 collection 上的查询为例子，操作非常简单，指定对应的字段名即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">example_collection.find_one(&#123;<span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-number">100012</span>&#125;)<br></code></pre></td></tr></table></figure><p>其他具体操作请查阅 MongoDB 官方文档：<a href="https://docs.mongodb.com/manual/crud/">https://docs.mongodb.com/manual/crud/</a></p><p>以及 pymongo 的示例：<a href="https://pymongo.readthedocs.io/en/stable/tutorial.html">https://pymongo.readthedocs.io/en/stable/tutorial.html</a></p><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>聚合（aggregation）稍微复杂，重要的<strong>关联查询</strong>就是使用这种操作完成的。MongoDB 中，可以给一系列的聚合操作定义一个 pipeline，像流水线一样层层过滤和组装，得到最终结果。</p><p>流水线通常是一个字典列表， 列表中每一个字典都是一个聚合操作，字典的 key 就是下面这些 $ 开头的字符串，对应的 value 是具体的参数字典。PyMongo 的一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">pipeline = [<br>    &#123;<br>        <span class="hljs-string">&quot;$sample&quot;</span>: &#123;   <span class="hljs-comment"># 操作名称为 $sample</span><br>            <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">3</span>  <span class="hljs-comment"># 参数名 size 的值为 3</span><br>        &#125;<br>    &#125;,<br>    ...<br>]<br></code></pre></td></tr></table></figure><h4 id="常用的一些聚合操作类型"><a href="#常用的一些聚合操作类型" class="headerlink" title="常用的一些聚合操作类型"></a>常用的一些聚合操作类型</h4><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>$project</td><td>指定输出文档中的字段</td></tr><tr><td>$match</td><td>相当于 query 语句</td></tr><tr><td>$limit</td><td>限制传递给下一步的文档数量</td></tr><tr><td>$lookup</td><td>多表关联查询</td></tr><tr><td>$sample</td><td>随机取样</td></tr><tr><td>$group</td><td>根据 key 分组文档</td></tr><tr><td>$sort</td><td>根据指定的字段排序文档</td></tr></tbody></table><p>具体见：</p><ul><li><a href="https://docs.mongodb.com/manual/core/aggregation-pipeline/">https://docs.mongodb.com/manual/core/aggregation-pipeline/</a></li><li><a href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/">https://docs.mongodb.com/manual/meta/aggregation-quick-reference/</a></li></ul><h4 id="关联查询-lookup"><a href="#关联查询-lookup" class="headerlink" title="关联查询 $lookup"></a>关联查询 <code>$lookup</code></h4><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;$lookup&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;from&quot;</span>: <span class="hljs-string">&quot;candidate&quot;</span>,<br>    <span class="hljs-attr">&quot;localField&quot;</span>: <span class="hljs-string">&quot;candidate_ids&quot;</span>,<br>    <span class="hljs-attr">&quot;foreignField&quot;</span>: <span class="hljs-string">&quot;_id&quot;</span>,<br>    <span class="hljs-attr">&quot;as&quot;</span>: <span class="hljs-string">&quot;candidates&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>from</td><td>关联的外表</td></tr><tr><td>localField</td><td>本表的关联字段</td></tr><tr><td>foreignField</td><td>外表的关联字段</td></tr><tr><td>as</td><td>输出的字段值</td></tr></tbody></table><p>所以上面的语句就是我现在在 <code>example</code> 集合（本表）中，跑去看名为 <code>candidate</code> 的集合（外表），将本表中 <code>candidates_ids</code> 字段中与外表的 <code>_id</code> 字段进行关联，相同的值的外表文档输出到一个列表里，插入到本表文档中，字段名为 <code>candidates</code> 。</p><p>在我的例子中，我的 <code>candidates_ids </code> 本身就是一个列表，里面仅储存了另一个集合的主键（相当于外键），因此关联后返回一个列表，里面的元素是外表中的文档。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">_id:<span class="hljs-number">1100142</span><br>tag:<span class="hljs-string">&quot;dev&quot;</span><br>context:Array<br>response_id:<span class="hljs-string">&quot;9ZOANIYSNBUL&quot;</span><br>candidate_ids:Array<br>cadidates:Array<br></code></pre></td></tr></table></figure><h4 id="PyMongo-使用流水线进行聚合的示例"><a href="#PyMongo-使用流水线进行聚合的示例" class="headerlink" title="PyMongo 使用流水线进行聚合的示例"></a>PyMongo 使用流水线进行聚合的示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">pipeline = [<br>        &#123;<br>            <span class="hljs-string">&quot;$match&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-number">1105000</span><br>            &#125;<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;$sample&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">5</span><br>            &#125;<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;$lookup&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-string">&quot;candidate&quot;</span>,<br>                <span class="hljs-string">&quot;localField&quot;</span>: <span class="hljs-string">&quot;candidate_ids&quot;</span>,<br>                <span class="hljs-string">&quot;foreignField&quot;</span>: <span class="hljs-string">&quot;_id&quot;</span>,<br>                <span class="hljs-string">&quot;as&quot;</span>: <span class="hljs-string">&quot;candidates&quot;</span><br>            &#125;<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;$lookup&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-string">&quot;candidate&quot;</span>,<br>                <span class="hljs-string">&quot;localField&quot;</span>: <span class="hljs-string">&quot;response_id&quot;</span>,<br>                <span class="hljs-string">&quot;foreignField&quot;</span>: <span class="hljs-string">&quot;_id&quot;</span>,<br>                <span class="hljs-string">&quot;as&quot;</span>: <span class="hljs-string">&quot;response&quot;</span><br>            &#125;<br>        &#125;<br>    ]<br><br>    <span class="hljs-keyword">with</span> example_collection.aggregate(pipeline, batchSize=batch_size) <span class="hljs-keyword">as</span> cursor:<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cursor:<br>            <span class="hljs-built_in">print</span>(item[<span class="hljs-string">&quot;tag&quot;</span>])<br></code></pre></td></tr></table></figure><p>定义 <code>pipeline</code> 为聚合操作的列表，然后在 <code>example_collection</code> 集合上进行关联查询，返回一个 <code>cursor</code> 对象。可以直接遍历这个对象拿到值。</p><h3 id="cursor-对象"><a href="#cursor-对象" class="headerlink" title="cursor 对象"></a><code>cursor</code> 对象</h3><p>实际上是一个用于遍历 MongoDB 查询结果的工具。详见：<a href="https://pymongo.readthedocs.io/en/stable/api/pymongo/cursor.html">https://pymongo.readthedocs.io/en/stable/api/pymongo/cursor.html</a></p><p>具体用法有空另开一篇写，这篇就先到这儿了。</p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go build 命令用法</title>
    <link href="/programming/go-build/"/>
    <url>/programming/go-build/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-build-命令用法"><a href="#Go-build-命令用法" class="headerlink" title="Go build 命令用法"></a>Go build 命令用法</h1><h2 id="按文件打包"><a href="#按文件打包" class="headerlink" title="按文件打包"></a>按文件打包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build main.go utils.go<br></code></pre></td></tr></table></figure><h2 id="按包名打包"><a href="#按包名打包" class="headerlink" title="按包名打包"></a>按包名打包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build go-message-pusher<br></code></pre></td></tr></table></figure><h2 id="打包到不同操作系统"><a href="#打包到不同操作系统" class="headerlink" title="打包到不同操作系统"></a>打包到不同操作系统</h2><p>设置两个环境变量：</p><ul><li><code>GOARCH</code> = amd64</li><li><code>GOOS</code> = linux | windows</li></ul><h2 id="其他附加参数"><a href="#其他附加参数" class="headerlink" title="其他附加参数"></a>其他附加参数</h2><table><thead><tr><th>参数</th><th>备注</th></tr></thead><tbody><tr><td>-o</td><td>指定编译输出的名称</td></tr><tr><td>-i</td><td>安装作为目标依赖的包</td></tr><tr><td>-v</td><td>编译时显示包名</td></tr><tr><td>-p n</td><td>开启并发编译，默认情况下该值为 CPU 逻辑核数</td></tr><tr><td>-a</td><td>强制重新构建</td></tr><tr><td>-x</td><td>打印编译时会用到的所有命令</td></tr><tr><td>-n</td><td>打印编译时会用到的所有命令，但不真正执行</td></tr><tr><td>-race</td><td>开启竞态检测</td></tr></tbody></table><h2 id="GoLand-中的设置示例"><a href="#GoLand-中的设置示例" class="headerlink" title="GoLand 中的设置示例"></a>GoLand 中的设置示例</h2><p><img src="https://i.loli.net/2021/08/21/peVkNE19O4GwClj.png"></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串转换整数</title>
    <link href="/leetcode/top-interview-questions-easy/string-to-integer-atoi/"/>
    <url>/leetcode/top-interview-questions-easy/string-to-integer-atoi/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnoilh/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnoilh/</a></p><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p><h2 id="有限状态机-FSM"><a href="#有限状态机-FSM" class="headerlink" title="有限状态机 (FSM)"></a>有限状态机 (FSM)</h2><p>字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码。臃肿还是其次，一堆 if-else 各种边界条件严格的想吐。。</p><p>使用有限状态机实现各种状态之间的转移。根据题目，容易画出来状态机图：</p><p><img src="https://i.loli.net/2021/08/06/3OLdx5pKkloamte.png"></p><p>状态机可以用一个状态转移表来实现。如图所示，行头是当前状态，列头是下一个输入，表中内容是跳转至的状态。直接将这个表编码进程序中，在状态为 in_number 时计数。</p><p><img src="https://i.loli.net/2021/08/06/XTm849u6plGHdSt.png"></p><p>对于 C++，居然可以用 long long 类型来计数，再去判断它跟 INT_MAX 和 INT_MIN 谁大谁小，属实有点无语。自己写程序的时候搞了半天。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Automaton</span> &#123;</span><br>    string state = <span class="hljs-string">&quot;start&quot;</span>;<br>    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;<br>        &#123;<span class="hljs-string">&quot;start&quot;</span>, &#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;signed&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;in_number&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;end&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_col</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>        state = table[state][<span class="hljs-built_in">get_col</span>(c)];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-string">&quot;in_number&quot;</span>) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            ans = sign == <span class="hljs-number">1</span> ? <span class="hljs-built_in">min</span>(ans, (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MAX) : <span class="hljs-built_in">min</span>(ans, -(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MIN);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == <span class="hljs-string">&quot;signed&quot;</span>)<br>            sign = c == <span class="hljs-string">&#x27;+&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        Automaton automaton;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str)<br>            automaton.<span class="hljs-built_in">get</span>(c);<br>        <span class="hljs-keyword">return</span> automaton.sign * automaton.ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证回文串</title>
    <link href="/leetcode/top-interview-questions-easy/valid-palindrome/"/>
    <url>/leetcode/top-interview-questions-easy/valid-palindrome/</url>
    
    <content type="html"><![CDATA[<h1 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xne8id/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xne8id/</a></p><p><a href="https://leetcode-cn.com/problems/valid-palindrome/">https://leetcode-cn.com/problems/valid-palindrome/</a></p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>左右指针，移动到合法位置（只能是字母、数字）后比较字符是否相同。</p><p>时间复杂度：<code>O(n)</code></p><p>空间复杂度：<code>O(1)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isalnum</span>(s[l])) &#123;<br>            ++l;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isalnum</span>(s[r])) &#123;<br>            --r;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">tolower</span>(s[l]) != <span class="hljs-built_in">tolower</span>(s[r])) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ++l;<br>        --r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛选-判断"><a href="#筛选-判断" class="headerlink" title="筛选 + 判断"></a>筛选 + 判断</h2><p>比较蠢的方法，就不谈了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩 MineCraft 的 Fabric 服务器</title>
    <link href="/essay/minecraft-fabric-server/"/>
    <url>/essay/minecraft-fabric-server/</url>
    
    <content type="html"><![CDATA[<h1 id="玩-MineCraft-的-Fabric-服务器"><a href="#玩-MineCraft-的-Fabric-服务器" class="headerlink" title="玩 MineCraft 的 Fabric 服务器"></a>玩 MineCraft 的 Fabric 服务器</h1><p>MineCraft Java 版有两种常见的非官方服务器，Forge 和 Fabric，相当于是提供了官方接口之上再次的封装，让 mod 开发者更加方便编程。</p><p>网上有说法称 Fabric 服务器更小巧，且 Forge 已经比较老了，故最终选择了 Fabric。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="安装-Fabric-服务器"><a href="#安装-Fabric-服务器" class="headerlink" title="安装 Fabric 服务器"></a>安装 Fabric 服务器</h3><p>可以完全参照 Fabric 官网的文档：<a href="https://fabricmc.net/wiki/player:tutorials:install_server">Installing a Fabric Server without a GUI</a>，按部就班即可。</p><p>注意，在按照文档的示例一通命名改名操作后，启动命令是<code>java -jar server.jar</code>，而非<code>java -jar vanilla.jar</code>，后者相当于原版服务器，mod 不会生效。</p><p>可以使用与官方服务器相同的参数来指定使用的内存大小。例如：<code>java -Xms1024M -Xmx1024M -jar server.jar</code></p><h3 id="安装-Mod"><a href="#安装-Mod" class="headerlink" title="安装 Mod"></a>安装 Mod</h3><p>一些 mod 是要求在服务器上安装，另一些则是需要在本地客户端上安装，还有一些是两者都要。安装 mod 时需要看清 mod 本身的说明。</p><p>服务端安装 mod，将 mod 的 jar 包直接放入游戏根目录的 <code>mods</code> 目录下，重启服务器即可。mod 本身可能会有设置，对应的配置文件在 <code>config</code> 目录中。</p><p><img src="https://i.loli.net/2021/08/04/Gh38n2fHJq6d9OK.png" alt="mods 和 config 目录示意图"></p><p>目前我在服务端安装的 mod：（1.17.1 版本可用）</p><ul><li>Fabric API</li><li>修改苦力怕爆炸的行为（environmentalcreepers）</li><li>一键砍树（FallingTree）</li><li>连锁挖矿（diggusmaximus）（客户端服务器都要装）</li></ul><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="安装-Fabric-客户端"><a href="#安装-Fabric-客户端" class="headerlink" title="安装 Fabric 客户端"></a>安装 Fabric 客户端</h3><p>在这里下载 Fabric Installer：<a href="https://fabricmc.net/use/">Installation for: Minecraft Launcher</a></p><p>对于我用的 Windows 系统，jar 包和 .exe 文件都可以，运行后按提示安装即可。最好使用默认目录，防止自己忘记。</p><h3 id="安装-Mod-1"><a href="#安装-Mod-1" class="headerlink" title="安装 Mod"></a>安装 Mod</h3><p>直接将jar包放到这个目录中：<code>C:\Users\你的用户名\AppData\Roaming\.minecraft\mods</code></p><p>目前我在客户端安装的 mod：（1.17.1 版本可用）</p><ul><li>Fabric API</li><li>钓鱼自动收杆（Autofish）</li><li>连锁挖矿（diggusmaximus）（客户端服务器都要装）</li><li>小地图（voxel map）（非常好用！！）</li><li>mod 管理菜单（mod menu）</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MineCraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效字母异位词</title>
    <link href="/leetcode/top-interview-questions-easy/valid-anagram/"/>
    <url>/leetcode/top-interview-questions-easy/valid-anagram/</url>
    
    <content type="html"><![CDATA[<h1 id="有效字母异位词"><a href="#有效字母异位词" class="headerlink" title="有效字母异位词"></a>有效字母异位词</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn96us/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn96us/</a></p><p><a href="https://leetcode-cn.com/problems/valid-anagram/">https://leetcode-cn.com/problems/valid-anagram/</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>用一个哈希表储存字母出现次数。在字符串 <code>s</code> 中出现的 +1，在 <code>t</code> 中出现的 -1，最后看是不是全为 0 即可。</p><p>时间复杂度：<code>O(n)</code></p><p>空间复杂度：<code>O(|Σ|)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; m;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> &amp;c: s) &#123;<br>        m[c] += <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> &amp;c: t) &#123;<br>        m[c] -= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> curr = m.<span class="hljs-built_in">begin</span>(); curr != m.<span class="hljs-built_in">end</span>(); ++curr) &#123;<br>        <span class="hljs-keyword">if</span> (curr -&gt; second != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序后比较"><a href="#排序后比较" class="headerlink" title="排序后比较"></a>排序后比较</h2><p>排序后比较字符串是否相等。</p><p>时间复杂度：快速排序平均复杂度为 <code>O(nlogn)</code></p><p>空间复杂度：排序所需要的空间为 <code>O(logn)</code></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个唯一字符</title>
    <link href="/leetcode/top-interview-questions-easy/first-unique-character-in-a-string/"/>
    <url>/leetcode/top-interview-questions-easy/first-unique-character-in-a-string/</url>
    
    <content type="html"><![CDATA[<h1 id="第一个唯一字符"><a href="#第一个唯一字符" class="headerlink" title="第一个唯一字符"></a>第一个唯一字符</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn5z8r/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn5z8r/</a></p><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></p><h2 id="哈希表储存出现次数"><a href="#哈希表储存出现次数" class="headerlink" title="哈希表储存出现次数"></a>哈希表储存出现次数</h2><p>第一次遍历用哈希表统计出现次数，第二次遍历找到第一个出现次数为 1 的字符。</p><p>时间复杂度：<code>O(n)</code></p><p>空间复杂度：<code>O(|Σ|)</code> （需要最大为词表大小的空间来储存哈希表）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; m;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c: s) &#123;<br>        m[c] += <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (m[s[i]] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表储存出现的索引"><a href="#哈希表储存出现的索引" class="headerlink" title="哈希表储存出现的索引"></a>哈希表储存出现的索引</h2><p>第一次遍历用哈希表储存索引，如果已经存在，就将索引值设为 -1 。第二次遍历，找出索引值最小的，返回。</p><p>时间、空间复杂度与上一个方法相同。</p><h2 id="哈希表储存出现索引-队列"><a href="#哈希表储存出现索引-队列" class="headerlink" title="哈希表储存出现索引 + 队列"></a>哈希表储存出现索引 + 队列</h2><p>用和方法二一样的哈希表储存索引值，用一个队列来跟踪哪些字符是只出现一次的。</p><p>在插入字符时，如果不存在（第一次出现），将插入的字符及其索引加入到队列尾。而如果插入了一个已经出现过的字符时，从头开始检查队列，如果头元素出现过多次（在哈希表中对应的值为 -1），就弹出。</p><p>其实就是使用队列来维持字符原本的顺序，如果队列头的字符出现了多次就踢掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; position;<br>    queue&lt;pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;&gt; q;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (!position.<span class="hljs-built_in">count</span>(s[i])) &#123;<br>            position[s[i]] = i;<br>            q.<span class="hljs-built_in">emplace</span>(s[i], i);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            position[s[i]] = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; position[q.<span class="hljs-built_in">front</span>().first] == <span class="hljs-number">-1</span>) &#123;<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : q.<span class="hljs-built_in">front</span>().second;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：遍历字符串 <code>O(n)</code> + 队列操作 <code>O(|Σ|)</code>  = <code>O(n)</code></p><p>空间复杂度：<code>O(|Σ|)</code></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>哈希表</tag>
      
      <tag>队列</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>干掉 Disqus 评论区广告</title>
    <link href="/blog/fuck-disqus-ads/"/>
    <url>/blog/fuck-disqus-ads/</url>
    
    <content type="html"><![CDATA[<h1 id="干掉Disqus评论区广告"><a href="#干掉Disqus评论区广告" class="headerlink" title="干掉Disqus评论区广告"></a>干掉Disqus评论区广告</h1><p>这 Disqus 评论区的广告真是越来越离谱了，虽然内容看着还行，但是评论上面六个大图下面也六个大图，都™要比我博客本身的内容还多了，不治治它它就真不知道什么是黑手。</p><p><img src="https://i.loli.net/2021/07/20/ATIczgZXp7SwLPf.png" alt="我啪的一下就点进去看了，很快啊"></p><p>这些广告会延迟加载，直接使用 css 隐藏的方法不好用。一般这个 ID 为 disqus_thread 的 div 通常有 2 到 3 个 iframe，一般第一个和第三个都是广告。这个函数会等待两秒，等广告加载出来后再把它隐藏掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> disqus = jQuery(<span class="hljs-string">&#x27;#disqus_thread&#x27;</span>);<br><br>disqus.ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (disqus.children().length &gt;= <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">const</span> comments = disqus.find(<span class="hljs-string">&#x27;iframe:nth-child(2)&#x27;</span>).detach();<br>      disqus.empty().append(comments);<br>    &#125;<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>最后将这段脚本插入到自定义 js 中。对于我的 Fluid 主题，把 js 文件放在 source 文件夹下的任意地方，然后在配置文件中指定就好了。</p>]]></content>
    
    
    <categories>
      
      <category>博客建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>个人域名绑定 Github pages</title>
    <link href="/blog/add-domain/"/>
    <url>/blog/add-domain/</url>
    
    <content type="html"><![CDATA[<h1 id="个人域名绑定-Github-pages"><a href="#个人域名绑定-Github-pages" class="headerlink" title="个人域名绑定 Github pages"></a>个人域名绑定 Github pages</h1><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>我是在腾讯云上买的域名，按照指示按部就班就好，各种实名认证都搞好，审核速度还是挺快的。</p><h2 id="添加-DNS-解析记录"><a href="#添加-DNS-解析记录" class="headerlink" title="添加 DNS 解析记录"></a>添加 DNS 解析记录</h2><p>来到腾讯云的控制台，添加类型为 CNAME 的记录，指向自己原来的 GitHub Page 名<code>xxx.github.io</code>。</p><p>这里我添加的是 blog 子域名，记录值如下图所示。</p><p><img src="https://i.loli.net/2021/07/19/NXI9p5ymYvCxhBf.png" alt="这里我只用了 blog 子域名而没有直接解析主域名(@)"></p><h2 id="GitHub-pages相关设置"><a href="#GitHub-pages相关设置" class="headerlink" title="GitHub pages相关设置"></a>GitHub pages相关设置</h2><h3 id="添加-CNAME-文件"><a href="#添加-CNAME-文件" class="headerlink" title="添加 CNAME 文件"></a>添加 CNAME 文件</h3><p><strong>在博客源分支的<code>source</code>目录下创建名为 CNAME 的文件</strong>，内容为刚才添加了解析规则的域名。例如我的是：blog.gentlecomet.com。</p><p>由于我的博客使用的是 Hexo 以及 GitHub action 的自动部署，如果直接放在部署分支中，会在 push 源分支的时候被自动删掉，必须放在源分支的<code>source</code>目录下才行，这样部署的时候这个文件也会被正确地放到部署的分支中。</p><h3 id="设置-pages"><a href="#设置-pages" class="headerlink" title="设置 pages"></a>设置 pages</h3><p>在仓库的 Settings 里找到 Pages 选项卡，设置 custom domain 为 CNAME 中的域名，save 即可。最后把强制 HTTPS 打开就好了。</p><p><img src="https://i.loli.net/2021/07/19/RAjPHGbsDiNFzE2.png"></p><p>注意这一步实际上会自动添加一个 CNAME 文件在部署分支里。</p><h2 id="关于我的域名"><a href="#关于我的域名" class="headerlink" title="关于我的域名"></a>关于我的域名</h2><p>有选择困难症，想域名的时候想了好久。最后选了这个 gentle comet，neta 了我很喜欢的 YOASOBI 的一首歌 <strong>優しい彗星</strong> 的英文翻译，意为”温柔的彗星“。</p>]]></content>
    
    
    <categories>
      
      <category>博客建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>整数反转</title>
    <link href="/leetcode/top-interview-questions-easy/reverse-integer/"/>
    <url>/leetcode/top-interview-questions-easy/reverse-integer/</url>
    
    <content type="html"><![CDATA[<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnx13t/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnx13t/</a></p><p><a href="https://leetcode-cn.com/problems/reverse-integer/">https://leetcode-cn.com/problems/reverse-integer/</a></p><h2 id="逐位运算"><a href="#逐位运算" class="headerlink" title="逐位运算"></a>逐位运算</h2><p>使用<code>x % 10</code>取得个位数的值，将它加到临时值<code>ret</code>中，并且让<code>ret</code>倍增10。</p><p>使用<code>x /= 10</code>来去掉个位（C++）。</p><p><strong>用<code>INT_MIN / 10</code>和<code>INT_MAX / 10</code>来提前判断是否会越界</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ret &lt; INT_MIN / <span class="hljs-number">10</span> || ret &gt; INT_MAX / <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> last = x % <span class="hljs-number">10</span>;<br>        x /= <span class="hljs-number">10</span>;<br>        ret = <span class="hljs-number">10</span> * ret + last;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串</title>
    <link href="/leetcode/top-interview-questions-easy/reverse-string/"/>
    <url>/leetcode/top-interview-questions-easy/reverse-string/</url>
    
    <content type="html"><![CDATA[<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhbqj/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhbqj/</a></p><p><a href="https://leetcode-cn.com/problems/reverse-string/">https://leetcode-cn.com/problems/reverse-string/</a></p><h2 id="直接交换"><a href="#直接交换" class="headerlink" title="直接交换"></a>直接交换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n/<span class="hljs-number">2</span> ; ++i) &#123;<br>        <span class="hljs-built_in">swap</span>(s[i], s[n<span class="hljs-number">-1</span>-i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>官方题解是双指针，其实是差不多的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>; left &lt; right; ++left, --right) &#123;<br>        <span class="hljs-built_in">swap</span>(s[left], s[right]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署自己的 MineCraft 服务器</title>
    <link href="/essay/deploy-minecraft-server/"/>
    <url>/essay/deploy-minecraft-server/</url>
    
    <content type="html"><![CDATA[<h1 id="部署自己的-MineCraft-服务器"><a href="#部署自己的-MineCraft-服务器" class="headerlink" title="部署自己的 MineCraft 服务器"></a>部署自己的 MineCraft 服务器</h1><p>放假在家突然想玩新版MC，买了个Java版和朋友联机玩。记录一下折腾过程。</p><h2 id="服务器的配置要求"><a href="#服务器的配置要求" class="headerlink" title="服务器的配置要求"></a>服务器的配置要求</h2><p>原本在朋友1核2G的服务器上玩，遇到了第三个玩家加入就会被踢出去的问题，而服务器内存和CPU并未过载，推测是带宽不足（为128KB）。可能出现的错误信息有：</p><ul><li>登入失败：身份验证目前正在停机维护</li><li>lost connection：timed out</li></ul><p><img src="https://i.loli.net/2021/07/19/NsQHjSEZBkLTnOz.png" alt="错误信息"></p><p>为了能愉快地玩耍，在阿里云上买了个所谓的轻量应用服务器，2核2G内存，关键是峰值带宽为5M。搞定以后解决了所有问题，3个人玩的很流畅。虽然每月限流1000GB，但还是完全够用。一年99，并且再续费一年似乎也是99，感觉挺不错的。</p><p><img src="https://i.loli.net/2021/07/19/LaSM8ypwVfiJmAI.png" alt="我买的服务器的配置"></p><h2 id="开放服务器端口"><a href="#开放服务器端口" class="headerlink" title="开放服务器端口"></a>开放服务器端口</h2><p>在阿里云的服务器控制台中设置防火墙规则，开放MC要用的<code>25565</code>端口。</p><p><img src="https://i.loli.net/2021/07/19/5x8Vbvz1nkrqmPf.png" alt="不知道用的是TCP还是UDP，那就全部开放"></p><h2 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h2><h3 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install openjdk-16-jre-headless<br></code></pre></td></tr></table></figure><h3 id="安装screen"><a href="#安装screen" class="headerlink" title="安装screen"></a>安装screen</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install screen<br></code></pre></td></tr></table></figure><h3 id="下载MC服务器程序"><a href="#下载MC服务器程序" class="headerlink" title="下载MC服务器程序"></a>下载MC服务器程序</h3><p>下载地址见：<a href="https://www.minecraft.net/en-us/download/server">DOWNLOAD THE MINECRAFT: JAVA EDITION SERVER</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://launcher.mojang.com/v1/objects/a16d67e5807f57fc4e550299cf20226194497dc2/server.jar<br></code></pre></td></tr></table></figure><p>就是一个jar包，用Java运行这个包就启动了服务器。</p><h2 id="启动游戏服务器"><a href="#启动游戏服务器" class="headerlink" title="启动游戏服务器"></a>启动游戏服务器</h2><h3 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h3><p>创建了名为mc的会话。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S mc<br></code></pre></td></tr></table></figure><h3 id="运行游戏服务器"><a href="#运行游戏服务器" class="headerlink" title="运行游戏服务器"></a>运行游戏服务器</h3><p>两个参数<code>-Xmx</code>和<code>-Xms</code>分别指定了最大内存和最小内存。（均为1024M）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx1024M -Xms1024M -jar minecraft_server.1.17.1.jar nogui<br></code></pre></td></tr></table></figure><p>成功启动后就能看到各种提示信息，此时可以输入各种服务器命令了。</p><p><img src="https://i.loli.net/2021/07/19/MOFGxlQfTH5X3gd.png" alt="启动成功"></p><h3 id="保留Screen并退出"><a href="#保留Screen并退出" class="headerlink" title="保留Screen并退出"></a>保留Screen并退出</h3><p><code>ctrl + A + D</code></p><h3 id="再次进入"><a href="#再次进入" class="headerlink" title="再次进入"></a>再次进入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -r mc<br></code></pre></td></tr></table></figure><h3 id="强行杀死"><a href="#强行杀死" class="headerlink" title="强行杀死"></a>强行杀死</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S mc -X quit<br></code></pre></td></tr></table></figure><p>更多screen的用法详见：<a href="https://www.huaweicloud.com/articles/6d91932d9a65d3cb45101886ac6fe53a.html">linux中screen命令的用法</a></p><h2 id="MineCraft服务器属性"><a href="#MineCraft服务器属性" class="headerlink" title="MineCraft服务器属性"></a>MineCraft服务器属性</h2><p>详见：<a href="https://minecraft.fandom.com/zh/wiki/Server.properties?variant=zh#Java.E7.89.88_3">Minecraft服务器属性</a></p><p>编辑<code>server.properties</code>文件。</p><h2 id="MineCraft后台命令"><a href="#MineCraft后台命令" class="headerlink" title="MineCraft后台命令"></a>MineCraft后台命令</h2><p>详见：<a href="https://minecraft.fandom.com/zh/wiki/%E5%91%BD%E4%BB%A4?variant=zh#.E5.91.BD.E4.BB.A4.E5.88.97.E8.A1.A8.E5.8F.8A.E5.85.B6.E6.A6.82.E8.BF.B0">命令列表及其概述</a></p><p>启动服务器后直接输入命令即可，无需以<code>/</code>开头。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MineCraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转图像</title>
    <link href="/leetcode/top-interview-questions-easy/rotate-image/"/>
    <url>/leetcode/top-interview-questions-easy/rotate-image/</url>
    
    <content type="html"><![CDATA[<h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhhkv/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhhkv/</a></p><p><a href="https://leetcode-cn.com/problems/rotate-image/">https://leetcode-cn.com/problems/rotate-image/</a></p><h2 id="使用临时矩阵"><a href="#使用临时矩阵" class="headerlink" title="使用临时矩阵"></a>使用临时矩阵</h2><p>注意到旋转后元素位置和原位置的关系：</p><ul><li>原本在第n行，旋转后变成倒数第n列</li><li>原本在第m列，旋转后变成第m行</li></ul><p>即：<code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code></p><p>使用一个临时数组，利用上面这个规律更新临时数组。最后再将原数组换成临时数组，达到“原地修改”的目的。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间空间复杂度都是<code>O(n^2)​</code></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> temp = matrix;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; n; ++row) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; ++col) &#123;<br>            temp[col][n<span class="hljs-number">-1</span>-row] = matrix[row][col];<br>        &#125;<br>    &#125;<br><br>    matrix.<span class="hljs-built_in">swap</span>(temp);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原地旋转"><a href="#原地旋转" class="headerlink" title="原地旋转"></a>原地旋转</h2><p>直接在原地将每一个元素移动到它应该在的地方，并且把要被覆盖的元素也移动走。容易发现旋转一次，一个位置的元素对应了4个位置的变化，且它们之间组成一个环。因此用temp保存最后一个被覆盖的值，然后依次移动并覆盖即可。</p><p>这4个元素旋转一次后，<strong>相对于上一个位置</strong>的关系都是<code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code>。转换成<strong>相对于第一个位置</strong>（绝对位置）的关系：</p><ol><li><code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code></li><li><code>matrix[col][n-1-row] -&gt; matrix_new[n-1-row][n-1-col]</code></li><li><code>matrix[n-1-row][n-1-col] -&gt; matrix_new[n-1-col][row]</code></li><li><code>matrix[n-1-col][row] -&gt; matrix_new[row][col]</code></li></ol><p>如同上面说的，组成了一个循环。用一个<code>temp</code>变量保 存第一个丢失的值<code>matrix[row][col]</code>即可。</p><p>还有一个问题：需要遍历矩阵中的哪些元素？显然，一次这样的操作移动好了4个元素，因此当边长n为偶数时，可以将矩阵分成一样大小的4块，只需操作其中一块；</p><p><img src="https://i.loli.net/2021/07/17/zgGOmqE2jDtAr8P.png"></p><p>对于左上角的这一块，它的范围是：</p><ul><li>行：n/2</li><li>列：n/2</li></ul><p>如果边长n为奇数的时候呢？使用这种巧妙的方法：</p><p><img src="https://i.loli.net/2021/07/17/b9NjW7KMGdnDQt3.png"></p><p>对于左上角这一块，它的范围是：</p><ul><li>行：<code>n/2</code></li><li>列：<code>n/2 + 1</code></li></ul><p>综合起来可以写成：</p><ul><li>行：<code>n/2</code></li><li>列：<code>n/2 + n%2</code> （或者<code>(n+1)/2</code>）</li></ul><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(1)</code></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 注意for循环的范围</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; n/<span class="hljs-number">2</span>; ++row) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n/<span class="hljs-number">2</span> + n%<span class="hljs-number">2</span>; ++col) &#123;<br>            <span class="hljs-keyword">int</span> temp = matrix[row][col];<br>            matrix[row][col] = matrix[n<span class="hljs-number">-1</span>-col][row];<br>            matrix[n<span class="hljs-number">-1</span>-col][row] = matrix[n<span class="hljs-number">-1</span>-row][n<span class="hljs-number">-1</span>-col];<br>            matrix[n<span class="hljs-number">-1</span>-row][n<span class="hljs-number">-1</span>-col] = matrix[col][n<span class="hljs-number">-1</span>-row];<br>            matrix[col][n<span class="hljs-number">-1</span>-row] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用翻转来代替旋转"><a href="#使用翻转来代替旋转" class="headerlink" title="使用翻转来代替旋转"></a>使用翻转来代替旋转</h2><p>上下翻转，然后主对角线翻转，就能得到答案。</p><p><img src="https://i.loli.net/2021/07/17/xn5CS9HVprRDQMl.png"></p><p>这是根据之前的那个关键公式推断的：<code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code>。观察这个公式，主要是两点：</p><ol><li><code>row</code>变成了<code>n-1-row</code>（正数变成倒数）</li><li><code>row</code>和<code>col</code>交换（转置）</li></ol><p>而1可以用上下翻转得到，这样正数第n行就变成了倒数第n行；2可以通过转置得到，即行号变成列号。</p><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(1)</code></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 水平翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[n - i - <span class="hljs-number">1</span>][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 主对角线翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效的数独</title>
    <link href="/leetcode/top-interview-questions-easy/valid-sudoku/"/>
    <url>/leetcode/top-interview-questions-easy/valid-sudoku/</url>
    
    <content type="html"><![CDATA[<h1 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2f9gg/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2f9gg/</a></p><p><a href="https://leetcode-cn.com/problems/valid-sudoku">https://leetcode-cn.com/problems/valid-sudoku</a></p><h2 id="我的方法"><a href="#我的方法" class="headerlink" title="我的方法"></a>我的方法</h2><p>容易想到的是使用哈希表来记录一行/一列/一个方格内是否出现了重复值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = board.<span class="hljs-built_in">size</span>();<br>    unordered_set&lt;<span class="hljs-keyword">char</span>&gt; row, col, grid;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(row.<span class="hljs-built_in">insert</span>(board[i][j]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (board[j][i] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(col.<span class="hljs-built_in">insert</span>(board[j][i]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span> &amp;&amp; j%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">3</span>; ++x) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-number">3</span>; ++y) &#123;<br>                        <span class="hljs-keyword">if</span> (board[i+x][j+y] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(grid.<span class="hljs-built_in">insert</span>(board[i+x][j+y]).second)) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            grid.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        row.<span class="hljs-built_in">clear</span>();<br>        col.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一行和每一列是否有重复值比较好搞，但是如何在一次遍历中就记录方格里的值呢？</p><p>我的方法是判断遍历到的值是不是方格左上角的元素，是的话再遍历整个方格。这样实际上多了不必要的访问。</p><h2 id="更好的方法"><a href="#更好的方法" class="headerlink" title="更好的方法"></a>更好的方法</h2><p>如何在一次遍历就访问到方格里的元素呢？大家可能很好奇如何在一次遍历就访问到方格里的元素。方法就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> m = j / <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> n = j % <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>小编也很奇怪，为什么可以这样呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = board.<span class="hljs-built_in">size</span>();<br>    unordered_set&lt;<span class="hljs-keyword">char</span>&gt; row, col, grid;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(row.<span class="hljs-built_in">insert</span>(board[i][j]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (board[j][i] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(col.<span class="hljs-built_in">insert</span>(board[j][i]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> m = j / <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">int</span> n = j % <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">if</span> (board[m][n] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(grid.<span class="hljs-built_in">insert</span>(board[m][n]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        row.<span class="hljs-built_in">clear</span>();<br>        col.<span class="hljs-built_in">clear</span>();<br>        grid.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/leetcode/top-interview-questions-easy/two-sum/"/>
    <url>/leetcode/top-interview-questions-easy/two-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2jrse/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2jrse/</a></p><p><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>双重循环遍历，时间复杂度显然是<code>O(n^2)</code></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>在暴力法中，对于每一个<code>x</code>，都需要遍历一次整个数组来寻找<code>target - x</code>。</p><p>如何加快<code>target - x</code>的寻找速度？答案就是使用哈希表来储存<code>target - x</code>的值，这样寻找<code>target - x</code>的时间复杂度只有<code>O(1)</code>，总时间复杂度为<code>O(n)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">auto</span> p = m.<span class="hljs-built_in">find</span>(nums[i]);<br>        <span class="hljs-keyword">if</span> (p == m.<span class="hljs-built_in">end</span>()) &#123;<br>            m.<span class="hljs-built_in">insert</span>(&#123;target-nums[i], i&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;i, p -&gt; second&#125;;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><p>这里使用了 C++ 11的新特性列表初始化 (initialiser_list)，可以用花括号来初始化vector、作为函数参数使用、直接返回。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化</span><br>std::vector&lt;std::string&gt; words = &#123;<span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-string">&quot;mortar&quot;</span>, <span class="hljs-string">&quot;holding&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;together&quot;</span>&#125;; <br><br><span class="hljs-built_in">twoSum</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;, <span class="hljs-number">7</span>); <span class="hljs-comment">// 作为参数</span><br><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">numbers</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;  <span class="hljs-comment">// 作为返回值</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动零</title>
    <link href="/leetcode/top-interview-questions-easy/move-zeros/"/>
    <url>/leetcode/top-interview-questions-easy/move-zeros/</url>
    
    <content type="html"><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2ba4i/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2ba4i/</a></p><p><a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>使用左右两个指针，右指针一直移动，当指向的数非0时，与左指针交换，并移动左指针一次。</p><ul><li>左右指针一开始会在一起，如果当前的数非 0 ，它们交换也不会有变化</li><li>当遇到为 0 的数时，左指针停在 0 上，右指针会继续走，并将另一个非 0 的数交换过来</li></ul><p><strong>不会存在这样的情况</strong>：左右指针都非 0，交换导致相对顺序改变，因为右指针只会在遇到 0 的时候超越左指针，即左指针要么和右指针在一起，要么左指针指的是 0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (nums[right] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[left], nums[right]);<br>            ++left;<br>        &#125;<br>        ++right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加一</title>
    <link href="/leetcode/top-interview-questions-easy/plus-one/"/>
    <url>/leetcode/top-interview-questions-easy/plus-one/</url>
    
    <content type="html"><![CDATA[<h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2cv1c/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2cv1c/</a></p><p><a href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></p><h2 id="严密的逻辑"><a href="#严密的逻辑" class="headerlink" title="严密的逻辑"></a>严密的逻辑</h2><p>考虑所有可能的情况即可：</p><ol><li>不用进位，直接加一</li><li>需要进位，非最高位，则置为 0 并执行高一位的操作</li><li>需要进位，是最高位，则置为 0 并在前面插入一个 1，直接返回</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; digits)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> curr = digits.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (curr; curr &gt;= <span class="hljs-number">0</span>; --curr) &#123;<br>        <span class="hljs-keyword">if</span> (digits[curr] + <span class="hljs-number">1</span> == <span class="hljs-number">10</span>) &#123;<br>            digits[curr] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (curr == <span class="hljs-number">0</span>) &#123;<br>                digits.<span class="hljs-built_in">insert</span>(digits.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> digits;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            digits[curr] += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> digits;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用标准库容器</title>
    <link href="/programming/cpp-stl-containers/"/>
    <url>/programming/cpp-stl-containers/</url>
    
    <content type="html"><![CDATA[<h1 id="C-常用标准库容器"><a href="#C-常用标准库容器" class="headerlink" title="C++常用标准库容器"></a>C++常用标准库容器</h1><p><a href="https://www.geeksforgeeks.org/containers-cpp-stl/">https://www.geeksforgeeks.org/containers-cpp-stl/</a></p><h2 id="顺序容器-sequence-containers"><a href="#顺序容器-sequence-containers" class="headerlink" title="顺序容器 (sequence containers)"></a>顺序容器 (sequence containers)</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>可以动态扩展的列表</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br></code></pre></td></tr></table></figure><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th></tr></thead><tbody><tr><td>插入</td><td>v.insert(v.begin(), 3)</td></tr><tr><td>插入到最后面<br />插入到最前面</td><td>v.push_back(3)<br />v.push_front(3)</td></tr><tr><td>删除</td><td>v.erase(v.begin())<br />v.erase(v.begin(), v.end())</td></tr><tr><td>删除尾元素<br />删除头元素</td><td>v.pop_back()<br />v.pop_front()</td></tr><tr><td>计数</td><td>v.count(3)</td></tr></tbody></table><h2 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h2><p>关联容器可能会使用到的数据类型，定义在头文件<code>utility</code>中。具有两个数据成员，名字为<code>first</code>以及<code>second</code>。</p><h2 id="关联容器-associative-containers"><a href="#关联容器-associative-containers" class="headerlink" title="关联容器 (associative containers)"></a>关联容器 (associative containers)</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>map&lt;string, <span class="hljs-keyword">int</span>&gt; map;<br></code></pre></td></tr></table></figure><h4 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>插入</td><td>map.insert({“word”, 1})<br />map.insert(make_pair(“word”, 1))<br />map.insert(pair&lt;string, size_t&gt;(“word”, 1))</td><td></td></tr><tr><td>删除</td><td>map.erase(“word”)<br />map.erase(iterator)</td><td></td></tr><tr><td>查找</td><td>map.find(“word”)</td><td>返回指向第一个找到元素的迭代器<br />迭代器指向的类型为pair<br />若未找到，则返回尾后迭代器</td></tr><tr><td>计数</td><td>map.count(“word”)</td><td>计数值</td></tr></tbody></table><h4 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h4><p>map（以及unordered_map）可以使用下标运算符，获取关键字对应的<strong>值</strong>。</p><p>如果关键字不存在，会用这个关键字创建一个新的元素，并对关联的值初始化。因此不应该直接用下标操作来进行查找，应该使用<code>find()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">map[<span class="hljs-string">&quot;hello&quot;</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 会插入一个关键字为hello的元素，且值为1</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：map 的<strong>下标操作</strong>返回的是关键字对应的值，而<strong>解引用 map 迭代器</strong>返回的是一个 <strong><code>pair</code></strong> 对象。</p><h2 id="无序关联容器-unordered-associative-containers"><a href="#无序关联容器-unordered-associative-containers" class="headerlink" title="无序关联容器 (unordered associative containers)"></a>无序关联容器 (unordered associative containers)</h2><p>使用哈希函数组织的关联容器，查找速度更快，时间复杂度平均<code>O(1)</code>，最坏<code>O(n)</code>。在关键字类型元素没有明显有序关系时，可以使用无序容器。</p><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_set&lt;<span class="hljs-keyword">int</span>&gt; uset;<br></code></pre></td></tr></table></figure><h4 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>插入</td><td>uset.insert(5)</td><td>一个pair，first成员为指向插入元素的迭代器；second指示是否成功插入，true为成功插入，false为不成功（已经存在一样的元素）</td></tr><tr><td>清空</td><td>uset.clear()</td><td>void</td></tr><tr><td>查询</td><td>uset.find(key)</td><td>指向找到元素的迭代器，或者尾后迭代器（没找到）</td></tr></tbody></table><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>无序键值对</p><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; umap;<br></code></pre></td></tr></table></figure><h4 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>插入</td><td>umap.insert({“word”, 1})<br />umap.insert(make_pair(“word”, 1))<br />umap.insert(pair&lt;string, size_t&gt;(“word”, 1))</td><td></td></tr><tr><td>查询</td><td>umap.find(“word”)</td><td></td></tr><tr><td>计数</td><td>umap.count(“word”)</td><td></td></tr></tbody></table><h2 id="容器适配器-container-adapters"><a href="#容器适配器-container-adapters" class="headerlink" title="容器适配器 (container adapters)"></a>容器适配器 (container adapters)</h2>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用泛型算法</title>
    <link href="/programming/cpp-generic-algorithms/"/>
    <url>/programming/cpp-generic-algorithms/</url>
    
    <content type="html"><![CDATA[<h1 id="C-常用泛型算法"><a href="#C-常用泛型算法" class="headerlink" title="C++常用泛型算法"></a>C++常用泛型算法</h1><p><a href="https://www.geeksforgeeks.org/c-magicians-stl-algorithms/">https://www.geeksforgeeks.org/c-magicians-stl-algorithms/</a></p><p><a href="https://en.cppreference.com/w/cpp/algorithm">https://en.cppreference.com/w/cpp/algorithm</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// 泛型算法</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span>   <span class="hljs-comment">// 数值泛型算法</span></span><br></code></pre></td></tr></table></figure><h2 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h2><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>查找</td><td>find(v.begin(), v.end(), value)</td><td>满足条件的迭代器，找不到则为尾后</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="写容器算法"><a href="#写容器算法" class="headerlink" title="写容器算法"></a>写容器算法</h2><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>交换元素</td><td>swap(v.begin(), v.end())</td><td>void</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="重排容器算法"><a href="#重排容器算法" class="headerlink" title="重排容器算法"></a>重排容器算法</h2><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>排序</td><td>sort(v.begin(), v.end())</td><td>void</td></tr><tr><td>将不重复的排在前面</td><td>unique(v.begin(), v.end())</td><td>一个指向不重复值范围末尾的迭代器</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个数组的交集 II</title>
    <link href="/leetcode/top-interview-questions-easy/intersection-of-two-arrays-ii/"/>
    <url>/leetcode/top-interview-questions-easy/intersection-of-two-arrays-ii/</url>
    
    <content type="html"><![CDATA[<h1 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/</a></p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>将数组排序后，使用双指针，值相同则加入并集，否则向后移动<strong>值比较小</strong>的那个指针，直到其中一方越界。</p><p>时间复杂度：排序为<code>O(nlogn + mlogm)</code>，双指针移动为<code>O(n + m)</code>，加起来就是<code>O(nlogn + mlogm)</code></p><p>空间复杂度：由于<code>vector</code>的大小是动态改变的，复杂度为<code>O(1)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; intersection;<br><br>    <span class="hljs-keyword">int</span> n1 = <span class="hljs-number">0</span>, n2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> ( n1 != nums1.<span class="hljs-built_in">size</span>() &amp;&amp; n2 != nums2.<span class="hljs-built_in">size</span>() ) &#123;<br>        <span class="hljs-keyword">if</span> (nums1[n1] == nums2[n2]) &#123;<br>            intersection.<span class="hljs-built_in">push_back</span>(nums1[n1]);<br>            ++n1;<br>            ++n2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[n1] &gt; nums2[n2]) &#123;<br>            ++n2;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++n1;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> intersection;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希表来记录数字以及出现的次数。</p><ol><li>遍历较短的数组，依次将数字插入哈希表。</li><li>遍历较长的数组，查询哈希表中是否已有该元素。如果有，就将它加入并集中，并将哈希表中的计数减一；如果没有则无需采取任何操作。</li></ol><p>时间复杂度：遍历两个数组所用的时间<code>O(m + n)</code>，哈希表的插入和查询平均都是<code>O(1)</code>。</p><p>空间复杂度：创建了大小为较短数组长度的哈希表，因此是<code>O(min(m, n))</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() &lt; nums2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersect</span>(nums2, nums1);<br><br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; intersection;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums1) &#123;<br>        ++m[x];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums2) &#123;<br>        <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(x) != m.<span class="hljs-built_in">end</span>() &amp;&amp; (m.<span class="hljs-built_in">find</span>(x) -&gt; second) &gt; <span class="hljs-number">0</span>) &#123;<br>            --m[x];<br>            intersection.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> intersection;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现时，可以不用<code>find(x)</code>来查找，直接利用<code>count(x)</code>来判断表中是否存该数字，计数减一后判断计数值是不是变成0了，是的话就从表中删去此元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>只出现一次的数字</title>
    <link href="/leetcode/top-interview-questions-easy/single-number/"/>
    <url>/leetcode/top-interview-questions-easy/single-number/</url>
    
    <content type="html"><![CDATA[<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/</a></p><p><a href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希表，如果放入元素时候已经有了，就删掉它。最后剩下的就是只出现一次的元素。时间复杂度是<code>O(n)</code>，空间复杂度也是<code>O(n)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(x)) &#123;<br>            s.<span class="hljs-built_in">erase</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            s.<span class="hljs-built_in">insert</span>(x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *(s.<span class="hljs-built_in">begin</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>数字按位进行异或运算。基于以下几点事实：</p><ul><li>任何数和自己做异或运算，结果为 0，即 a ⊕ a = 0 。</li><li>任何数和 0 做异或运算，结果还是自己，即 a ⊕ 0 = 0 。</li><li>异或运算中，满足交换律和结合律，a ⊕ b ⊕ a = b ⊕ a ⊕ a = b ⊕ ( a ⊕ a ) = b ⊕ 0 = b 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: nums) ret ^= e;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-的位和逻辑运算操作符"><a href="#C-的位和逻辑运算操作符" class="headerlink" title="C++的位和逻辑运算操作符"></a>C++的位和逻辑运算操作符</h2><table><thead><tr><th>运算</th><th>位运算操作符 (bitwise)</th><th>逻辑运算符(logical)</th></tr></thead><tbody><tr><td>AND</td><td>&amp;</td><td>&amp;&amp;</td></tr><tr><td>OR</td><td>|</td><td>||</td></tr><tr><td>XOR</td><td>^</td><td></td></tr><tr><td>NOT</td><td>~</td><td>!</td></tr><tr><td>left shift</td><td>&lt;&lt;</td><td></td></tr><tr><td>right shift</td><td>&gt;&gt;</td><td></td></tr></tbody></table><p>参考链接：<a href="https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/">https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存在重复元素</title>
    <link href="/leetcode/top-interview-questions-easy/contain-duplicates/"/>
    <url>/leetcode/top-interview-questions-easy/contain-duplicates/</url>
    
    <content type="html"><![CDATA[<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/</a><br><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p><h2 id="排序后比较"><a href="#排序后比较" class="headerlink" title="排序后比较"></a>排序后比较</h2><p>先排序，然后比较相邻元素即可。使用C++的排序泛型算法<code>sort()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>将元素插入哈希表，如果插入时发现重复了，就可以返回了。</p><p>C++中，类似的功能可以用关联容器<code>unordered_set</code>实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(x) != s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        s.<span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转数组</title>
    <link href="/leetcode/top-interview-questions-easy/rotate-array/"/>
    <url>/leetcode/top-interview-questions-easy/rotate-array/</url>
    
    <content type="html"><![CDATA[<h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/</a><br><a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></p><h2 id="临时数组"><a href="#临时数组" class="headerlink" title="临时数组"></a>临时数组</h2><p>最简单的方法，但是空间复杂为<code>O(n)</code>。</p><h2 id="环状替换"><a href="#环状替换" class="headerlink" title="环状替换"></a>环状替换</h2><p>如果直接将每个数字放至它<strong>最后的位置</strong>，这样被放置位置的元素会被覆盖从而丢失。</p><p>解决方法：从位置 0 开始，将它放到正确的位置（向右 k 位），然后<strong>把被覆盖的元素保存下来</strong>，再将它放到正确的位置（再向右 k 位），循环往复。</p><p>容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到（当 nums.length % k = 0 时，只会遍历偶数位置然后回到开头），此时应该跳到下一个位置然后继续。至于怎么判断该不该跳，我还不是很懂，详见<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/">题解</a>。</p><h2 id="数组翻转"><a href="#数组翻转" class="headerlink" title="数组翻转"></a>数组翻转</h2><p><img src="https://i.loli.net/2021/07/17/xNXsC3YdFDwPa8O.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[start], nums[end]);<br>            start += <span class="hljs-number">1</span>;<br>            end -= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        k %= nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums, k, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机 II</title>
    <link href="/leetcode/top-interview-questions-easy/best-time-to-buy-and-sell-stock-ii/"/>
    <url>/leetcode/top-interview-questions-easy/best-time-to-buy-and-sell-stock-ii/</url>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/</a><br><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>只看相邻的两天，只要后一天比前一天高，就是收益，非常简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> curr = prices.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>; curr != prices.<span class="hljs-built_in">end</span>(); ++curr) &#123;<br>        <span class="hljs-keyword">if</span> (*curr &gt; *(curr - <span class="hljs-number">1</span>))<br>            result += *curr - *(curr - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>刚做完一个双指针，指魔怔了，嗯是搞了个双指针。其实就是找到每一段递增区间的起点和终点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">auto</span> min = prices.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">auto</span> max = min;<br>    <span class="hljs-keyword">auto</span> end = prices.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (min != end &amp;&amp; max != end) &#123;<br>        <span class="hljs-keyword">while</span> ((min+<span class="hljs-number">1</span>) != end &amp;&amp; *min &gt; *(min + <span class="hljs-number">1</span>))<br>            ++min;<br>        max = min;<br>        <span class="hljs-keyword">while</span> ((max+<span class="hljs-number">1</span>) != end &amp;&amp; *max &lt; *(max + <span class="hljs-number">1</span>))<br>            ++max;<br>        result += *(max) - *(min);<br>        <span class="hljs-keyword">if</span> (min != end &amp;&amp; max != end) &#123;<br>            ++max;<br>            min = max;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何制作 Unravel 和 damedane 的 Deepfake 换脸视频</title>
    <link href="/essay/make-deepfake-meme/"/>
    <url>/essay/make-deepfake-meme/</url>
    
    <content type="html"><![CDATA[<h1 id="如何制作-Unravel-和-damedane-换脸视频"><a href="#如何制作-Unravel-和-damedane-换脸视频" class="headerlink" title="如何制作 Unravel 和 damedane 换脸视频"></a>如何制作 Unravel 和 damedane 换脸视频</h1><p>虽然这梗已经火了好久了，但是最近看多了，自己也想试着搞一个。奇怪的是知乎和B站居然搜不到教程，而上外网一下就找到了，于是写一个博客记录一下，顺便帮助有需要的人（虽然应该不会有人看我的博客）。</p><h2 id="准备照片和视频"><a href="#准备照片和视频" class="headerlink" title="准备照片和视频"></a>准备照片和视频</h2><h3 id="人脸照片"><a href="#人脸照片" class="headerlink" title="人脸照片"></a>人脸照片</h3><p>准备一张人脸照片（受害人），裁剪为长宽比例1：1，人脸最好在中间。这里请出明日方舟的制作人海猫络合物先生。<br><img src="/img/deepfake/oceancat.png" alt="Ocean Cat"></p><h3 id="母体视频"><a href="#母体视频" class="headerlink" title="母体视频"></a>母体视频</h3><p>如果是要制作damedane的，就不需要自己准备了，代码里已经预设好了。<br>Unravel的视频模板在这：<a href="https://www.kapwing.com/explore/unravel-tokyo-ghoul-meme-template">Unravel模板</a>，直接下载下来一会儿用。</p><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>这个翻唱Unravel的小姐姐YouTube视频在<a href="https://www.youtube.com/watch?v=Dsd9X_7WSd4">这里</a>，下面的评论都在感谢她提供了这么好的deepfake模板，真是令人哭笑不得。但是有一说一还是唱的挺好听的，就是不知道为什么一看她闭眼就想笑。<br><img src="/img/deepfake/comment.png" alt="thank you for the great deepfake template"></p><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><p>打开这个链接：<a href="https://colab.research.google.com/github/AliaksandrSiarohin/first-order-model/blob/master/demo.ipynb">Deepfake代码</a><br>依次点击两个代码块左边的运行按钮，滚动到页面底部，等待一会儿后就会出来图像界面。<br><img src="/img/deepfake/run_script.png" alt="依次点这两个播放按钮"><br>根据图形界面的指示，上传刚才准备好的图片和视频，点击<code>Generate</code>按钮就可以生成换脸视频了，需要等几分钟。如图所示，damedane的原版视频有预设了（奥巴马左边那位）。<br><img src="/img/deepfake/gui2.png" alt="海猫填充完毕"><br>生成完成后，下载下来即可。<br><img src="/img/deepfake/compare.png" alt="海猫的痛，你们懂吗"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>YouTube一搜Unravel就会有一个教程视频，然后找到了对应的文章。不过这个教程是快一年前的了，现在deepfake的脚本已经更新过了，不用这么麻烦了。<br><a href="https://www.youtube.com/watch?v=MXNBtws35WE&amp;t=518s">https://www.youtube.com/watch?v=MXNBtws35WE&amp;t=518s</a><br><a href="https://www.kapwing.com/resources/how-to-make-the-unravel-tokyo-ghoul-deepfake-meme/">https://www.kapwing.com/resources/how-to-make-the-unravel-tokyo-ghoul-deepfake-meme/</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>删除排序数组中的重复项</title>
    <link href="/leetcode/top-interview-questions-easy/remove-duplicates-from-sorted-array/"/>
    <url>/leetcode/top-interview-questions-easy/remove-duplicates-from-sorted-array/</url>
    
    <content type="html"><![CDATA[<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/</a><br><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">auto</span> iter_first = a.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> iter_second = iter_first + <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以直接对迭代器加减，得到指向下一个位置的迭代器</span><br><span class="hljs-keyword">auto</span> iter_last = a.<span class="hljs-built_in">end</span>();<br><br><span class="hljs-keyword">int</span> str = *iter_first;             <span class="hljs-comment">// 解引用迭代器得到它指向的值</span><br></code></pre></td></tr></table></figure><h3 id="遍历vector容器"><a href="#遍历vector容器" class="headerlink" title="遍历vector容器"></a>遍历<code>vector</code>容器</h3><p>范围<code>for</code>循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v: nums) &#123;<br>    v *= <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code>循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">auto</span> current = nums.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-keyword">while</span> (current != nums.<span class="hljs-built_in">end</span>()) &#123;    <span class="hljs-comment">// 使用!=号来比较迭代器，&gt;或&lt;号不一定都有实现</span><br>    ++current;                     <span class="hljs-comment">// 使用前置++来递增迭代器</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>使用左右两个指针，前后两两比较，在重复值的位置替换成不重复的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) <span class="hljs-comment">// i是右指针，j是左指针</span><br><span class="hljs-keyword">if</span> (nums[j] != nums[i]) nums[++j] = nums[i];<br><span class="hljs-keyword">return</span> ++j;<br>&#125;<br></code></pre></td></tr></table></figure><p>右指针一直右移，遇到和左指针不同的，就将它的值赋给左指针，并使左指针移动到下一位。</p><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>遇见重复的元素就用<code>erase()</code>直接删除了，也是太简单粗暴了，感觉智商被题解碾压了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> curr = nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (curr != nums.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (*curr == *(curr<span class="hljs-number">-1</span>)) &#123;<br>            curr = nums.<span class="hljs-built_in">erase</span>(curr);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++curr;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意增加或删除vector中的元素会改变end迭代器的值，所以<code>nums.end()</code>需要写在循环条件里，每次循环都调用。</p><h3 id="使用标准库函数std-unique-（作弊）"><a href="#使用标准库函数std-unique-（作弊）" class="headerlink" title="使用标准库函数std::unique()（作弊）"></a>使用标准库函数<code>std::unique()</code>（作弊）</h3><p><code>std::unique()</code>接受一对迭代器，将这两个迭代器范围内的元素不重复的排到前面，然后返回不重复区域的下一个位置的迭代器。最后用<code>erase()</code>将此位置到末尾的元素都删除即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    nums.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">unique</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将 Hexo 部署到 Github 上</title>
    <link href="/blog/deploy-hexo-on-github/"/>
    <url>/blog/deploy-hexo-on-github/</url>
    
    <content type="html"><![CDATA[<h2 id="主要参考"><a href="#主要参考" class="headerlink" title="主要参考"></a>主要参考</h2><ul><li><a href="https://hexo.io/docs/github-pages">GitHub Pages</a></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h4 id="博客目录创建git仓库，推送至source分支"><a href="#博客目录创建git仓库，推送至source分支" class="headerlink" title="博客目录创建git仓库，推送至source分支"></a>博客目录创建git仓库，推送至source分支</h4><figure class="highlight ps"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ps">git init<br>git add .<br>git commit<br>git branch <span class="hljs-literal">-M</span> source<br>git push origin source<br></code></pre></td></tr></table></figure><h4 id="更改-github-workflows-pages-yml"><a href="#更改-github-workflows-pages-yml" class="headerlink" title="更改.github/workflows/pages.yml"></a>更改<code>.github/workflows/pages.yml</code></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">source</span>  <span class="hljs-comment"># 监听push事件的分支，是博客源文件的分支</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">12.</span><span class="hljs-string">x</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;12.x&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">NPM</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.OS</span> <span class="hljs-string">&#125;&#125;-npm-cache</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br>          <span class="hljs-attr">publish_branch:</span> <span class="hljs-string">master</span>  <span class="hljs-comment"># 部署的分支，是Github Pages对应的目录</span><br></code></pre></td></tr></table></figure><p>注意一下分支名字即可。</p><h4 id="更改项目Github-Pages的源目录"><a href="#更改项目Github-Pages的源目录" class="headerlink" title="更改项目Github Pages的源目录"></a>更改项目Github Pages的源目录</h4><p>在项目的<code>Settings</code>页的<code>Pages</code>标签里，将源目录改为<code>master</code>，保存就好了。</p><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><p>这两个是Fluid主题给的教程，但是不太看得懂到底部署到哪儿去了，最后没有用。</p><ul><li><a href="https://hexo.fluid-dev.com/posts/actions-deploy/">利用 GitHub Actions 自动部署 Hexo 博客</a></li><li><a href="https://zkqiang.cn/posts/e8ed6836/">编写自己的 GitHub Action，体验自动化部署</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客，不知道起什么标题好</title>
    <link href="/essay/first-blog/"/>
    <url>/essay/first-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客，不知道起什么标题好"><a href="#第一篇博客，不知道起什么标题好" class="headerlink" title="第一篇博客，不知道起什么标题好"></a>第一篇博客，不知道起什么标题好</h1><p>总之就先随便写写吧。</p><h2 id="2021-年-6-月-8-日"><a href="#2021-年-6-月-8-日" class="headerlink" title="2021 年 6 月 8 日"></a>2021 年 6 月 8 日</h2><p>今天是 2021 年 6 月 8 日，是高考的最后一天。1461天之前的我，现在可能正在考场里检查着自己的英语试卷吧。四年时光如同白驹过隙，转眼间就已经快要毕业了。</p><h2 id="突然开始写博客"><a href="#突然开始写博客" class="headerlink" title="突然开始写博客"></a>突然开始写博客</h2><p>作为一个计算机系的学生，居然在临近毕业的时候才开始捣鼓博客，属实有些贻笑大方。无论如何，算是个开始吧。研究生的生活已经开始，希望这个博客能够多少留下一点印迹吧。</p><h2 id="Be-Happy"><a href="#Be-Happy" class="headerlink" title="Be Happy"></a>Be Happy</h2><p>算是人生信条吧，做人最重要就是开心。当然，也要为了以后能一直开心下去。</p><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>其实本科四年最大的遗憾就是并没有真正地学好一门技术。原以为只需要按部就班做好课内的工作就可以了，结果来说确实做的还可以，各种考试成绩都还行，但是除此以外好像也就没了。要说四年里最大的收获，可能就是我明白了自己真正喜欢什么、不喜欢什么。</p><p>大三与大四之间的暑假，在保研名额还没完全决定的时候，其实为找工作焦虑过一小段时间。编程语言没深入过，没有什么项目，学院给的实习机会也没有报名。</p><p>后来决定要了这个保研名额，其实也是走了一个退路。希望多出来的这两年时间，能够让我为工作做好充足的准备吧。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>希望以后还是能在离家近的地方工作，所以 TX 是个不错的目标。由于研究方向与算法岗完全不搭边儿，可以安心地准备找开发岗的工作了。先把 C++ 和 Go 学好吧。</p><p>当然，考公才是我心中最佳的选择，无奈考公也卷，而且考不上就是考不上了，不像给资本家打工那样可以退而求其次。所以只能做两手准备了，现在先把字练好吧。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我自认为自己是典型的三分钟热度，只希望这不是最后一篇博客，无论写点什么，都能够坚持下去。就酱。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
