<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网易笔试题（3.27） 编程题 4. 沼泽地</title>
    <link href="/leetcode/programming-exam/travel-wetland/"/>
    <url>/leetcode/programming-exam/travel-wetland/</url>
    
    <content type="html"><![CDATA[<h1 id="网易笔试题（3-27）-编程题-4-沼泽地"><a href="#网易笔试题（3-27）-编程题-4-沼泽地" class="headerlink" title="网易笔试题（3.27） 编程题 4. 沼泽地"></a>网易笔试题（3.27） 编程题 4. 沼泽地</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个二维数组，元素只会是 0 或 1，0 代表 平地，1 代表沼泽。小红从左上角出发，要走到右下角，可以向左、右、下走，一次走一格。同地形的路程耗费 1 点时间，而跨越地形（从 0 走到 1 或者从 1 走到 0）需要时间 2 点，因为要更换装备。</p><p>求走到终点的最短耗时。</p><h2 id="DIJKSTRA-最短路径"><a href="#DIJKSTRA-最短路径" class="headerlink" title="DIJKSTRA 最短路径"></a>DIJKSTRA 最短路径</h2><p>很明显是个最短路径题，做的时候没想起来。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;container/heap&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>graph := [][]<span class="hljs-keyword">int</span>&#123;<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>&#125;<br>n, m := <span class="hljs-built_in">len</span>(graph), <span class="hljs-built_in">len</span>(graph[<span class="hljs-number">0</span>])<br><br>fmt.Println(dijkstra(graph)[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>])<br>&#125;<br><br><span class="hljs-keyword">type</span> State <span class="hljs-keyword">struct</span> &#123;<br>x                 <span class="hljs-keyword">int</span><br>y                 <span class="hljs-keyword">int</span><br>distanceFromStart <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>n, m := <span class="hljs-built_in">len</span>(graph), <span class="hljs-built_in">len</span>(graph[<span class="hljs-number">0</span>])<br>minDistanceTo := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> minDistanceTo &#123;<br>minDistanceTo[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, m)<br><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> minDistanceTo[i] &#123;<br>minDistanceTo[i][j] = math.MaxInt<br>&#125;<br>&#125;<br>minDistanceTo[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>pq := PriorityQueue&#123;&#125;<br>heap.Push(&amp;pq, &amp;State&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;)<br><br><span class="hljs-comment">// 3 个能走的方向</span><br>directions := [][]<span class="hljs-keyword">int</span>&#123;<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> pq.Len() &gt; <span class="hljs-number">0</span> &#123;<br>currState := heap.Pop(&amp;pq).(*State)<br>currX, currY, currDist := currState.x, currState.y, currState.distanceFromStart<br><br><span class="hljs-keyword">if</span> minDistanceTo[currX][currY] &lt; currDist &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> directions &#123;<br>nextX, nextY := currX+d[<span class="hljs-number">0</span>], currY+d[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">// 走出边界</span><br><span class="hljs-keyword">if</span> nextX &gt;= n || nextY &lt; <span class="hljs-number">0</span> || nextY &gt;= m &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>weight := <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> graph[nextX][nextY] != graph[currX][currY] &#123;<br>weight += <span class="hljs-number">1</span><br>&#125;<br><br>distanceToNext := minDistanceTo[currX][currY] + weight<br><br><span class="hljs-keyword">if</span> distanceToNext &lt; minDistanceTo[nextX][nextY] &#123;<br>minDistanceTo[nextX][nextY] = distanceToNext<br>heap.Push(&amp;pq, &amp;State&#123;nextX, nextY, distanceToNext&#125;)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> minDistanceTo<br>&#125;<br><br><span class="hljs-keyword">type</span> PriorityQueue []*State<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(pq)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> pq[i].distanceFromStart &lt; pq[j].distanceFromStart<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>pq[i], pq[j] = pq[j], pq[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span> <span class="hljs-title">Push</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>*pq = <span class="hljs-built_in">append</span>(*pq, x.(*State))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>old := *pq<br>n := <span class="hljs-built_in">len</span>(old)<br>item := old[n<span class="hljs-number">-1</span>]<br>old[n<span class="hljs-number">-1</span>] = <span class="hljs-literal">nil</span><br>*pq = old[:n<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> item<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>笔试编程题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里暑期实习后端面试记录</title>
    <link href="/essay/ali-interview-review/"/>
    <url>/essay/ali-interview-review/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里暑期实习后端面试记录"><a href="#阿里暑期实习后端面试记录" class="headerlink" title="阿里暑期实习后端面试记录"></a>阿里暑期实习后端面试记录</h1><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul><li>项目相关，难点，如何解决</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>进程和线程是什么，区别</li><li>进程间通信有哪几种</li><li>为什么操作系统要用用户态和内核态<ul><li>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。</li><li>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I&#x2F;O 许可位图(I&#x2F;O Permission Bitmap)中规定的可访问端口进行直接访问</li><li>通过区分内核空间和用户空间的设计，隔离了操作系统代码(操作系统的代码要比应用程序的代码健壮很多)与应用程序代码。即便是单个应用程序出现错误也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行</li><li><strong>区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性</strong></li></ul></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>三次握手过程，两次握手可以吗</li><li>HTTP 和 HTTPS 的区别</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>介绍 B 树，B+ 树，B* 树</li><li>MySQL 有哪些索引</li><li>对区分度不高的列（例如性别）可以建立索引吗，怎么建立索引<ul><li>不适合，区分度越低，索引效果越差</li></ul></li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><ul><li>五种数据类型及底层的实现有了解吗</li><li>为什么 ZSET 用跳跃表不用红黑树</li><li>内存淘汰策略</li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>单例模式等</li></ul><h2 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h2><ul><li>几十亿个无序正整数互不重复，储存在磁盘中，电脑内存不够大没有办法一次都进来，现在要查找几个数是否在这之中，有什么方法做到，复杂度 O(logn)<ul><li>利用二进制位建立类似二叉树结构（文件储存）</li><li>布隆过滤器</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>美团暑期实习后端面试记录</title>
    <link href="/essay/meituan-interview-review/"/>
    <url>/essay/meituan-interview-review/</url>
    
    <content type="html"><![CDATA[<h1 id="美团暑期实习后端面试记录"><a href="#美团暑期实习后端面试记录" class="headerlink" title="美团暑期实习后端面试记录"></a>美团暑期实习后端面试记录</h1><p>寄了，太紧张了，很多基础八股文没想起来。</p><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul><li>项目相关，难点，如何解决</li></ul><h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><ul><li>二叉树层序遍历打印</li><li>反转链表一个区间</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>什么是临界区<ul><li>临界资源：同一时间只允许一个进程使用的共享资源</li><li>对临界资源进行访问的那段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查</li><li>使用临界区时，一般不允许其运行时间过长，只要运行在临界区的线程还没有离开，其他所有进入此临界区的线程都会被挂起而进入等待状态</li></ul></li><li>进程间通信有哪些<ul><li>管道：只能在父子进程或者兄弟进程中使用</li><li>命名管道（FIFO）：去除了管道只能在父子进程中使用的限制</li><li>消息队列<ul><li>可以独立于读写进程存在</li><li>避免了 FIFO 的同步阻塞问题，即进程把消息放入队列就能继续运行</li><li>读进程可以根据消息类型有选择地接收消息</li></ul></li><li>信号量 &#x2F; 互斥量：信号量等于 0 时休眠，为多个进程提供对共享数据对象的访问</li><li>共享储存<ul><li>允许多个进程共享一个给定的存储区</li><li>需要用信号量同步</li><li>多个进程可以使用同一个文件的方式实现共享内存</li></ul></li><li>套接字：可以用于不同机器的通信</li></ul></li><li>死锁的四个必要条件<ul><li>互斥：资源不能共享</li><li>不可抢占：已经分配的资源不能被抢占</li><li>占用并等待：已经得到资源的进程可以继续申请新的资源</li><li>环路等待：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源</li></ul></li><li>满足了这四个条件就一定会发生死锁吗：不一定</li><li>怎么避免死锁<ul><li>在程序运行时对即将进入的状态判断，拒绝进入不安全的状态</li><li>安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的</li></ul></li><li>怎么预防死锁<ul><li>破坏四个必要条件之一</li></ul></li><li>为什么要加锁<ul><li>使共享资源同一时间只能由一个进程访问，避免出错</li></ul></li></ul><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>TCP 是怎么保证可靠传输的<ul><li>超时重传-确认机制：保证包不会丢失</li><li>首部校验和：保证包不会传输出错</li><li>流量控制：接收方告诉发送方发送窗口的大小，避免接收方因缓存不足而丢包</li><li>拥塞控制：降低整个网络的拥挤程度</li></ul></li><li>浏览器输入网址后发生了什么</li><li>数据是如何根据 IP 地址发送到目标主机的</li><li>怎么追踪分组到目的地经过了多少跳：traceroute<ul><li>发送无法交付的 UDP </li><li>从 TLL &#x3D; 1 开始依次增加 TTL，如果超时就增加 TTL</li><li>直到返回 ICMP 终点不可达差错报文</li></ul></li></ul><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><ul><li>MySQL 用的什么索引：B+ 树</li><li>为什么要用 B+ 树，不用普通的二叉树红黑树哈希索引<ul><li>二叉树、红黑树都是二叉树，相同的数据树的高度会更高，磁盘 IO 次数更多，B+ 树是多路树</li><li>哈希索引是无序的，不能部分查找或范围查找，无法用于排序与分组</li></ul></li><li>为什么不用 B 树<ul><li>磁盘一次会读入一整个块，树的每个节点都会使用一整个块的内存，<strong>B+ 树的内部节点只储存索引，不储存值</strong>，同样的内存空间大小下能储存更多的索引，树高更低</li><li>B+ 树叶子节点是有序链表且包含了父节点，区间查找更加方便（B 树的父节点在内部节点中，查找一个区间需要中序遍历）</li><li>B+ 树查询时间稳定，因为数据都只储存在叶节点中</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DIJKSTRA 算法</title>
    <link href="/leetcode/fucking-algorithm/dijkstra-algorithm/"/>
    <url>/leetcode/fucking-algorithm/dijkstra-algorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="DIJKSTRA-算法"><a href="#DIJKSTRA-算法" class="headerlink" title="DIJKSTRA 算法"></a>DIJKSTRA 算法</h1><p><a href="https://labuladong.gitee.io/algo/2/20/45/">https://labuladong.gitee.io/algo/2/20/45/</a></p><h2 id="算法模板"><a href="#算法模板" class="headerlink" title="算法模板"></a>算法模板</h2><p>输入：</p><ul><li><code>graph [][]int</code> 图的邻接矩阵，矩阵的值代表边的权重，-1 表示不直接相连</li><li><code>start int</code> 最短路径算法的起点</li></ul><p>输出：</p><ul><li><code>minDistanceTo []int</code> 从起点到其他所有点的最短距离，值为 <code>MaxInt</code> 表示不可达</li></ul><p>核心思想：</p><ul><li>从起点开始 BFS 遍历整幅图。遍历到某个点 <code>curr</code> 时，检查从 <code>start</code> 到 <code>curr</code> 的距离 <code>minDistanceTo[curr]</code> 加上到下一个点 <code>next</code> 的距离 <code>graph[curr][next]</code> 是否更短了。<ul><li>如果是，就说明这条路径比之前记录的更短，更新到 <code>next</code> 的最短路径，并且继续从 <code>next</code> 往后遍历；</li><li>如果没有更短，就不用继续遍历了，因为这条路径已经不是最短的了。</li></ul></li><li>类似于动态规划的思想，<code>minDistanceTo[next] = max(minDistanceTo[next], minDistanceTo[curr] + graph[curr][next])</code></li></ul><p>注：用优先级队列是因为贪心策略，优先选更短的路径来尝试遍历。普通队列也能完成。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;container/heap&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-comment">/* DIJKSTRA 算法 */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>, start <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>v := <span class="hljs-built_in">len</span>(graph)<br><br>minDistanceTo := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, v)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> minDistanceTo &#123;<br>minDistanceTo[i] = math.MaxInt<br>&#125;<br><br><span class="hljs-comment">// 起点到自己的距离是 0</span><br>minDistanceTo[start] = <span class="hljs-number">0</span><br><br>pq := PriorityQueue&#123;&#125;<br>heap.Push(&amp;pq, &amp;State&#123;start, <span class="hljs-number">0</span>&#125;)<br><br><span class="hljs-comment">// 开始 BFS</span><br><span class="hljs-keyword">for</span> pq.Len() != <span class="hljs-number">0</span> &#123;<br>currState := heap.Pop(&amp;pq).(*State)<br>currPos, currDist := currState.id, currState.distanceFromStart<br><br><span class="hljs-comment">// 已经有一条更短的到当前点的路径了</span><br><span class="hljs-keyword">if</span> currDist &gt; minDistanceTo[currPos] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 开始遍历相邻的点</span><br><span class="hljs-keyword">for</span> nextPos, weight := <span class="hljs-keyword">range</span> graph[currPos] &#123;<br><span class="hljs-comment">// 跳过不可达的点</span><br><span class="hljs-keyword">if</span> weight == <span class="hljs-number">-1</span> &#123;  <br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 到下一个点的距离等于自己的距离加上边的权重</span><br>distanceToNext := minDistanceTo[currPos] + weight<br><br><span class="hljs-comment">// 如果当前的路径更短，就更新最短路径，并继续将下一个点加入队列遍历</span><br><span class="hljs-keyword">if</span> minDistanceTo[nextPos] &gt; distanceToNext &#123;<br>minDistanceTo[nextPos] = distanceToNext<br>heap.Push(&amp;pq, &amp;State&#123;nextPos, distanceToNext&#125;)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> minDistanceTo<br>&#125;<br><br><span class="hljs-comment">/* 记录图节点的编号以及离起点的距离 */</span><br><br><span class="hljs-keyword">type</span> State <span class="hljs-keyword">struct</span> &#123;<br>id                <span class="hljs-keyword">int</span><br>distanceFromStart <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">/* 为 State 结构体定义的优先级队列，按 distanceFromStart 升序排序 */</span> <br><br><span class="hljs-keyword">type</span> PriorityQueue []*State<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(pq) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> pq[i].distanceFromStart &lt; pq[j].distanceFromStart<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>pq[i], pq[j] = pq[j], pq[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span> <span class="hljs-title">Push</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>item := x.(*State)<br>*pq = <span class="hljs-built_in">append</span>(*pq, item)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>old := *pq<br>n := <span class="hljs-built_in">len</span>(old)<br>item := old[n<span class="hljs-number">-1</span>]<br>old[n<span class="hljs-number">-1</span>] = <span class="hljs-literal">nil</span> <span class="hljs-comment">// avoid memory leak</span><br>*pq = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> item<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 Golang 中实现优先级队列比较麻烦，放一个用一个普通队列实现的，代码更加简洁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* DIJKSTRA 算法 */</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>, start <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>v := <span class="hljs-built_in">len</span>(graph)<br><br>minDistanceTo := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, v)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> minDistanceTo &#123;<br>minDistanceTo[i] = math.MaxInt<br>&#125;<br><br><span class="hljs-comment">// 起点到自己的距离是 0</span><br>minDistanceTo[start] = <span class="hljs-number">0</span><br><br>queue := <span class="hljs-built_in">make</span>([]State, <span class="hljs-number">0</span>)<br>    queue = <span class="hljs-built_in">append</span>(queue, State&#123;start, <span class="hljs-number">0</span>&#125;)<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>currState := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br><br>currPos, currDist := currState.id, currState.distanceFromStart<br><br><span class="hljs-comment">// 已经有一条更短的到当前点的路径了</span><br><span class="hljs-keyword">if</span> currDist &gt; minDistanceTo[currPos] &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 开始遍历相邻的点</span><br><span class="hljs-keyword">for</span> nextPos, weight := <span class="hljs-keyword">range</span> graph[currPos] &#123;<br><span class="hljs-comment">// 跳过不可达的点</span><br>            <span class="hljs-keyword">if</span> weight == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br><span class="hljs-comment">// 到下一个点的距离等于自己的距离加上边的权重</span><br>distanceToNext := minDistanceTo[currPos] + weight<br><br><span class="hljs-comment">// 如果当前的路径更短，就更新最短路径，并继续将下一个点加入队列遍历</span><br><span class="hljs-keyword">if</span> minDistanceTo[nextPos] &gt; distanceToNext &#123;<br>minDistanceTo[nextPos] = distanceToNext<br>queue = <span class="hljs-built_in">append</span>(queue, State&#123;nextPos, distanceToNext&#125;)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> minDistanceTo<br>&#125;<br><br><span class="hljs-keyword">type</span> State <span class="hljs-keyword">struct</span> &#123;<br>id                <span class="hljs-keyword">int</span><br>distanceFromStart <span class="hljs-keyword">int</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="网络延迟时间"><a href="#网络延迟时间" class="headerlink" title="网络延迟时间"></a>网络延迟时间</h2><p><a href="https://leetcode-cn.com/problems/network-delay-time/">https://leetcode-cn.com/problems/network-delay-time/</a></p><p>这道题就是求从起点开始，到每一个点的最短路径中最长的那条，就是最大的网络延迟时间。构造图之后直接套模板即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">networkDelayTime</span><span class="hljs-params">(times [][]<span class="hljs-keyword">int</span>, n <span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    graph := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> graph &#123;<br>        graph[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> graph[i] &#123;<br>            graph[i][j] = <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, time := <span class="hljs-keyword">range</span> times &#123;<br>        from, to, w := time[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>, time[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>, time[<span class="hljs-number">2</span>]<br>        graph[from][to] = w<br>    &#125;<br><br>    distTo := dijkstra(graph, k<span class="hljs-number">-1</span>)<br><br><span class="hljs-comment">// 寻找最长的最短路径</span><br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> distTo &#123;<br>        <span class="hljs-keyword">if</span> d == math.MaxInt &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> d &gt; res &#123;<br>            res = d<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>寻找名人</title>
    <link href="/leetcode/fucking-algorithm/find-the-celebrity/"/>
    <url>/leetcode/fucking-algorithm/find-the-celebrity/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找名人"><a href="#寻找名人" class="headerlink" title="寻找名人"></a>寻找名人</h1><p><a href="https://labuladong.gitee.io/algo/2/20/44/">https://labuladong.gitee.io/algo/2/20/44/</a></p><p>寻找名人问题：在 n 人中有一个人是名人，其他人都认识名人，而名人不认识任何人。题目提供了 <code>knows(a, b)</code> 这样一个函数来判断一个人是否认识另一个。</p><p>这个题有个有趣的性质：观察两人是否认识，至少可以排除一个人一定不是名人。设一个人为名人候选 <code>candidate</code>，另一个人记为 <code>other</code> 。两个人之间的关系只可能有 4 种：</p><ul><li><code>candidate</code> 认识 <code>other</code>：因为名人不认识其他人，所以 <code>candidate</code> 肯定不是名人，排除 <code>candidate</code>。</li><li><code>other</code> 认识 <code>candidate</code>：同理，排除 <code>other</code>。</li><li>两个人互相认识，则他俩都不是名人，因为名人不认识其他人。</li><li>两个人互不认识，则他俩也都不是名人，因为所有人都认识名人。</li></ul><p>开始时，将所有人放进队列，然后每次取出 2 个人观察他们的关系，根据上面的关系排除掉一个人（如果是两个人都不是名人的情况，随便排除一个，方便写代码），将另一人归回队列中，直到只剩下一个人。然后再遍历一次其他人来检查这个人是否是名人。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCelebrity</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br>queue := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, i)<br>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt;= <span class="hljs-number">2</span> &#123;<br>candidate := queue[<span class="hljs-number">0</span>]<br>other := queue[<span class="hljs-number">1</span>]<br>queue = queue[<span class="hljs-number">2</span>:]<br><br><span class="hljs-keyword">if</span> knows(candidate, other) || !knows(other, candidate) &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, other)  <span class="hljs-comment">// 排除 candidate</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>queue = <span class="hljs-built_in">append</span>(queue, candidate)  <span class="hljs-comment">// 排除 other</span><br>&#125;<br>&#125;<br><br>candidate := queue[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> other := <span class="hljs-number">0</span>; other &lt; n; other++ &#123;<br><span class="hljs-keyword">if</span> other == candidate &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> !knows(other, candidate) || knows(candidate, other) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> candidate<br>&#125;<br><br><span class="hljs-comment">// 模拟 leetcode API，此处名人是 2</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">knows</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>adjacentMatrix := [][]<span class="hljs-keyword">int</span>&#123;<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>&#125;<br><span class="hljs-keyword">return</span> adjacentMatrix[a][b] == <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以再简化，把队列去掉，每次只维护一个候选人变量即可，排除掉一个人时就让另一个成为候选。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KRUSKAL 最小生成树算法</title>
    <link href="/leetcode/fucking-algorithm/kruskal-algorithm/"/>
    <url>/leetcode/fucking-algorithm/kruskal-algorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="KRUSKAL-最小生成树算法"><a href="#KRUSKAL-最小生成树算法" class="headerlink" title="KRUSKAL 最小生成树算法"></a>KRUSKAL 最小生成树算法</h1><p><a href="https://labuladong.gitee.io/algo/2/20/42/">https://labuladong.gitee.io/algo/2/20/42/</a></p><p>最小生成树算法：在图中找一棵<strong>包含图中的所有节点</strong>的<strong>树</strong>（无环连通图），且使得边的权重最小。</p><p>KRUSKAL 最小生成树算法：</p><ol><li>将边按权重从小到大排序。</li><li>然后从最小权重的边开始，如果连通它的两个端点不会产生环（用并查集实现，如果它们已经是连通状态了，则连通它们会产生环），则这条边就是最小生成树的一部分；否则不使用这条边。</li><li>最终查看并查集的连通分量是否为 1 来判断是不是所有的节点都已被连通。</li></ol><h2 id="连接所有点的最小费用"><a href="#连接所有点的最小费用" class="headerlink" title="连接所有点的最小费用"></a>连接所有点的最小费用</h2><p><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">https://leetcode-cn.com/problems/min-cost-to-connect-all-points/</a></p><p>先构造出所有可能的边以及权重（曼哈顿距离），然后按权重排序后，直接利用并查集完成。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minCostConnectPoints</span><span class="hljs-params">(points [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(points)<br><br>    edges := <span class="hljs-built_in">make</span>([][<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dist := abs(points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>]) + abs(points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>])<br>            edges = <span class="hljs-built_in">append</span>(edges, [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;i, j, dist&#125;)<br>        &#125;<br>    &#125; <br>    <br>    sort.Slice(edges, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>        <span class="hljs-keyword">return</span> edges[i][<span class="hljs-number">2</span>] &lt; edges[j][<span class="hljs-number">2</span>]<br>    &#125;)<br><br>    cost := <span class="hljs-number">0</span><br>    uf := NewUF(n)<br><br>    <span class="hljs-keyword">for</span> _, edge := <span class="hljs-keyword">range</span> edges &#123;<br>        <span class="hljs-comment">// 如果两个端点没连通，就连接它们并加入最小生成树中</span><br>        <span class="hljs-keyword">if</span> !uf.Connected(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>]) &#123;<br>            uf.Union(edge[<span class="hljs-number">0</span>], edge[<span class="hljs-number">1</span>])<br>            cost += edge[<span class="hljs-number">2</span>]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cost<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -x<br>    &#125;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>对于一副节点个数为 <code>V</code>，边数为 <code>E</code> 的图：</p><p>空间复杂度：装载 <code>E</code> 条边和并查集装载的 <code>V</code> 个节点的空间复杂度为 <code>O(E + V)</code>。</p><p>时间复杂度：主要是对 <code>E</code> 条边排序的复杂度，为 <code>O(E * logE)</code>；并查集的合并和查找操作都是 <code>O(1)</code>，操作 <code>E</code> 次为 <code>O(E)</code>。总体复杂度为 <code>O(E * logE)</code>。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/leetcode/fucking-algorithm/union-find/"/>
    <url>/leetcode/fucking-algorithm/union-find/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集（union-find）"><a href="#并查集（union-find）" class="headerlink" title="并查集（union-find）"></a>并查集（union-find）</h1><p><a href="https://labuladong.gitee.io/algo/2/20/41/">https://labuladong.gitee.io/algo/2/20/41/</a></p><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>用一个类 UF 来实现并查集。初始化时，将每个节点的父节点设为自己。</p><p><code>union</code> 操作将 p 的根节点接到 q 的根节点下面。</p><p><code>find</code> 操作查找节点 x 的根节点，且在查找的路上将路径压缩，将 x 直接接到它的爷爷节点（父节点的父节点）下面，这样下来最终树的高度不会超过 3。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> UF <span class="hljs-keyword">struct</span> &#123;<br>count   <span class="hljs-keyword">int</span>    <span class="hljs-comment">// 连通分量数</span><br>parents []<span class="hljs-keyword">int</span>  <span class="hljs-comment">// 记录每个节点的父节点</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUF</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">UF</span></span> &#123;<br>parents := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>parents[i] = i<br>&#125;<br><span class="hljs-keyword">return</span> UF&#123;n, parents&#125;<br>&#125;<br><br><span class="hljs-comment">// Union 将节点 p 和 q 联通</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UF)</span> <span class="hljs-title">Union</span><span class="hljs-params">(p, q <span class="hljs-keyword">int</span>)</span></span> &#123;<br>rootP, rootQ := u.Find(p), u.Find(q)<br><span class="hljs-keyword">if</span> rootP == rootQ &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>u.parents[rootP] = rootQ<br>u.count -= <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// Find 查找节点 x 的根节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UF)</span> <span class="hljs-title">Find</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">for</span> u.parents[x] != x &#123;<br>u.parents[x] = u.parents[u.parents[x]] <span class="hljs-comment">// 路径压缩</span><br>x = u.parents[x]<br>&#125;<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">// Connected 判断两个节点是否连通</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UF)</span> <span class="hljs-title">Connected</span><span class="hljs-params">(p, q <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>rootP, rootQ := u.Find(p), u.Find(q)<br><span class="hljs-keyword">return</span> rootP == rootQ<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="被围绕的区域"><a href="#被围绕的区域" class="headerlink" title="被围绕的区域"></a>被围绕的区域</h2><p><a href="https://leetcode-cn.com/problems/surrounded-regions/">https://leetcode-cn.com/problems/surrounded-regions/</a></p><p>这个问题有个重要的性质：和 <strong>边界上的 0</strong> 连通的 0 不会被替换，而其他的 0 要被替换。</p><p>因此，利用并查集，我们将边界上的所有 0 和图一个 <code>dummy</code> 根节点相连，然后遍历棋盘内部，将所有的 0 来跟周围的 0 连接。最后判断一个 0 是否要被替换，就看它的根节点是否为 <code>dummy</code>，如果是就不用替换。</p><p>实现要点：</p><ol><li>为 <code>dummy</code> 根节点预留位置</li><li>将二维数组转为一维的技巧：<code>(x, y) =&gt; x*n + y</code> （n 为列数）</li><li>为了不破坏上面这个映射结构，<code>dummy</code> 的位置为数组最末尾</li><li>用 <code>directions</code> 数组技巧来遍历上下左右四个位置</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solve</span><span class="hljs-params">(board [][]<span class="hljs-keyword">byte</span>)</span></span>  &#123;<br>    m, n := <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br>    uf := NewUF(m * n + <span class="hljs-number">1</span>)<br><br>    dummy := m * n<br><br>    <span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; m; row++ &#123;<br>        <span class="hljs-keyword">if</span> board[row][<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>            uf.Union(row * n, dummy)<br>        &#125;<br>        <span class="hljs-keyword">if</span> board[row][n<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>            uf.Union(row * n + n - <span class="hljs-number">1</span>, dummy)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>        <span class="hljs-keyword">if</span> board[<span class="hljs-number">0</span>][col] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>            uf.Union(col, dummy)<br>        &#125;<br>        <span class="hljs-keyword">if</span> board[m<span class="hljs-number">-1</span>][col] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>            uf.Union((m<span class="hljs-number">-1</span>) * n + col, dummy)<br>        &#125;<br>    &#125;<br><br>    directions := [][]<span class="hljs-keyword">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;,<br>        &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;,<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m<span class="hljs-number">-1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n<span class="hljs-number">-1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>                <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> directions &#123;<br>                    x := i + d[<span class="hljs-number">0</span>]<br>                    y := j + d[<span class="hljs-number">1</span>]<br>                    <span class="hljs-keyword">if</span> board[x][y] == <span class="hljs-string">&#x27;O&#x27;</span> &#123;<br>                        uf.Union(i * n + j, x * n + y)<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m<span class="hljs-number">-1</span>; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n<span class="hljs-number">-1</span>; j++ &#123;<br>            <span class="hljs-keyword">if</span> !uf.Connected(dummy, i * n + j) &#123;<br>                board[i][j] = <span class="hljs-string">&#x27;X&#x27;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// UF 实现见上文</span><br></code></pre></td></tr></table></figure><p>注：这题更好的解法是遍历边界上的 0，用 DFS 或 BFS 将与它们连接的 0 替换成别的一个特殊字符 #，然后替换掉其他所有的 0，再将 # 替换回来。</p><h2 id="等式方程的可满足性"><a href="#等式方程的可满足性" class="headerlink" title="等式方程的可满足性"></a>等式方程的可满足性</h2><p><a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">https://leetcode-cn.com/problems/satisfiability-of-equality-equations/</a></p><p>用 <code>==</code> 连接的变量，就是互相连通的关系，可以自然地用并查集解决。具体来说，先处理 <code>==</code> 连接的变量，构造连通图，然后处理 <code>!=</code> 的变量，检查是否破坏了连通关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">equationsPossible</span><span class="hljs-params">(equations []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    uf := NewUF(<span class="hljs-number">26</span>)<br>    <span class="hljs-keyword">for</span> _, eq := <span class="hljs-keyword">range</span> equations &#123;<br>        <span class="hljs-keyword">if</span> eq[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;=&#x27;</span> &#123;<br>            uf.Union(<span class="hljs-keyword">int</span>(eq[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-keyword">int</span>(eq[<span class="hljs-number">3</span>] - <span class="hljs-string">&#x27;a&#x27;</span>))<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, eq := <span class="hljs-keyword">range</span> equations &#123;<br>        <span class="hljs-keyword">if</span> eq[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;!&#x27;</span> &#123;<br>            <span class="hljs-comment">// 检查是否违反了已有的连通关系</span><br>            <span class="hljs-keyword">if</span> uf.Connected(<span class="hljs-keyword">int</span>(eq[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;a&#x27;</span>), <span class="hljs-keyword">int</span>(eq[<span class="hljs-number">3</span>] - <span class="hljs-string">&#x27;a&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-comment">// UF 实现见上文</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分图</title>
    <link href="/leetcode/fucking-algorithm/bipartite-graph/"/>
    <url>/leetcode/fucking-algorithm/bipartite-graph/</url>
    
    <content type="html"><![CDATA[<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><p><a href="https://labuladong.gitee.io/algo/2/20/40/">https://labuladong.gitee.io/algo/2/20/40/</a></p><p>二分图定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 <strong>二分图</strong> 。</p><p>经典二分图问题：双色问题</p><blockquote><p>给你一幅图，请你用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同。</p></blockquote><p>这个问题等价于判断二分图。如果一个图是二分图，那他就可以用这种方式染色。</p><h2 id="判定二分图"><a href="#判定二分图" class="headerlink" title="判定二分图"></a>判定二分图</h2><p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/">https://leetcode-cn.com/problems/is-graph-bipartite/</a></p><p>利用双色问题的思想，遍历图尝试染色。如果发现相邻节点已被染色且颜色和自己相同，就说明不是二分图。</p><p>由于图不一定是联通的，可能存在多个子图，所以要对每一个节点都作为起点开始遍历。如果任意一个子图不是二分图，整幅图也不是二分图。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> validBipartite <span class="hljs-keyword">bool</span><br><br><span class="hljs-keyword">var</span> color   []<span class="hljs-keyword">bool</span><br><span class="hljs-keyword">var</span> visited []<span class="hljs-keyword">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    validBipartite = <span class="hljs-literal">true</span><br>    <br>    n := <span class="hljs-built_in">len</span>(graph)<br>    color = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, n)<br>    visited = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, n)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> !visited[i] &#123;<br>            traverse(graph, i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> validBipartite<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>, curr <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> !validBipartite &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    visited[curr] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[curr] &#123;<br>        <span class="hljs-keyword">if</span> !visited[next] &#123;<br>            color[next] = !color[curr]<br>            traverse(graph, next)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> color[next] == color[curr] &#123;<br>                validBipartite = <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>和 DFS 几乎是一样的，只是用队列来维护接下来访问的图节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> validBipartite <span class="hljs-keyword">bool</span><br><br><span class="hljs-keyword">var</span> color   []<span class="hljs-keyword">bool</span><br><span class="hljs-keyword">var</span> visited []<span class="hljs-keyword">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    validBipartite = <span class="hljs-literal">true</span><br><br>    n := <span class="hljs-built_in">len</span>(graph)<br>    color = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, n)<br>    visited = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, n)<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> !visited[i] &#123;<br>            traverse(graph, i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> validBipartite<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>, start <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    queue := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    queue = <span class="hljs-built_in">append</span>(queue, start)<br><br>    visited[start] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &amp;&amp; validBipartite &#123;<br>        curr := queue[<span class="hljs-number">0</span>]<br>        queue = queue[<span class="hljs-number">1</span>:]<br>        visited[curr] = <span class="hljs-literal">true</span><br><br>        <span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[curr] &#123;<br>            <span class="hljs-keyword">if</span> !visited[next] &#123;<br>                color[next] = !color[curr]<br>                queue = <span class="hljs-built_in">append</span>(queue, next)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> color[next] == color[curr] &#123;<br>                    validBipartite = <span class="hljs-literal">false</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可能的二分法"><a href="#可能的二分法" class="headerlink" title="可能的二分法"></a>可能的二分法</h2><p><a href="https://leetcode-cn.com/problems/possible-bipartition/">https://leetcode-cn.com/problems/possible-bipartition/</a></p><p>一样的道理，根据关系建图后，判断是否为二分图。要注意的是由于是无向图，建图的时候要同时将出入节点都加到邻接表里去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> validBipartite <span class="hljs-keyword">bool</span><br><br><span class="hljs-keyword">var</span> color   []<span class="hljs-keyword">bool</span><br><span class="hljs-keyword">var</span> visited []<span class="hljs-keyword">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">possibleBipartition</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>, dislikes [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    validBipartite = <span class="hljs-literal">true</span><br>    color = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, n)<br>    visited = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, n)<br><br>    graph := buildGrapth(n, dislikes)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> !visited[i] &#123;<br>            traverse(graph, i)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> validBipartite<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>, curr <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> !validBipartite &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    visited[curr] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[curr] &#123;<br>        <span class="hljs-keyword">if</span> !visited[next] &#123;<br>            color[next] = !color[curr]<br>            traverse(graph, next)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> color[next] == color[curr] &#123;<br>                validBipartite = <span class="hljs-literal">false</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildGrapth</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>, dislikes [][]<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    graph := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br><br>    <span class="hljs-keyword">for</span> _, dislike := <span class="hljs-keyword">range</span> dislikes &#123;<br>        from, to := dislike[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>, dislike[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span><br>        graph[from] = <span class="hljs-built_in">append</span>(graph[from], to)<br>        graph[to] = <span class="hljs-built_in">append</span>(graph[to], from)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> graph<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论基础</title>
    <link href="/leetcode/fucking-algorithm/graph-basis/"/>
    <url>/leetcode/fucking-algorithm/graph-basis/</url>
    
    <content type="html"><![CDATA[<h1 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h1><p><a href="https://labuladong.gitee.io/algo/2/20/38/">https://labuladong.gitee.io/algo/2/20/38/</a></p><p>图遍历框架：</p><p>需要在函数内将自己当前节点加入 <code>path</code>，否则根节点不会被记录。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs go">visited []<span class="hljs-keyword">bool</span><br>path    []<span class="hljs-keyword">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>, curr <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> visited[curr] &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    visited[curr] = <span class="hljs-literal">true</span><br><br>    path[curr] = <span class="hljs-literal">true</span>  <span class="hljs-comment">// 标记当前节点为路径</span><br>    <span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[curr] &#123;<br>        traverse(graph, next)<br>    &#125;<br>    path[curr] = <span class="hljs-literal">false</span> <span class="hljs-comment">// 退出节点后删除路径标记</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="所有可能的路径"><a href="#所有可能的路径" class="headerlink" title="所有可能的路径"></a>所有可能的路径</h2><p><a href="https://leetcode-cn.com/problems/all-paths-from-source-to-target/">https://leetcode-cn.com/problems/all-paths-from-source-to-target/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res [][]<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allPathsSourceTarget</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    res = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    traverse(graph, <span class="hljs-number">0</span>, []<span class="hljs-keyword">int</span>&#123;&#125;)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>, curr <span class="hljs-keyword">int</span>, path []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    path = <span class="hljs-built_in">append</span>(path, curr)<br><br>    <span class="hljs-keyword">if</span> curr == <span class="hljs-built_in">len</span>(graph) - <span class="hljs-number">1</span> &#123;<br>        r := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(path))<br>        <span class="hljs-built_in">copy</span>(r, path)<br>        res = <span class="hljs-built_in">append</span>(res, r)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[curr] &#123;<br>        traverse(graph, next, path)<br>    &#125;<br>    path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓扑排序</title>
    <link href="/leetcode/fucking-algorithm/topological-sort/"/>
    <url>/leetcode/fucking-algorithm/topological-sort/</url>
    
    <content type="html"><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p><a href="https://labuladong.gitee.io/algo/2/20/39/">https://labuladong.gitee.io/algo/2/20/39/</a></p><h2 id="课程表-I"><a href="#课程表-I" class="headerlink" title="课程表 I"></a>课程表 I</h2><p><a href="https://leetcode-cn.com/problems/course-schedule/">https://leetcode-cn.com/problems/course-schedule/</a></p><p>课和它的前置课程可以视为图的关系，如果出现有环图，则必不能完成课程。</p><p>注意，有的课可能也是没又前置课程的，也可能多个课依赖于一个前置课程，因此不能使用是否已经访问过 <code>visited[i]</code> 的值来判断是否走到了重复的环上，而应该在 <code>path[i]</code> 上判断当前路径上是否有环。</p><h3 id="DFS-遍历"><a href="#DFS-遍历" class="headerlink" title="DFS 遍历"></a>DFS 遍历</h3><p>用函数调用栈来完成 BFS。每访问一个图节点，就继续访问他它的邻接节点。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> visited []<span class="hljs-keyword">bool</span><br><span class="hljs-keyword">var</span> path    []<span class="hljs-keyword">bool</span><br><br><span class="hljs-keyword">var</span> hasCycle <span class="hljs-keyword">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    graph := buildGrapth(numCourses, prerequisites)<br><br>    visited = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, numCourses)<br>    path = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, numCourses)<br>    hasCycle = <span class="hljs-literal">false</span><br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br>        traverse(graph, i)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> !hasCycle<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>, curr <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> path[curr] &#123;<br>        hasCycle = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> visited[curr] || hasCycle &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    visited[curr] = <span class="hljs-literal">true</span><br>    <br>    path[curr] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[curr] &#123;<br>        traverse(graph, next)<br>    &#125;<br>    path[curr] = <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 构建图为邻接表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildGrapth</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    graph := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, numCourses)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> graph &#123;<br>        graph[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, dependency := <span class="hljs-keyword">range</span> prerequisites &#123;<br>        from, to := dependency[<span class="hljs-number">0</span>], dependency[<span class="hljs-number">1</span>]<br>        graph[from] = <span class="hljs-built_in">append</span>(graph[from], to)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> graph<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="BFS-遍历"><a href="#BFS-遍历" class="headerlink" title="BFS 遍历"></a>BFS 遍历</h3><p>BFS 判断图中有无环，需要借助每个节点的<strong>入度</strong>信息（指向这个节点的边的数目）。</p><p>流程：</p><ol><li>构建邻接表</li><li>构建 <code>indegree</code> 数组，记录每个节点的入度</li><li>初始化 BFS 队列，将入度为 0 的节点进队</li><li>执行 BFS 循环，不断弹出节点并将其邻接节点的入度 -1，将入度变为 0 的节点进队</li><li>如果所有节点都被遍历过，则说明不存在环</li></ol><p>当节点入度为 0 时，我们才去访问它的邻接节点。如果队列空了，而还有节点没访问完，说明这些节点的入度全不为 0，它们肯定存在环的关系。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    graph := buildGrapth(numCourses, prerequisites)<br><br>    <span class="hljs-comment">// 统计节点入度</span><br>    indegrees := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, numCourses)<br>    <span class="hljs-keyword">for</span> _, dependency := <span class="hljs-keyword">range</span> prerequisites &#123;<br>        indegrees[dependency[<span class="hljs-number">1</span>]] += <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 将入度为 0 的节点进队</span><br>    queue := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i, indegree := <span class="hljs-keyword">range</span> indegrees &#123;<br>        <span class="hljs-keyword">if</span> indegree == <span class="hljs-number">0</span> &#123;<br>            queue = <span class="hljs-built_in">append</span>(queue, i)<br>        &#125;<br>    &#125;<br><br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        sz := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; sz; i++ &#123;<br>            curr := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br><br>            count += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment">// 相邻节点入度 -1，如果为 0 了就进队</span><br>            <span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[curr] &#123;<br>                indegrees[next] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> indegrees[next] == <span class="hljs-number">0</span> &#123;<br>                    queue = <span class="hljs-built_in">append</span>(queue, next)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果不是所有节点已被访问，则说明有环</span><br>    <span class="hljs-keyword">return</span> count == numCourses<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildGrapth</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    graph := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, numCourses)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> graph &#123;<br>        graph[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, dependency := <span class="hljs-keyword">range</span> prerequisites &#123;<br>        from, to := dependency[<span class="hljs-number">0</span>], dependency[<span class="hljs-number">1</span>]<br>        graph[from] = <span class="hljs-built_in">append</span>(graph[from], to)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> graph<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="课程表-II"><a href="#课程表-II" class="headerlink" title="课程表 II"></a>课程表 II</h2><p><a href="https://leetcode-cn.com/problems/course-schedule-ii/">https://leetcode-cn.com/problems/course-schedule-ii/</a></p><p>与上一题的区别是，此题不仅要判断能否完成，还需要找出正确的完成顺序。</p><h3 id="拓扑排序-1"><a href="#拓扑排序-1" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>简单来说，拓扑排序就是将图的节点拉成一条直线，且所有箭头的方向都是一致的。</p><p>如果一幅图有环，则无法进行拓扑排序，否则一定可以进行拓扑排序。</p><p>完成拓扑排序，只需要在图节点的后序遍历位置加入自己即可，视建图方式来判断要不要将这个列表反转。</p><p>本题中，邻接表 <code>graph[i][j]</code> 定义为要选修 <code>i</code>，需要<strong>先</strong>修 <code>j</code>，因此按照后序遍历，子节点会在列表前面，即前置课程在前面，是正确的顺序。代码与上体几乎一样，先判断有无环，如果没有就输出拓扑顺序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> visited []<span class="hljs-keyword">bool</span><br><span class="hljs-keyword">var</span> path    []<span class="hljs-keyword">bool</span><br><br><span class="hljs-keyword">var</span> hasCycle <span class="hljs-keyword">bool</span><br><br><span class="hljs-keyword">var</span> postOrder []<span class="hljs-keyword">int</span>  <span class="hljs-comment">// 【新增】用后序遍历来完成拓扑排序</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findOrder</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    visited = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, numCourses)<br>    path = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, numCourses)<br>    hasCycle = <span class="hljs-literal">false</span><br><br>    postOrder = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br><br>    graph := buildGrapth(numCourses, prerequisites)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numCourses; i++ &#123;<br>        traverse(graph, i)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> hasCycle &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;&#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> postOrder<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(graph [][]<span class="hljs-keyword">int</span>, curr <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> path[curr] &#123;<br>        hasCycle = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> visited[curr] || hasCycle &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    visited[curr] = <span class="hljs-literal">true</span><br>    <br>    path[curr] = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[curr] &#123;<br>        traverse(graph, next)<br>    &#125;<br>    postOrder = <span class="hljs-built_in">append</span>(postOrder, curr)  <span class="hljs-comment">// 【新增】在后序位置添加节点</span><br>    path[curr] = <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildGrapth</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    graph := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, numCourses)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> graph &#123;<br>        graph[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, dependency := <span class="hljs-keyword">range</span> prerequisites &#123;<br>        from, to := dependency[<span class="hljs-number">0</span>], dependency[<span class="hljs-number">1</span>]<br>        graph[from] = <span class="hljs-built_in">append</span>(graph[from], to)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> graph<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓扑排序-BFS-版本"><a href="#拓扑排序-BFS-版本" class="headerlink" title="拓扑排序 BFS 版本"></a>拓扑排序 BFS 版本</h3><p>容易看出，BFS 判断有无环的算法，直接输出拓扑排序的结果。由于图定义的关系，这里需要反转一下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findOrder</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    graph := buildGrapth(numCourses, prerequisites)<br><br>    result := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)  <span class="hljs-comment">// 【新增】记录 BFS 访问顺序</span><br><br>    <span class="hljs-comment">// 统计节点入度</span><br>    indegrees := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, numCourses)<br>    <span class="hljs-keyword">for</span> _, dependency := <span class="hljs-keyword">range</span> prerequisites &#123;<br>        indegrees[dependency[<span class="hljs-number">1</span>]] += <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 将入度为 0 的节点进队</span><br>    queue := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i, indegree := <span class="hljs-keyword">range</span> indegrees &#123;<br>        <span class="hljs-keyword">if</span> indegree == <span class="hljs-number">0</span> &#123;<br>            queue = <span class="hljs-built_in">append</span>(queue, i)<br>        &#125;<br>    &#125;<br><br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        sz := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; sz; i++ &#123;<br>            curr := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br><br>            count += <span class="hljs-number">1</span><br>            result = <span class="hljs-built_in">append</span>(result, curr)<br><br>            <span class="hljs-comment">// 相邻节点入度 -1，如果为 0 了就进队</span><br>            <span class="hljs-keyword">for</span> _, next := <span class="hljs-keyword">range</span> graph[curr] &#123;<br>                indegrees[next] -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> indegrees[next] == <span class="hljs-number">0</span> &#123;<br>                    queue = <span class="hljs-built_in">append</span>(queue, next)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> count != numCourses &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;&#125;<br>    &#125;<br>    reverse(result)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildGrapth</span><span class="hljs-params">(numCourses <span class="hljs-keyword">int</span>, prerequisites [][]<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    graph := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, numCourses)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> graph &#123;<br>        graph[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, dependency := <span class="hljs-keyword">range</span> prerequisites &#123;<br>        from, to := dependency[<span class="hljs-number">0</span>], dependency[<span class="hljs-number">1</span>]<br>        graph[from] = <span class="hljs-built_in">append</span>(graph[from], to)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> graph<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++ &#123;<br>        nums[i], nums[n<span class="hljs-number">-1</span>-i] = nums[n<span class="hljs-number">-1</span>-i], nums[i]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>图</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分治法</title>
    <link href="/leetcode/fucking-algorithm/divide-and-conquer/"/>
    <url>/leetcode/fucking-algorithm/divide-and-conquer/</url>
    
    <content type="html"><![CDATA[<h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><p><a href="https://labuladong.gitee.io/algo/4/32/127/">https://labuladong.gitee.io/algo/4/32/127/</a></p><h2 id="为运算表达式设计优先级"><a href="#为运算表达式设计优先级" class="headerlink" title="为运算表达式设计优先级"></a>为运算表达式设计优先级</h2><p><a href="https://leetcode-cn.com/problems/different-ways-to-add-parentheses/">https://leetcode-cn.com/problems/different-ways-to-add-parentheses/</a></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diffWaysToCompute</span><span class="hljs-params">(expression <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment">// 遍历字符串，如果是运算符就【分】</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(expression); i++ &#123;<br>        c := expression[i]<br>        <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;+&#x27;</span> || c == <span class="hljs-string">&#x27;-&#x27;</span> || c == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>            <span class="hljs-comment">// 【分】成左右两边计算可能出现的结果</span><br>            left := diffWaysToCompute(expression[:i])<br>            right := diffWaysToCompute(expression[i+<span class="hljs-number">1</span>:])<br><br>            <span class="hljs-comment">// 【治】根据返回的结果，暴力计算出所有可能的值</span><br>            <span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> left &#123;<br>                <span class="hljs-keyword">for</span> _, b := <span class="hljs-keyword">range</span> right &#123;<br>                    <span class="hljs-keyword">switch</span> c &#123;<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                            res = <span class="hljs-built_in">append</span>(res, a + b)<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                            res = <span class="hljs-built_in">append</span>(res, a - b)<br>                        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br>                            res = <span class="hljs-built_in">append</span>(res, a * b)<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// base case: expression 不包含运算符，它只是一个数字</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) == <span class="hljs-number">0</span> &#123;<br>        n, _ := strconv.Atoi(expression)<br>        res = <span class="hljs-built_in">append</span>(res, n)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>分治法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>目标和</title>
    <link href="/leetcode/fucking-algorithm/target-sum/"/>
    <url>/leetcode/fucking-algorithm/target-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h1><p><a href="https://leetcode-cn.com/problems/target-sum/">https://leetcode-cn.com/problems/target-sum/</a></p><p><a href="https://labuladong.gitee.io/algo/3/24/75/">https://labuladong.gitee.io/algo/3/24/75/</a></p><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><p>很容易想到最简单的回溯法，就是在每一个位置决定是加法还是减法。</p><p>其中变量 <code>track</code> 表示当前回溯路径（当前已经积累的和）。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res = <span class="hljs-number">0</span><br>    backtrack(nums, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, target)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, i, track, target <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> i == n &#123;<br>        <span class="hljs-keyword">if</span> track == target &#123;<br>            res++<br>        &#125;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    backtrack(nums, i + <span class="hljs-number">1</span>, track - nums[i], target)<br>    backtrack(nums, i + <span class="hljs-number">1</span>, track + nums[i], target)<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="备忘录优化"><a href="#备忘录优化" class="headerlink" title="备忘录优化"></a>备忘录优化</h2><p>简单回溯，是具有重复子问题的。是否存在重复子问题，要关注递归函数中会变的参数 <code>i</code> 和 <code>track</code>。看这一段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">backtrack(nums, i + <span class="hljs-number">1</span>, track - nums[i], target)<br>backtrack(nums, i + <span class="hljs-number">1</span>, track + nums[i], target)<br></code></pre></td></tr></table></figure><p>当 <code>nums[i]</code> 为 0 时，显然是两个重复的函数调用。因此用备忘录记录会变的参数对 <code>i, track</code>，速度明显提升。</p><p>如果使用备忘录，需要让函数返回一个值。这里当回溯到终点且达到目标是，返回一个 1，表面这是一种可行的解法，否则返回 0。递归时将子问题加起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> memo <span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">return</span> backtrack(nums, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, target)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, i, track, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    <span class="hljs-keyword">if</span> i == n &#123;<br>        <span class="hljs-keyword">if</span> track == target &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, track&#125;]; ok &#123;<br>        <span class="hljs-keyword">return</span> v<br>    &#125;<br><br>    res := backtrack(nums, i + <span class="hljs-number">1</span>, track - nums[i], target) + backtrack(nums, i + <span class="hljs-number">1</span>, track + nums[i], target)<br>    memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, track&#125;] = res<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>此问题可以转换成背包问题，类似 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">分割等和子集</a>，然后用动态规划来解决。</p><p>首先，如果我们把 <code>nums</code> 划分成两个子集 A 和 B，分别代表分配 + 的数和分配 - 的数，那么他们和 target 存在如下关系：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">sum</span>(A) - <span class="hljs-built_in">sum</span>(B) = target<br>=&gt;  <span class="hljs-built_in">sum</span>(A) = target + <span class="hljs-built_in">sum</span>(B)<br>=&gt;  <span class="hljs-built_in">sum</span>(A) + <span class="hljs-built_in">sum</span>(A) = target + <span class="hljs-built_in">sum</span>(B) + <span class="hljs-built_in">sum</span>(A)<br>=&gt;  <span class="hljs-number">2</span> * <span class="hljs-built_in">sum</span>(A) = target + <span class="hljs-built_in">sum</span>(nums)<br>=&gt;  <span class="hljs-built_in">sum</span>(A) = (target + <span class="hljs-built_in">sum</span>(nums)) / <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>即：需要在 <code>nums</code> 中找到一个子集 A ，使得它的和为 <code>(target + sum(nums)) / 2</code>。需要求一共有多少个这样的子集。</p><p>定义 <code>dp[i][j]</code> 为前 i 个物品，当前背包容量为 j，有 <code>dp[i][j]</code> 种凑法使得子集的和为 <code>(target + sum(nums)) / 2</code>。</p><p>base case： <code>dp[0][0]</code> 为 1，因为当只有 0 个物品且背包容量为 0，什么都不干就是一个这样的子集。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += n<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> sum &lt; abs(target) || (target + sum) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    vol := (target + sum) / <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">return</span> subsets(nums, vol)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, target+<span class="hljs-number">1</span>)<br>    &#125;<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt;= target; j++ &#123;<br>            <span class="hljs-keyword">if</span> j - nums[i<span class="hljs-number">-1</span>] &gt;= <span class="hljs-number">0</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i<span class="hljs-number">-1</span>][j-nums[i<span class="hljs-number">-1</span>]]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][target]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> -a<br>    &#125;<br>    <span class="hljs-keyword">return</span> a<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>回溯法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美团笔试题（3.5） 编程题 2. 反转数组一段区间后最大子数组和</title>
    <link href="/leetcode/programming-exam/max-subarray-after-reversing-interval/"/>
    <url>/leetcode/programming-exam/max-subarray-after-reversing-interval/</url>
    
    <content type="html"><![CDATA[<h1 id="美团笔试题（3-5）-编程题-2-反转数组一段区间后最大子数组和"><a href="#美团笔试题（3-5）-编程题-2-反转数组一段区间后最大子数组和" class="headerlink" title="美团笔试题（3.5） 编程题 2. 反转数组一段区间后最大子数组和"></a>美团笔试题（3.5） 编程题 2. 反转数组一段区间后最大子数组和</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一个数组，可以任意反转数组的一段区间（也可以不反转），求最大子数组和。例：</p><p>输入：</p><figure class="highlight subunit"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-string">-1</span>, 3, <span class="hljs-string">-5</span>, 2, <span class="hljs-string">-1</span>, 3<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><p>解释：反转以元素 -5, 3 作为端点的区间，得到 <code>-1, 3, 3, -1, 2, -5</code>，最大子数组和为 7。 </p><h2 id="解法：动态规划"><a href="#解法：动态规划" class="headerlink" title="解法：动态规划"></a>解法：动态规划</h2><p><strong>核心思想：如果反转了某段区间 <code>[i..j]</code> 能够得到一个和最大的子数组，那这个操作实际上使得 <code>[i..j]</code> 中最大子数组跟 <code>[0..i]</code> 中（或者是 <code>[j..n]</code> 中）最大子数组拼了起来，形成了一个更大的子数组。</strong></p><p>以输入示例为例，反转 -5 到 3 之间的元素得到的最大子数组，实际上是由 <code>[3]</code> 跟 <code>[2, -1, 3]</code> 这两个小一点的子数组拼接而成，但是它们由于有个 -5 隔在中间导致不能连续。进行反转操作后，-5 就到最后去了，因此形成了更大的连续子数组。</p><p>更一般地说，考虑一个切分点 i ，以切分点为界的数组两边各有一个最大子数组。遍历所有可能的 i ，求这两个子数组的和的<strong>最大值</strong>即可。以输入示例为例，-5 就是这个切分点，至于具体反转哪一段区间则不需要关心，只要知道反转操作一定能使两个子数组变成连续的。</p><p>于是可以用动态规划求从左到 i 的最大子数组，以及从右到 i 的最大子数组，最后遍历所有的 i 找到一个最大值即可。</p><p>注意这里的 DP 数组定义， <code>maxSum_left2i[i]</code> 表示从 0 到 i 这一段区间的最大子数组和（不一定要以 i 结尾） ，详见 <a href="https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/">Kadane’s Algorithm</a>。（如果 <code>dp[i]</code> 表示以 i 结尾的最大子数组和，则为了找出 <code>[0..i]</code> 中最大的值，还要再遍历一遍）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arr := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>&#125;<br>n := <span class="hljs-built_in">len</span>(arr)<br><br><span class="hljs-comment">// 动态规划求 0 到 i 的最大子数组和</span><br>maxSum_left2i := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br><span class="hljs-keyword">if</span> arr[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> &#123;  <span class="hljs-comment">// DP base case</span><br>maxSum_left2i[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>]<br>&#125;<br><span class="hljs-keyword">for</span> i, maxSumEndWith_i := <span class="hljs-number">1</span>, <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>maxSumEndWith_i += arr[i]<br><span class="hljs-keyword">if</span> maxSumEndWith_i &lt; <span class="hljs-number">0</span> &#123;<br>maxSumEndWith_i = <span class="hljs-number">0</span><br>&#125;<br><br>maxSum_left2i[i] = max(maxSum_left2i[i<span class="hljs-number">-1</span>], maxSumEndWith_i)<br>&#125;<br><br><span class="hljs-comment">// 动态规划求 n-1 到 i 的最大子数组和</span><br>maxSum_i2right := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br><span class="hljs-keyword">if</span> arr[n<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> &#123;  <span class="hljs-comment">// DP base case</span><br>maxSum_i2right[n<span class="hljs-number">-1</span>] = arr[n<span class="hljs-number">-1</span>]<br>&#125;<br><span class="hljs-keyword">for</span> i, maxSumEndWith_i := n<span class="hljs-number">-2</span>, <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>maxSumEndWith_i += arr[i]<br><span class="hljs-keyword">if</span> maxSumEndWith_i &lt; <span class="hljs-number">0</span> &#123;<br>maxSumEndWith_i = <span class="hljs-number">0</span><br>&#125;<br><br>maxSum_i2right[i] = max(maxSum_i2right[i+<span class="hljs-number">1</span>], maxSumEndWith_i)<br>&#125;<br><br><span class="hljs-comment">// 遍历所有可能的 i 找出最大值</span><br>res := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>res = max(res, maxSum_left2i[i] + maxSum_i2right[i])<br>&#125;<br><br>fmt.Println(res)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>res := values[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br><span class="hljs-keyword">if</span> v &gt; res &#123;<br>res = v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>笔试编程题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里笔试题（3.14） 编程题 2. 探照灯</title>
    <link href="/leetcode/programming-exam/light-score/"/>
    <url>/leetcode/programming-exam/light-score/</url>
    
    <content type="html"><![CDATA[<h1 id="阿里笔试题（3-14）-编程题-2-探照灯"><a href="#阿里笔试题（3-14）-编程题-2-探照灯" class="headerlink" title="阿里笔试题（3.14） 编程题 2. 探照灯"></a>阿里笔试题（3.14） 编程题 2. 探照灯</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二维数组，元素只有 0 和 1 两种，0 代表探照灯，1 代表人。探照灯朝着 4 个方向照，照到一个人就能得一分（距离无限远），但是人会挡住光线。求这个二维数组的分数。</p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>按人统计 4 个方向上的灯数量，复杂度 O(n^3)。（有一半会超时）</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>分别考虑 4 个照射方向。以从左向右照为例，从最左边开始，统计有几盏灯在朝着右边照，遇到人就将这几盏灯作为得分加进结果中，并清空灯的计数。为每一行重复此操作即可。4 次二维数组遍历，渐进复杂度为 O(n^2)。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>matrix := [][]<span class="hljs-keyword">int</span>&#123;<br>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>&#125;<br><br>m, n := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>totalScore := <span class="hljs-number">0</span><br><br><span class="hljs-comment">// 从左往右照的得分</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>score := <span class="hljs-number">0</span><br>lightCount := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br><span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span> &#123;<br>lightCount++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>score += lightCount<br>lightCount = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>totalScore += score<br>&#125;<br><br><span class="hljs-comment">// 从右往左照</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br>score := <span class="hljs-number">0</span><br>lightCount := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> j := n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br><span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span> &#123;<br>lightCount++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>score += lightCount<br>lightCount = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>totalScore += score<br>&#125;<br><br><span class="hljs-comment">// 从上往下照</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>score := <span class="hljs-number">0</span><br>lightCount := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; m; i++ &#123;<br><span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span> &#123;<br>lightCount++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>score += lightCount<br>lightCount = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>totalScore += score<br>&#125;<br><br><span class="hljs-comment">// 从下往上照</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>score := <span class="hljs-number">0</span><br>lightCount := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> matrix[i][j] == <span class="hljs-number">0</span> &#123;<br>lightCount++<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>score += lightCount<br>lightCount = <span class="hljs-number">0</span><br>&#125;<br>&#125;<br>totalScore += score<br>&#125;<br><br>fmt.Println(totalScore)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>笔试编程题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 63. 股票的最大利润</title>
    <link href="/leetcode/jian-zhi-offer/63/"/>
    <url>/leetcode/jian-zhi-offer/63/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-63-股票的最大利润"><a href="#剑指-Offer-63-股票的最大利润" class="headerlink" title="剑指 Offer 63. 股票的最大利润"></a>剑指 Offer 63. 股票的最大利润</h1><p><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/</a></p><p>类似与 <a href="https://blog.gentlecomet.com/leetcode/fucking-algorithm/maximum-subarray/">最大子数组和</a>，不需要关心买入状态。由于只能买卖一次，只需要知道当前第 n 天，是今天卖出利润高，或是前 n - 1 天的利润高。如果是今天卖出，就要知道前 n - 1 天中的最小价格，用一个变量记录即可。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(prices []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(prices)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    pastMax := <span class="hljs-number">0</span><br>    min := prices[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        pastMax = max(pastMax, prices[i] - min)<br>        <span class="hljs-keyword">if</span> prices[i] &lt; min &#123;<br>            min = prices[i]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> pastMax<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 62. 圆圈中最后剩下的数字</title>
    <link href="/leetcode/jian-zhi-offer/62/"/>
    <url>/leetcode/jian-zhi-offer/62/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-62-圆圈中最后剩下的数字"><a href="#剑指-Offer-62-圆圈中最后剩下的数字" class="headerlink" title="剑指 Offer 62. 圆圈中最后剩下的数字"></a>剑指 Offer 62. 圆圈中最后剩下的数字</h1><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/</a></p><p>此问题称作 <strong>约瑟夫环</strong> 问题。</p><p>参考题解：<a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/</a></p><p>递推公式定义：</p><p><code>f(n, m)</code> 表示环长度为 <code>n</code>，每次杀掉第 <code>m</code> 人，<strong>最后生下来的人</strong> 在 <strong>当前序列</strong> 中的 index。由于这个人是活到最后的，所以他在任何子问题 <code>f(n-i, m)</code> 中都是活着的，只不过可能因为其他人被杀掉所以他 index 变了，且在 <code>f(0, m)</code> 中他的序号是 0（唯一活着的人）。</p><p>问题就是怎么找出他在不同序列中序号的变化。看图：</p><p><img src="https://s2.loli.net/2022/03/16/n6esXPzqUHgoDhv.png"></p><p>观察 N &#x3D; 8 和 N &#x3D; 7 的变化，N &#x3D; 8 时，这个人的序号是 6，而 N &#x3D; 7 时变成了 3。</p><p>首先考虑怎么将 N &#x3D; 7 时的序列复原回 N &#x3D; 8 时的样子。观察发现，将被杀掉 C 加回末尾，然后令数组顺时针旋转 3 格，就得到了原来的序列。如何表示这个变化呢？看图：</p><p><img src="https://s2.loli.net/2022/03/16/Wwk5czPgnSa9LtF.png"></p><p>至此，递归公式已被找出，可以直接从 0 开始推起。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lastRemaining</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>, m <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    pos := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>        pos = (pos + m) % i<br>    &#125;<br>    <span class="hljs-keyword">return</span> pos<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 60. n个骰子的点数</title>
    <link href="/leetcode/jian-zhi-offer/60/"/>
    <url>/leetcode/jian-zhi-offer/60/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a>剑指 Offer 60. n个骰子的点数</h1><p><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/">https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/</a></p><p>动态规划：由于每个骰子是独立的，且扔第 N 个骰子得到的点数和与 N-1 个有关，可以考虑用动态规划完成。</p><blockquote><p>假设已知 <code>n - 1</code> 个骰子的解 <code>f(n - 1)</code>，此时添加一枚骰子，求 <code>n</code> 个骰子的点数和为 <code>x</code> 的概率 <code>f(n, x)</code>。</p></blockquote><p>当添加的第 <code>n</code> 个骰子点数为 1，为了凑成 <code>x</code>，前面 <code>n - 1</code> 个的点数和就要是 <code>x - 1</code>。同理，当此骰子为 2 时，前 <code>n - 1</code> 个骰子应为 <code>x - 2 </code>。</p><p>因此，第 <code>n</code> 个骰子点数和就是第投出它本身的点数的概率（都是 1&#x2F;6）乘以第 <code>n - 1</code> 个骰子的概率。即：</p><p>$ f(n, x) &#x3D; ∑_i^6 1&#x2F;6 * f(n - 1, x - i) $</p><p>得到递推公式即可写出 DP，从底向上构建比较方便。遍历每个 <code>f(n - 1, j)</code>，统计它对 <code>f(n, j + i)</code>（i&#x3D;1..6）的贡献。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dicesProbability</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">float64</span></span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">float64</span>, <span class="hljs-number">6</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-number">1.0</span> / <span class="hljs-number">6</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt;= n; i++ &#123;<br>        tmp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">float64</span>, <span class="hljs-number">5</span>*i+<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> dp &#123;<br>            <span class="hljs-keyword">for</span> k := <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">6</span>; k++ &#123;<br>                tmp[j+k] += dp[j] / <span class="hljs-number">6</span><br>            &#125;<br>        &#125;<br>        dp = tmp<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp<br>&#125;<br></code></pre></td></tr></table></figure><p>由于数组是有偏移量的，所以 k 的索引是从 0 开始的。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 59 - II. 滑动窗口的最大值</title>
    <link href="/leetcode/jian-zhi-offer/59ii/"/>
    <url>/leetcode/jian-zhi-offer/59ii/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-59-II-队列的最大值"><a href="#剑指-Offer-59-II-队列的最大值" class="headerlink" title="剑指 Offer 59 - II. 队列的最大值"></a>剑指 Offer 59 - II. 队列的最大值</h1><p><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/</a></p><p>类似与最小栈，首先为了实现队列的功能要维护一个普通的队列，而在最大元素出队时需要知道第二大的元素，因此还需要维护一个 <strong>非严格递减</strong> 的单调队列。</p><p>如果进来了一个较大的元素，由于先进队的元素会先出队，则前面所有比它小的元素都不可能是最大值，可以直接将它们删除而不影响结果。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MaxQueue <span class="hljs-keyword">struct</span> &#123;<br>    queue []<span class="hljs-keyword">int</span><br>    descQ []<span class="hljs-keyword">int</span>  <span class="hljs-comment">// 非严格递减队列</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">MaxQueue</span></span> &#123;<br>    <span class="hljs-keyword">return</span> MaxQueue&#123;<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MaxQueue)</span> <span class="hljs-title">Max_value</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(this.descQ)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> this.descQ[<span class="hljs-number">0</span>]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MaxQueue)</span> <span class="hljs-title">Push_back</span><span class="hljs-params">(value <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    this.queue = <span class="hljs-built_in">append</span>(this.queue, value)<br><br>    <span class="hljs-comment">// 将单调队列中比新值大的元素都踢出</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.descQ) &gt; <span class="hljs-number">0</span> &amp;&amp; this.descQ[<span class="hljs-built_in">len</span>(this.descQ)<span class="hljs-number">-1</span>] &lt; value &#123;<br>            this.descQ = this.descQ[:<span class="hljs-built_in">len</span>(this.descQ)<span class="hljs-number">-1</span>]<br>    &#125;<br>    this.descQ = <span class="hljs-built_in">append</span>(this.descQ, value)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MaxQueue)</span> <span class="hljs-title">Pop_front</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.queue) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br><br>    res := this.queue[<span class="hljs-number">0</span>]<br>    this.queue = this.queue[<span class="hljs-number">1</span>:]<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.descQ) &gt; <span class="hljs-number">0</span> &amp;&amp; res == this.descQ[<span class="hljs-number">0</span>] &#123;<br>        this.descQ = this.descQ[<span class="hljs-number">1</span>:]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
    <link href="/leetcode/jian-zhi-offer/59i/"/>
    <url>/leetcode/jian-zhi-offer/59i/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-59-I-滑动窗口的最大值"><a href="#剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="剑指 Offer 59 - I. 滑动窗口的最大值"></a>剑指 Offer 59 - I. 滑动窗口的最大值</h1><p><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/</a></p><p>维护一个与单调栈类似的单调队列，队列的元素是 <strong>非严格递减</strong> 的，这样队头的元素是最大的。</p><p>队列需要仅包含滑动窗口的元素，滑动窗口移除的元素 <code>nums[i]</code>，队列也要相应移除。</p><p>为了保持 <strong>非严格递减</strong> 的性质，在一个元素 <code>nums[j]</code> 进队之前，需要把比它小的都先删除（因为这些元素都要比它小，而且会比它先出退出滑动窗口，因此必定不会是某段窗口的最大值，可以直接移除）</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;&#125;<br>    &#125;<br><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums) - k + <span class="hljs-number">1</span>)<br>    queue := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-comment">// 初始化滑动窗口的右边界 j 为 0，此时窗口还未形成。当 i &gt; 0 时才形成窗口。</span><br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">1</span>-k, <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(nums); i, j = i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span> &#123;<br>        <span class="hljs-comment">// 如果退出滑动窗的元素在队列中存在，将它移除</span><br>        <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &amp;&amp; queue[<span class="hljs-number">0</span>] == nums[i<span class="hljs-number">-1</span>] &#123;<br>            queue = queue[<span class="hljs-number">1</span>:]<br>        &#125;<br><br>        <span class="hljs-comment">// 移除比新进元素小的元素</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &amp;&amp; queue[<span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>]  &lt; nums[j] &#123;<br>            queue = queue[:<span class="hljs-built_in">len</span>(queue)<span class="hljs-number">-1</span>]<br>        &#125;<br>        <br>        <span class="hljs-comment">// 新元素入队</span><br>        queue = <span class="hljs-built_in">append</span>(queue, nums[j])<br>        <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 队首元素为窗口内最大值</span><br>            res[i] = queue[<span class="hljs-number">0</span>]<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 56. 数组中数字出现的次数</title>
    <link href="/leetcode/jian-zhi-offer/56/"/>
    <url>/leetcode/jian-zhi-offer/56/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-56-数组中数字出现的次数"><a href="#剑指-Offer-56-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56. 数组中数字出现的次数"></a>剑指 Offer 56. 数组中数字出现的次数</h1><h2 id="剑指-Offer-56-I-数组中数字出现的次数"><a href="#剑指-Offer-56-I-数组中数字出现的次数" class="headerlink" title="剑指 Offer 56 - I. 数组中数字出现的次数"></a>剑指 Offer 56 - I. 数组中数字出现的次数</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/</a></p><p>用异或运算可以找出 1 个只出现一次的数字。而如果这样的数字有 2 个，异或运算的结果就是它们俩异或的结果。</p><p>根据他们俩异或的结果，从右开始找到第一位不相同的数字，用这一位数字为 0 或 1 就能将整个数组分成两半，同时这两个只出现了一次的数也被分开了。</p><p>再次循环判断数组，这一位为 1 的组成一组异或，为 0 的组成另一组异或，得到的结果就是这两个只出现了一次的数。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNumbers</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    res, index := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nums &#123;<br>        res ^= n<br>    &#125;<br><br>    <span class="hljs-comment">//  检查这两个只出现一次的数从哪一位开始不同</span><br>    <span class="hljs-keyword">for</span> res &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span> &#123;<br>        index ++<br>        res &gt;&gt;= <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 用这不同的一位分割数组，从而分开两个只出现一次的数</span><br>    r1, r2 := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> n &gt;&gt; index &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span> &#123;<br>            r1 ^= n<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r2 ^= n<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;r1, r2&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剑指-Offer-56-II-数组中数字出现的次数-II"><a href="#剑指-Offer-56-II-数组中数字出现的次数-II" class="headerlink" title="剑指 Offer 56 - II. 数组中数字出现的次数 II"></a>剑指 Offer 56 - II. 数组中数字出现的次数 II</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/</a></p><p>如果一个数字出现 3 次，它的二进制每一位也出现的 3 次。</p><p>如果把所有的出现 3 次的数字的二进制表示的每一位都分别加起来，那么每一位都能被 3 整除。 </p><p>我们把数组中所有的数字的二进制表示的<strong>每一位都分别加起来</strong>。</p><ul><li>如果某一位能被 3 整除，那么这一位对只出现一次的那个数的这一肯定为 0。</li><li>如果某一位不能被3整除，那么只出现一次的那个数字的该位置一定为 1。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    digitsSum := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">32</span>) <span class="hljs-comment">// 题目限制最多 32 位</span><br><br>    <span class="hljs-comment">// 统计每一位的出现次数</span><br>    <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> digitsSum &#123;<br>            digitsSum[j] += (n &gt;&gt; j) &amp; <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 每一位的和都整除 3，哪一位不能整除，则说明只出现一次的数字这一位为 1</span><br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        res = res &lt;&lt; <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> digitsSum[i] % <span class="hljs-number">3</span> == <span class="hljs-number">1</span> &#123;<br>            res |= <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 51. 数组中的逆序对</title>
    <link href="/leetcode/jian-zhi-offer/51/"/>
    <url>/leetcode/jian-zhi-offer/51/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-51-数组中的逆序对"><a href="#剑指-Offer-51-数组中的逆序对" class="headerlink" title="剑指 Offer 51. 数组中的逆序对"></a>剑指 Offer 51. 数组中的逆序对</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/</a></p><p>「归并排序」与「逆序对」是息息相关的。使用归并排序，每当遇到 左子数组当前元素 &gt; 右子数组当前元素 时，意味着 「左子数组当前元素 至 末尾元素」 与 「右子数组当前元素」 构成了若干 「逆序对」 。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> tmp []<span class="hljs-keyword">int</span>  <span class="hljs-comment">// 暂存原数组，排序结果将直接写回原数组</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reversePairs</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    tmp = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums))<br>    <span class="hljs-built_in">copy</span>(tmp, nums)<br>    <span class="hljs-keyword">return</span> mergeSort(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, left, right <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> left &gt;= right &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <br>    mid := (left + right) / <span class="hljs-number">2</span><br>    res := mergeSort(nums, left, mid) + mergeSort(nums, mid + <span class="hljs-number">1</span>, right)<br><br>    i, j := left, mid + <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">// 更新暂存数组</span><br>    <span class="hljs-keyword">for</span> k := left; k &lt;= right; k++ &#123;<br>        tmp[k] = nums[k]<br>    &#125;<br><br>    <span class="hljs-comment">// 合并排序原数组中从 left 到 right 之间的元素</span><br>    <span class="hljs-keyword">for</span> k := left; k &lt;= right; k++ &#123;<br>        <span class="hljs-keyword">if</span> i == mid + <span class="hljs-number">1</span> &#123;  <br>            <span class="hljs-comment">// 左数组已填完，则顺序填入右数组</span><br>            nums[k] = tmp[j]<br>            j++<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> j == right + <span class="hljs-number">1</span> || tmp[i] &lt;= tmp[j] &#123;<br>            <span class="hljs-comment">// 右数组已填完，或是左数组的元素更小，填入左数组</span><br>            nums[k] = tmp[i]<br>            i++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 左数组的元素更大，填入右数组</span><br>            nums[k] = tmp[j]<br>            j++<br><br>            res += mid - i + <span class="hljs-number">1</span>  <span class="hljs-comment">// 遇到左数组元素比右数组大时，说明左数组当前位置到末尾位置的元素都比右数组的大，这些元素的个数就是逆序对个数</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 38. 字符串的排列</title>
    <link href="/leetcode/jian-zhi-offer/38/"/>
    <url>/leetcode/jian-zhi-offer/38/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a>剑指 Offer 38. 字符串的排列</h1><p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p><p>可以用经典回溯法生成全排列，但是要注意一个问题：如果给定输入字符串中有重复字符，会生成重复的排列。</p><p>因此在决定填入某个字符时，如果这个字符在这个位置上已经用过一次了，就不能再用了。用一个哈希表记录已经填过的字符。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res []<span class="hljs-keyword">string</span><br><span class="hljs-keyword">var</span> used []<span class="hljs-keyword">bool</span>   <span class="hljs-comment">// 记录哪些字符已被使用 </span><br><span class="hljs-keyword">var</span> track <span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permutation</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;<br>    res = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>)<br>    used = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, <span class="hljs-built_in">len</span>(s))<br>    backtrack(s)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(track) == <span class="hljs-built_in">len</span>(s) &#123;<br>        res = <span class="hljs-built_in">append</span>(res, track)       <br>    &#125;<br><br>    <span class="hljs-comment">// 在填入此位置时，不能使用重复字符</span><br>    set := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">rune</span>]<span class="hljs-keyword">bool</span>)<br><br>    <span class="hljs-comment">// 尝试填入所有可能的字符</span><br>    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> s &#123;<br>        <span class="hljs-comment">// 如果当前字符已被使用，或是已经填过了一样的字符，都直接跳过</span><br>        <span class="hljs-keyword">if</span> _, ok := set[r]; ok || used[i] == <span class="hljs-literal">true</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        set[r] = <span class="hljs-literal">true</span><br><br>        used[i] = <span class="hljs-literal">true</span><br>        track += <span class="hljs-keyword">string</span>(r)<br>        backtrack(s)<br>        used[i] = <span class="hljs-literal">false</span><br>        track = track[:<span class="hljs-built_in">len</span>(track)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>回溯法</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 35. 复杂链表的复制</title>
    <link href="/leetcode/jian-zhi-offer/35/"/>
    <url>/leetcode/jian-zhi-offer/35/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-35-复杂链表的复制"><a href="#剑指-Offer-35-复杂链表的复制" class="headerlink" title="剑指 Offer 35. 复杂链表的复制"></a>剑指 Offer 35. 复杂链表的复制</h1><p><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/</a></p><p>此问题的难点是如果顺序复制，random 指针可能指向未创建的节点。</p><p>可以分两次复制，第一次先复制链表，第二次再连接上 random 指针。</p><p>在新链表中，为了找到 random 指针指的是谁，需要先访问旧链表找到 random 指针，且需要在新链表中找到对应的节点，如果每次寻找这个节点都要遍历整个链表，时间复杂度则会是 O(N)。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希表记录旧节点到新节点的映射，这样可以快速找到新节点，而不用再遍历。用 O(N) 的空间换了 O(N) 的时间。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(head *Node)</span> *<span class="hljs-title">Node</span></span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*Node]*Node)<br><br>    dummyHead := <span class="hljs-built_in">new</span>(Node)<br>    currOld := head<br>    prev := dummyHead<br><br>    <span class="hljs-comment">// 遍历旧链表，复制并链接新链表的 Next 指针</span><br>    <span class="hljs-keyword">for</span> currOld != <span class="hljs-literal">nil</span> &#123;<br>        curr := &amp;Node&#123;currOld.Val, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>        prev.Next = curr<br><br>        m[currOld] = curr<br><br>        prev = curr<br>        currOld = currOld.Next<br>    &#125;<br><br>    <span class="hljs-comment">// 再遍历旧链表，链接新链表的 Random 指针</span><br>    curr := head<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        m[curr].Random = m[curr.Random]<br>        curr = curr.Next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummyHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原地复制-拆分链表"><a href="#原地复制-拆分链表" class="headerlink" title="原地复制 + 拆分链表"></a>原地复制 + 拆分链表</h2><p>可见一个关键是需要知道旧节点和新节点的映射关系。可以在复制链表时，直接把每个新节点接在对应旧节点的后面，变成 <code>old -&gt; new -&gt; old -&gt; new -&gt; </code> 这样的结构。只要顺序遍历这个链表，就知道了旧节点和新节点映射关系，设置完指针后再拆开即可。省去了哈希表的空间开销。</p><p>注意需要复原旧链表，而不能仅仅把新链表拆出来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyRandomList</span><span class="hljs-params">(head *Node)</span> *<span class="hljs-title">Node</span></span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    curr := head<br><br>    <span class="hljs-comment">// 复制链表</span><br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        next := curr.Next<br>        curr.Next = &amp;Node&#123;curr.Val, curr.Next, <span class="hljs-literal">nil</span>&#125;<br>        curr.Next.Next = next<br><br>        curr = next<br>    &#125;<br><br>    <span class="hljs-comment">// 设置 random 指针，curr 是旧链表头</span><br>    curr = head<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> curr.Random != <span class="hljs-literal">nil</span> &#123;<br>            curr.Next.Random = curr.Random.Next  <span class="hljs-comment">// 设置对应新节点 curr.Next 的 Random 指针</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            curr.Next.Random = <span class="hljs-literal">nil</span><br>        &#125;<br>        curr = curr.Next.Next                    <span class="hljs-comment">// 每次前进两个节点，保证 curr 是旧节点</span><br>    &#125;<br><br>    <span class="hljs-comment">// 拆分链表</span><br>    newHead := head.Next<br>    curr = head<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        newNode := curr.Next<br>        curr.Next = curr.Next.Next            <span class="hljs-comment">// 将 Next 链接回下一个旧节点</span><br><br>        <span class="hljs-keyword">if</span> newNode.Next != <span class="hljs-literal">nil</span> &#123;<br>            newNode.Next = newNode.Next.Next  <span class="hljs-comment">// 链接新节点的 Next 指针</span><br>        &#125;<br>        <br>        curr = curr.Next                      <span class="hljs-comment">// 前进 curr 到下一个旧节点</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> newHead<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 33. 二叉搜索树的后序遍历序列</title>
    <link href="/leetcode/jian-zhi-offer/33/"/>
    <url>/leetcode/jian-zhi-offer/33/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a>剑指 Offer 33. 二叉搜索树的后序遍历序列</h1><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p><p>根据 BST 的特点，左子树的值都小于根节点，右子树的值都大于根节点。</p><p>又根据后序遍历为 “左右根” 的特点，在后序遍历序列中，最末尾元素是根节点。</p><p>从左数起，比根节点小的都是左子树，且最后一个是左子树的根。剩下部分就是右子树。验证了 <strong>左子树的值都小于根节点，右子树的值都大于根节点</strong> 这一条件后，递归验证两颗子树。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">verifyPostorder</span><span class="hljs-params">(postorder []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> verify(postorder, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(postorder)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">verify</span><span class="hljs-params">(postorder []<span class="hljs-keyword">int</span>, left, right <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-comment">// 空树是 BST</span><br>    <span class="hljs-keyword">if</span> left &gt; right &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br> <br>    <span class="hljs-comment">// 根节点是序列最后一个元素</span><br>    rootVal := postorder[right]<br>    leftRootIdx := right<span class="hljs-number">-1</span><br><br>    <span class="hljs-comment">// 从左数起，遇到第一个比根节点大的元素，它前一个元素就是左子树根节点</span><br>    <span class="hljs-keyword">for</span> i := left; i &lt; right; i++ &#123;<br>        <span class="hljs-keyword">if</span> postorder[i] &gt; rootVal &#123;<br>            leftRootIdx = i<span class="hljs-number">-1</span><br>            <span class="hljs-keyword">break</span><br>        &#125;<br>    &#125;<br>    rightRootIdx := right - <span class="hljs-number">1</span><br><br>    <span class="hljs-comment">// 验证右子树是否都大于根节点</span><br>    <span class="hljs-keyword">for</span> i := leftRootIdx + <span class="hljs-number">1</span>; i &lt;= rightRootIdx; i++ &#123;<br>        <span class="hljs-keyword">if</span> postorder[i] &lt; rootVal &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 递归验证左右子树是否为 BST</span><br>    <span class="hljs-keyword">return</span> verify(postorder, left, leftRootIdx) &amp;&amp; verify(postorder, leftRootIdx+<span class="hljs-number">1</span>, rightRootIdx)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小栈</title>
    <link href="/leetcode/fucking-algorithm/min-stack/"/>
    <url>/leetcode/fucking-algorithm/min-stack/</url>
    
    <content type="html"><![CDATA[<h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h1><p><a href="https://leetcode-cn.com/problems/min-stack/">https://leetcode-cn.com/problems/min-stack/</a></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol><li>需要完成栈的功能（压入、弹出），因此底层数据结构是栈</li><li>需要知道最小的元素；如果最小元素被弹出，需要知道第二小的元素</li></ol><p>需求 2 是难点，由于需要知道第二小的元素，不能简单地用一个变量来记录最小值。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 2 个栈。栈 A 是一般的栈，储存所有元素。使用一个辅助栈 B，存储栈 A 中所有 <strong>非严格降序</strong> 的元素，这样栈 B 顶就是最小的元素。</p><p>新元素 <code>x</code> 入栈时，如果 <code>x &lt;= B.top()</code> (x 小于 B 的栈顶），将 x 也压入栈 B，这样就保证了最小元素的更新。</p><p>要弹出栈 A 的元素时，检查这个元素是否是跟栈 B 顶的 元素相等。如果相等，栈 B 也需要弹出，这样栈 B 的栈顶就是第二小的元素了（有可能大小不变）。</p><p>由于 B 储存的是 <strong>非严格降序</strong> 的元素，即使 A 和 B 都压入了多个一样大小的最小值，也能保证弹出栈顶后维持正确的最小元素。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MinStack <span class="hljs-keyword">struct</span> &#123;<br>    stack []<span class="hljs-keyword">int</span><br>    descendingStack []<span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-comment">/** initialize your data structure here. */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">MinStack</span></span> &#123;<br>    <span class="hljs-keyword">return</span> MinStack&#123;<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span> <span class="hljs-title">Push</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    this.stack = <span class="hljs-built_in">append</span>(this.stack, x)<br>  <br>    m := <span class="hljs-built_in">len</span>(this.descendingStack)<br>    <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span> || x &lt;= this.descendingStack[m<span class="hljs-number">-1</span>] &#123;<br>        this.descendingStack = <span class="hljs-built_in">append</span>(this.descendingStack, x)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span></span>  &#123;<br>    n, m := <span class="hljs-built_in">len</span>(this.stack), <span class="hljs-built_in">len</span>(this.descendingStack)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    x := this.stack[n<span class="hljs-number">-1</span>]<br>    this.stack = this.stack[:n<span class="hljs-number">-1</span>]<br><br>    <span class="hljs-keyword">if</span> x == this.descendingStack[m<span class="hljs-number">-1</span>] &#123;<br>        this.descendingStack = this.descendingStack[:m<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span> <span class="hljs-title">Top</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> this.stack[<span class="hljs-built_in">len</span>(this.stack)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MinStack)</span> <span class="hljs-title">GetMin</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> this.descendingStack[<span class="hljs-built_in">len</span>(this.descendingStack)<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数据结构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 16. 数值的整数次方</title>
    <link href="/leetcode/jian-zhi-offer/16/"/>
    <url>/leetcode/jian-zhi-offer/16/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a>剑指 Offer 16. 数值的整数次方</h1><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/</a></p><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/</a></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myPow</span><span class="hljs-params">(x <span class="hljs-keyword">float64</span>, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float64</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / myPow(x, -n)<br>    &#125;<br><br>    res := <span class="hljs-number">1.0</span><br>    <span class="hljs-keyword">for</span> n != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">if</span> n &amp; <span class="hljs-number">1</span> != <span class="hljs-number">0</span> &#123;    <span class="hljs-comment">// n % 2 != 0  判断 n 二进制最右边的一位是否为 1，如果为 0 就相当于 res * (x^0) = res</span><br>            res = res * x<br>        &#125;<br>        x = x * x<br>        n = n &gt;&gt; <span class="hljs-number">1</span>         <span class="hljs-comment">// n = n / 2   右移，相当于删除二进制的最右边一位</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 14- I. 剪绳子</title>
    <link href="/leetcode/jian-zhi-offer/14/"/>
    <url>/leetcode/jian-zhi-offer/14/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a>剑指 Offer 14- I. 剪绳子</h1><p><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">https://leetcode-cn.com/problems/jian-sheng-zi-lcof/</a></p><p>动态规划，<code>dp[i]</code> 表示长度为 <code>i</code> 的绳子能产生出来的最大乘积（这一段绳子可能剪了多次，也可能<strong>一次都没剪</strong>），因为题目至少要求剪一刀，因此再剪了一刀后，剩余的绳子可以不剪，这是为了方便状态转移。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cuttingRope</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// special case</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">2</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">3</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>    &#125;<br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n+<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 剩余绳子的最大长度</span><br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span><br>    dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span><br><br>    <span class="hljs-keyword">for</span> length := <span class="hljs-number">4</span>; length &lt;= n; length++ &#123;<br>        <span class="hljs-comment">// 剪掉长度为 cutted 的一段，求出剪掉多长能取到最大值</span><br>        <span class="hljs-keyword">for</span> cutted := <span class="hljs-number">1</span>; cutted &lt; length; cutted++ &#123;<br>            dp[length] = max(dp[length],  dp[length-cutted] * dp[cutted])<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 13. 机器人的运动范围</title>
    <link href="/leetcode/jian-zhi-offer/13/"/>
    <url>/leetcode/jian-zhi-offer/13/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a>剑指 Offer 13. 机器人的运动范围</h1><p><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</a></p><p>第一反应是回溯，写出来以后才发现是简单递归。回溯一般是用在<strong>穷举所有可能性</strong>时。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> visited [][]<span class="hljs-keyword">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">movingCount</span><span class="hljs-params">(m <span class="hljs-keyword">int</span>, n <span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res = <span class="hljs-number">0</span><br>    visited = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">bool</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> visited &#123;<br>        visited[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, n)<br>    &#125;<br>    traverse(m, n, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(m, n, i, j, k <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || i == m || j &lt; <span class="hljs-number">0</span> || j == n &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> i / <span class="hljs-number">10</span> + i % <span class="hljs-number">10</span> + j / <span class="hljs-number">10</span> + j % <span class="hljs-number">10</span> &gt; k &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> visited[i][j] == <span class="hljs-literal">false</span> &#123;<br>        visited[i][j] = <span class="hljs-literal">true</span><br>        res++<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    traverse(m, n, i+<span class="hljs-number">1</span>, j, k)<br>    traverse(m, n, i, j+<span class="hljs-number">1</span>, k)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <link href="/leetcode/jian-zhi-offer/12/"/>
    <url>/leetcode/jian-zhi-offer/12/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a>剑指 Offer 12. 矩阵中的路径</h1><p><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/</a></p><h2 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> visited <span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span><br><span class="hljs-keyword">var</span> target <span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exist</span><span class="hljs-params">(board [][]<span class="hljs-keyword">byte</span>, word <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    visited = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span>)<br>    target = word<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(board); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>]); j++ &#123;<br>            visited[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;] = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">if</span> backtrack(board, i, j, <span class="hljs-string">&quot;&quot;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>            <span class="hljs-built_in">delete</span>(visited, [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(board [][]<span class="hljs-keyword">byte</span>, i, j <span class="hljs-keyword">int</span>, track <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(track) &gt; <span class="hljs-built_in">len</span>(target) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125; <br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(track) == <span class="hljs-built_in">len</span>(target) &#123;<br>        <span class="hljs-keyword">if</span> track == target &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> board[i][j] != target[<span class="hljs-built_in">len</span>(track)] &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, pos := <span class="hljs-keyword">range</span> getNextPos(i, j, m, n) &#123;<br>        <span class="hljs-keyword">if</span> _, ok := visited[pos]; !ok &#123;<br>            visited[pos] = <span class="hljs-literal">true</span><br>            <span class="hljs-keyword">if</span> backtrack(board, pos[<span class="hljs-number">0</span>], pos[<span class="hljs-number">1</span>], track + <span class="hljs-keyword">string</span>(board[i][j])) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>            <span class="hljs-built_in">delete</span>(visited, pos)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 加完当前字母后无路可走了</span><br>    <span class="hljs-keyword">return</span> track + <span class="hljs-keyword">string</span>(board[i][j]) == target<br>&#125;<br><br><span class="hljs-comment">// 获取下一个合法位置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getNextPos</span><span class="hljs-params">(i, j, m, n <span class="hljs-keyword">int</span>)</span> [][2]<span class="hljs-title">int</span></span> &#123;<br>    res := <span class="hljs-built_in">make</span>([][<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">if</span> i + <span class="hljs-number">1</span> &lt; m &#123;<br>        res = <span class="hljs-built_in">append</span>(res, [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i+<span class="hljs-number">1</span>, j&#125;)<br>    &#125;<br>    <span class="hljs-keyword">if</span> j + <span class="hljs-number">1</span> &lt; n &#123;<br>        res = <span class="hljs-built_in">append</span>(res, [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j+<span class="hljs-number">1</span>&#125;)<br>    &#125;<br>    <span class="hljs-keyword">if</span> i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &#123;<br>        res = <span class="hljs-built_in">append</span>(res, [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i<span class="hljs-number">-1</span>, j&#125;)<br>    &#125;<br>    <span class="hljs-keyword">if</span> j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &#123;<br>        res = <span class="hljs-built_in">append</span>(res, [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j<span class="hljs-number">-1</span>&#125;)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><ol><li>是否是合法位置可以进入函数后再判断 （i.e. 作为 base case）</li><li>是否访问过此位置也可以进入函数后判断，在<strong>继续 backtrack 之后</strong>、<strong>函数退出之前</strong>，释放对此位置的访问</li><li>由于每次进入函数只需要比较当前位置和 <code>target</code> 的某个值是否相等，不需要储存整个 <code>track</code>，只用记录当前匹配到哪里了</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> visited <span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span><br><span class="hljs-keyword">var</span> target <span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">exist</span><span class="hljs-params">(board [][]<span class="hljs-keyword">byte</span>, word <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    visited = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span>)<br>    target = word<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(board); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>]); j++ &#123;<br>            <span class="hljs-keyword">if</span> backtrack(board, i, j, <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(board [][]<span class="hljs-keyword">byte</span>, i, j, k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(board), <span class="hljs-built_in">len</span>(board[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-comment">// 越界</span><br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || i == m || j &lt; <span class="hljs-number">0</span> || j == n || board[i][j] != target[k] &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 已访问过</span><br>    <span class="hljs-keyword">if</span> _, ok := visited[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;]; ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    visited[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment">// 已全部匹配</span><br>    <span class="hljs-keyword">if</span> k == <span class="hljs-built_in">len</span>(target) - <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    res := backtrack(board, i+<span class="hljs-number">1</span>, j, k+<span class="hljs-number">1</span>) || backtrack(board, i, j+<span class="hljs-number">1</span>, k+<span class="hljs-number">1</span>) || backtrack(board, i<span class="hljs-number">-1</span>, j, k+<span class="hljs-number">1</span>) || backtrack(board, i, j<span class="hljs-number">-1</span>, k+<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-built_in">delete</span>(visited, [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;)  <span class="hljs-comment">// 退出节点，设为未访问</span><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>队列实现栈以及栈实现队列</title>
    <link href="/leetcode/fucking-algorithm/queue-as-stack-and-vice-versa/"/>
    <url>/leetcode/fucking-algorithm/queue-as-stack-and-vice-versa/</url>
    
    <content type="html"><![CDATA[<h1 id="队列实现栈以及栈实现队列"><a href="#队列实现栈以及栈实现队列" class="headerlink" title="队列实现栈以及栈实现队列"></a>队列实现栈以及栈实现队列</h1><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">https://leetcode-cn.com/problems/implement-queue-using-stacks/</a></p><p>两个栈来回倒，其中一个的栈顶就是最后进入的，push 的时候压进这个栈；另一个栈的栈顶是最先进入的，pop 和 peek 的时候弹出这个栈顶。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyQueue <span class="hljs-keyword">struct</span> &#123;<br>    s1, s2 []<span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">MyQueue</span></span> &#123;<br>    <span class="hljs-keyword">return</span> MyQueue&#123;<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span> <span class="hljs-title">Push</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    <span class="hljs-comment">// 弹出所有 s2 元素并压入 s1</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.s2) != <span class="hljs-number">0</span> &#123;<br>        top := this.s2[<span class="hljs-built_in">len</span>(this.s2)<span class="hljs-number">-1</span>]<br>        this.s2 = this.s2[:<span class="hljs-built_in">len</span>(this.s2)<span class="hljs-number">-1</span>]<br>        this.s1 = <span class="hljs-built_in">append</span>(this.s1, top)<br>    &#125;<br><br>    <span class="hljs-comment">// 压入 x</span><br>    this.s1 = <span class="hljs-built_in">append</span>(this.s1, x)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 弹出所有 s1 元素并压入 s2</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.s1) != <span class="hljs-number">0</span> &#123;<br>        top := this.s1[<span class="hljs-built_in">len</span>(this.s1)<span class="hljs-number">-1</span>]<br>        this.s1 = this.s1[:<span class="hljs-built_in">len</span>(this.s1)<span class="hljs-number">-1</span>]<br>        this.s2 = <span class="hljs-built_in">append</span>(this.s2, top)<br>    &#125;<br><br>    <span class="hljs-comment">// s2 此时已是先进先出顺序。弹出 s2 栈顶元素</span><br>    top := this.s2[<span class="hljs-built_in">len</span>(this.s2)<span class="hljs-number">-1</span>]<br>    this.s2 = this.s2[:<span class="hljs-built_in">len</span>(this.s2)<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> top<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span> <span class="hljs-title">Peek</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 弹出所有 s1 元素并压入 s2</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(this.s1) != <span class="hljs-number">0</span> &#123;<br>        top := this.s1[<span class="hljs-built_in">len</span>(this.s1)<span class="hljs-number">-1</span>]<br>        this.s1 = this.s1[:<span class="hljs-built_in">len</span>(this.s1)<span class="hljs-number">-1</span>]<br>        this.s2 = <span class="hljs-built_in">append</span>(this.s2, top)<br>    &#125;<br><br>    <span class="hljs-comment">// s2 此时已是先进先出顺序。返回 s2 栈顶元素</span><br>    <span class="hljs-keyword">return</span> this.s2[<span class="hljs-built_in">len</span>(this.s2)<span class="hljs-number">-1</span>]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyQueue)</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(this.s1) + <span class="hljs-built_in">len</span>(this.s2) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">https://leetcode-cn.com/problems/implement-stack-using-queues/</a></p><p>只用一个队列即可。栈顶元素就是队尾，入队时记下来。弹出栈顶元素时，将其他元素全部出队并重新入队，注意记住下一个栈顶元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStack <span class="hljs-keyword">struct</span> &#123;<br>    top <span class="hljs-keyword">int</span><br>    q []<span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">MyStack</span></span> &#123;<br>    <span class="hljs-keyword">return</span> MyStack&#123;&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span> <span class="hljs-title">Push</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    this.q = <span class="hljs-built_in">append</span>(this.q, x)<br>    this.top = x  <span class="hljs-comment">// 顺便记录栈顶</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    sz := <span class="hljs-built_in">len</span>(this.q) - <span class="hljs-number">2</span><br>    <span class="hljs-keyword">for</span> sz &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 无关元素重新重新排队</span><br>        front := this.q[<span class="hljs-number">0</span>]<br>        this.q = this.q[<span class="hljs-number">1</span>:]<br>        this.q = <span class="hljs-built_in">append</span>(this.q, front)<br>        sz--<br>    &#125;<br>    <span class="hljs-comment">// 当前栈顶的前一个元素是下一个栈顶，单独拎出来记住</span><br>    nextTop := this.q[<span class="hljs-number">0</span>]<br>    this.q = this.q[<span class="hljs-number">1</span>:]<br>    this.q = <span class="hljs-built_in">append</span>(this.q, nextTop)<br><br>    this.top = nextTop<br><br>    <span class="hljs-comment">// 当前栈顶元素出队并返回</span><br>    top := this.q[<span class="hljs-number">0</span>]<br>    this.q = this.q[<span class="hljs-number">1</span>:]<br>    <span class="hljs-keyword">return</span> top<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span> <span class="hljs-title">Top</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> this.top<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MyStack)</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(this.q) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数据结构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <link href="/leetcode/jian-zhi-offer/06/"/>
    <url>/leetcode/jian-zhi-offer/06/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h1><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p><p>递归后序</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res []<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reversePrint</span><span class="hljs-params">(head *ListNode)</span> []<span class="hljs-title">int</span></span> &#123;<br>    res = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    traverse(head)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(head *ListNode)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    traverse(head.Next)<br>    res = <span class="hljs-built_in">append</span>(res, head.Val)<br>&#125;<br></code></pre></td></tr></table></figure><p>两次遍历（实际运行更快，复杂度一样）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reversePrint</span><span class="hljs-params">(head *ListNode)</span> []<span class="hljs-title">int</span></span> &#123;<br>    count := <span class="hljs-number">0</span><br>    p := head<br>    <span class="hljs-keyword">for</span> p != <span class="hljs-literal">nil</span> &#123;<br>        p = p.Next<br>        count++<br>    &#125;<br><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, count)<br>    <span class="hljs-keyword">for</span> i := count - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        res[i] = head.Val<br>        head = head.Next<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;   <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <link href="/leetcode/jian-zhi-offer/04/"/>
    <url>/leetcode/jian-zhi-offer/04/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a>剑指 Offer 04. 二维数组中的查找</h1><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</a></p><p>从数组的右上角开始找起，会发现有类似 BST 的特点。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(matrix) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <br>    m, n := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br><br>    <span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>; &#123;<br>        <span class="hljs-keyword">if</span> matrix[i][j] == target &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> matrix[i][j] &gt; target &#123;<br>            j--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <link href="/leetcode/jian-zhi-offer/03/"/>
    <url>/leetcode/jian-zhi-offer/03/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-03-数组中重复的数字"><a href="#剑指-Offer-03-数组中重复的数字" class="headerlink" title="剑指 Offer 03. 数组中重复的数字"></a>剑指 Offer 03. 数组中重复的数字</h1><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span>)<br>    <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-keyword">if</span> _, ok := m[n]; ok &#123;<br>            <span class="hljs-keyword">return</span> n<br>        &#125;<br>        m[n] = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原地交换"><a href="#原地交换" class="headerlink" title="原地交换"></a>原地交换</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); &#123;<br>        n := nums[i]<br>        <span class="hljs-keyword">if</span> n == i &#123;<br>            i++<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> n == nums[n] &#123;<br>            <span class="hljs-keyword">return</span> n<br>        &#125;<br>        nums[n], nums[i] = nums[i], nums[n]<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>剑指 Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据流的中位数</title>
    <link href="/leetcode/fucking-algorithm/find-median-from-data-stream/"/>
    <url>/leetcode/fucking-algorithm/find-median-from-data-stream/</url>
    
    <content type="html"><![CDATA[<h1 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h1><p><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/">https://leetcode-cn.com/problems/find-median-from-data-stream/</a></p><p>用两个优先级队列实现，一个 <code>MinHeap</code> 存放比中位数小的（最大堆），另一个 <code>MaxHeap</code> 存放比中位数大的（最小堆），这样两个堆的堆顶就是最靠近中位数的两个数。</p><p>只要能保证两个优先级队列<strong>大小最多不相差超过 1</strong>，中位数就位于数量更多的那堆顶、或是两个堆顶的平均数。</p><p>插入时，需要维持 <code>MinHeap</code> 的所有元素都比 <code>MaxHeap</code> 的小，因此不能简单比较待插入元素和两个堆顶元素大小就插入。</p><p>如果想插入 <code>MaxHeap</code>，要先插入到<code>MinHeap</code> 中，然后从 <code>MinHeap</code> 中弹出堆顶（最大的）元素，再插入到 <code>MaxHeap</code> 中。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里的 Golang 实现中，直接使用 <code>sort.IntSlice</code> 作为底层的队列，这个类型已经实现好了排序的接口，且是按从小到大排（因此它是一个最小堆）。</p><p>为了减少代码量，最大堆  <code>MinHeap</code> 也复用这个类型，让元素在进出 <code>MinHeap</code> 的时候都取反，它就相当于变成了个最大堆（里面存的都是负数，堆顶是最小的负数，取反后变成最大的）。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sort&quot;</span><br><br><span class="hljs-keyword">type</span> MedianFinder <span class="hljs-keyword">struct</span> &#123;<br>    MinHeap, MaxHeap *Heap<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">MedianFinder</span></span> &#123;<br>    <span class="hljs-keyword">return</span> MedianFinder&#123; &amp;Heap&#123;&#125;, &amp;Heap&#123;&#125; &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span> <span class="hljs-title">AddNum</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> this.MinHeap.Len() &gt;= this.MaxHeap.Len() &#123;<br>        heap.Push(this.MinHeap, -num)<br>        heap.Push(this.MaxHeap, -heap.Pop(this.MinHeap).(<span class="hljs-keyword">int</span>))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        heap.Push(this.MaxHeap, num)<br>        heap.Push(this.MinHeap, -heap.Pop(this.MaxHeap).(<span class="hljs-keyword">int</span>))<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MedianFinder)</span> <span class="hljs-title">FindMedian</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> &#123;<br>    <span class="hljs-keyword">if</span> this.MinHeap.Len() &lt; this.MaxHeap.Len() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">float64</span>(this.MaxHeap.IntSlice[<span class="hljs-number">0</span>])<br>    &#125;<br>    <span class="hljs-keyword">if</span> this.MinHeap.Len() &gt; this.MaxHeap.Len() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">float64</span>(-this.MinHeap.IntSlice[<span class="hljs-number">0</span>])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">float64</span>(this.MaxHeap.IntSlice[<span class="hljs-number">0</span>] - this.MinHeap.IntSlice[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span><br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MedianFinder object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.AddNum(num);</span><br><span class="hljs-comment"> * param_2 := obj.FindMedian();</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">// sort.IntSlice 已经给 []int 实现了 sort 相关的那三个接口</span><br><span class="hljs-keyword">type</span> Heap <span class="hljs-keyword">struct</span> &#123; sort.IntSlice &#125;  <span class="hljs-comment">// 直接作为匿名字段嵌入</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Heap)</span> <span class="hljs-title">Push</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    h.IntSlice = <span class="hljs-built_in">append</span>(h.IntSlice, x.(<span class="hljs-keyword">int</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *Heap)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>    old := h.IntSlice<br>    n := <span class="hljs-built_in">len</span>(old)<br>    x := old[n<span class="hljs-number">-1</span>]<br>    h.IntSlice = old[:n<span class="hljs-number">-1</span>]<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://pkg.go.dev/sort#IntSlice">https://pkg.go.dev/sort#IntSlice</a></p><p><a href="https://pkg.go.dev/container/heap">https://pkg.go.dev/container/heap</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数据结构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>优先级队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计推特</title>
    <link href="/leetcode/fucking-algorithm/design-twitter/"/>
    <url>/leetcode/fucking-algorithm/design-twitter/</url>
    
    <content type="html"><![CDATA[<h1 id="设计推特"><a href="#设计推特" class="headerlink" title="设计推特"></a>设计推特</h1><p><a href="https://leetcode-cn.com/problems/design-twitter/">https://leetcode-cn.com/problems/design-twitter/</a></p><p>此问题一个难点是如何按时间顺序展示 <em>关注了的用户</em> 发的推特。</p><p>每个用户用 <strong>链表</strong> 维护自己发的推特，这样可以保持推特的时间顺序信息。展示关注用户推特就相当于 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并 K 个有序链表</a>，用一个优先级队列实现即可。</p><p>用一个全局时间戳 <code>timestamp</code> 来记录推特的时间，用于优先级队列的排序，每次发推特都使这个值递增。推特类设计成类似链表的结构。</p><p>最后是 <code>Twitter</code> 对象要用一个哈希表维护自己的用户，然后每个用户也要用一个哈希表维护自己关注的用户 ID。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Twitter <span class="hljs-keyword">struct</span> &#123;<br>    UsersMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*User<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">Twitter</span></span> &#123;<br>    <span class="hljs-keyword">return</span> Twitter&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*User)&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Twitter)</span> <span class="hljs-title">PostTweet</span><span class="hljs-params">(userId <span class="hljs-keyword">int</span>, tweetId <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> u, ok := this.UsersMap[userId]; ok &#123;<br>        u.post(tweetId)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        u = NewUser(userId)<br>        this.UsersMap[userId] = u<br><br>        u.post(tweetId)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Twitter)</span> <span class="hljs-title">GetNewsFeed</span><span class="hljs-params">(userId <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    tweetIds := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">if</span> u, ok := this.UsersMap[userId]; ok &#123;<br>        pq := <span class="hljs-built_in">make</span>(PriorityQueue, <span class="hljs-number">0</span>)<br>        heap.Init(&amp;pq)<br><br>        <span class="hljs-keyword">for</span> followee := <span class="hljs-keyword">range</span> u.Following &#123;<br>            headT := this.UsersMap[followee].Head<br>            <span class="hljs-keyword">if</span> headT != <span class="hljs-literal">nil</span> &#123;<br>                heap.Push(&amp;pq, headT)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 通过优先级队列按时间降序取推文</span><br>        <span class="hljs-keyword">for</span> pq.Len() &gt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(tweetIds) == <span class="hljs-number">10</span> &#123;<br>                <span class="hljs-keyword">break</span><br>            &#125;<br>            tweet := heap.Pop(&amp;pq).(*Tweet)<br>            <span class="hljs-keyword">if</span> tweet.Next != <span class="hljs-literal">nil</span> &#123;<br>                heap.Push(&amp;pq, tweet.Next)<br>            &#125;<br><br>            tweetIds = <span class="hljs-built_in">append</span>(tweetIds, tweet.Id)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> tweetIds<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Twitter)</span> <span class="hljs-title">Follow</span><span class="hljs-params">(followerId <span class="hljs-keyword">int</span>, followeeId <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    <span class="hljs-comment">// 如果 follower 或 followee 不存在，新建</span><br>    <span class="hljs-keyword">if</span> _, ok := this.UsersMap[followerId]; !ok &#123;<br>        f := NewUser(followerId)<br>        this.UsersMap[followerId] = f<br>    &#125;<br>    <span class="hljs-keyword">if</span> _, ok := this.UsersMap[followeeId]; !ok &#123;<br>        f := NewUser(followeeId)<br>        this.UsersMap[followeeId] = f<br>    &#125;<br>    this.UsersMap[followerId].follow(followeeId)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Twitter)</span> <span class="hljs-title">Unfollow</span><span class="hljs-params">(followerId <span class="hljs-keyword">int</span>, followeeId <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    <span class="hljs-keyword">if</span> f, ok := this.UsersMap[followerId]; ok &#123;<br>        f.unfollow(followeeId)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Twitter object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor();</span><br><span class="hljs-comment"> * obj.PostTweet(userId,tweetId);</span><br><span class="hljs-comment"> * param_2 := obj.GetNewsFeed(userId);</span><br><span class="hljs-comment"> * obj.Follow(followerId,followeeId);</span><br><span class="hljs-comment"> * obj.Unfollow(followerId,followeeId);</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**** Tweet 类和 User 类 ****/</span><br><br><span class="hljs-keyword">var</span> timestamp <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">type</span> Tweet <span class="hljs-keyword">struct</span> &#123;<br>    Id, Time <span class="hljs-keyword">int</span><br>    Next     *Tweet<br>&#125;<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    Id        <span class="hljs-keyword">int</span><br>    Following <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span><br>    Head      *Tweet<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewUser</span><span class="hljs-params">(userId <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">User</span></span> &#123;<br>    u := &amp;User&#123;userId, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span>), <span class="hljs-literal">nil</span>&#125;<br>    u.follow(userId)  <span class="hljs-comment">// 把自己也加入关注列表</span><br>    <span class="hljs-keyword">return</span> u<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span> <span class="hljs-title">follow</span><span class="hljs-params">(userId <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    u.Following[userId] = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span> <span class="hljs-title">unfollow</span><span class="hljs-params">(userId <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> userId != u.Id &#123;<br>        <span class="hljs-built_in">delete</span>(u.Following, userId)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span> <span class="hljs-title">post</span><span class="hljs-params">(tweetId <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    tweet := &amp;Tweet&#123;tweetId, timestamp, <span class="hljs-literal">nil</span>&#125;<br>    timestamp++<br><br>    tweet.Next = u.Head<br>    u.Head = tweet<br>&#125;<br><br><span class="hljs-comment">/**** 优先级队列 ****/</span><br><br><span class="hljs-keyword">type</span> PriorityQueue []*Tweet<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(pq) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-comment">// 按时间降序排列</span><br><span class="hljs-keyword">return</span> pq[i].Time &gt; pq[j].Time<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq PriorityQueue)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>pq[i], pq[j] = pq[j], pq[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span> <span class="hljs-title">Push</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>tweet := x.(*Tweet)<br>*pq = <span class="hljs-built_in">append</span>(*pq, tweet)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(pq *PriorityQueue)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>old := *pq<br>n := <span class="hljs-built_in">len</span>(old)<br>tweet := old[n<span class="hljs-number">-1</span>]<br>old[n<span class="hljs-number">-1</span>] = <span class="hljs-literal">nil</span>  <span class="hljs-comment">// 防止内存泄漏</span><br>*pq = old[:n<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> tweet<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数据结构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>优先级队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的位操作</title>
    <link href="/leetcode/fucking-algorithm/common-bitwise-operations/"/>
    <url>/leetcode/fucking-algorithm/common-bitwise-operations/</url>
    
    <content type="html"><![CDATA[<h1 id="常用的位操作"><a href="#常用的位操作" class="headerlink" title="常用的位操作"></a>常用的位操作</h1><p><a href="https://labuladong.gitee.io/algo/4/30/118/">https://labuladong.gitee.io/algo/4/30/118/</a></p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="将某个二进制数的第-i-位置为-0-或-1"><a href="#将某个二进制数的第-i-位置为-0-或-1" class="headerlink" title="将某个二进制数的第 i 位置为 0 或 1"></a>将某个二进制数的第 i 位置为 0 或 1</h3><p>在用位图技巧记录一连串 bool 值的时候非常有用。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs go">n = n | <span class="hljs-number">1</span> &lt;&lt; i    <span class="hljs-comment">// 用或操作置 1</span><br><br>n = n &amp; ~(<span class="hljs-number">1</span> &lt;&lt; i) <span class="hljs-comment">// 用与操作置 0</span><br><br>n = n ^ <span class="hljs-number">1</span> &lt;&lt; i    <span class="hljs-comment">// 用异或操作翻转这一位</span><br></code></pre></td></tr></table></figure><p>解释：将 1 左移 <code>i</code> 位，得到的数只有第 <code>i</code> 位为 1，其余为 0。</p><ul><li>用 <code>1 &lt;&lt; i</code> 对 <code>n</code> 进行 OR 操作，其他位置都会维持不变，第 <code>i</code> 位会变成 1。</li><li>用 <code>~(1 &lt;&lt; i)</code> 对 <code>n</code> 进行 AND 操作，只有第 <code>i</code> 位会变成 0。</li><li>用 <code>1 &lt;&lt; i</code> 对 <code>n</code> 进行 XOR 操作，由于 <code>1 XOR 0 = 1</code>，<code>1 XOR 1 = 0</code>，如果这一位原来是 1，异或后会变成 0；如果这一位原来是 0，异或后会变成 1，实现了翻转。因为 <code>1 &lt;&lt; i</code> 的其他位置都是 0，而 <code>1 XOR 0 = 1</code>，<code>0 XOR 0 = 0</code>，<code>n</code> 的其他位置不会变。</li></ul><h3 id="利用或操作-和空格将英文字符转换为小写"><a href="#利用或操作-和空格将英文字符转换为小写" class="headerlink" title="利用或操作 | 和空格将英文字符转换为小写"></a>利用或操作 <code>|</code> 和空格将英文字符转换为小写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">(<span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27; &#x27;</span>) = <span class="hljs-string">&#x27;a&#x27;</span><br>(<span class="hljs-string">&#x27;A&#x27;</span> | <span class="hljs-string">&#x27; &#x27;</span>) = <span class="hljs-string">&#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="利用与操作-amp-和下划线将英文字符转换为大写"><a href="#利用与操作-amp-和下划线将英文字符转换为大写" class="headerlink" title="利用与操作 &amp; 和下划线将英文字符转换为大写"></a>利用与操作 <code>&amp;</code> 和下划线将英文字符转换为大写</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">(<span class="hljs-string">&#x27;b&#x27;</span> &amp; <span class="hljs-string">&#x27;_&#x27;</span>) = <span class="hljs-string">&#x27;B&#x27;</span><br>(<span class="hljs-string">&#x27;B&#x27;</span> &amp; <span class="hljs-string">&#x27;_&#x27;</span>) = <span class="hljs-string">&#x27;B&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="利用异或操作-和空格进行英文字符大小写互换"><a href="#利用异或操作-和空格进行英文字符大小写互换" class="headerlink" title="利用异或操作 ^ 和空格进行英文字符大小写互换"></a>利用异或操作 ^ 和空格进行英文字符大小写互换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">(<span class="hljs-string">&#x27;d&#x27;</span> ^ <span class="hljs-string">&#x27; &#x27;</span>) = <span class="hljs-string">&#x27;D&#x27;</span><br>(<span class="hljs-string">&#x27;D&#x27;</span> ^ <span class="hljs-string">&#x27; &#x27;</span>) = <span class="hljs-string">&#x27;d&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="判断两个数是否异号"><a href="#判断两个数是否异号" class="headerlink" title="判断两个数是否异号"></a>判断两个数是否异号</h3><p>利用补码编码的符号位来判断，可以省去 if else 分支。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">x, y := <span class="hljs-number">-1</span>, <span class="hljs-number">2</span><br>f := ((x ^ y) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// true</span><br><br>x, y := <span class="hljs-number">3</span>, <span class="hljs-number">2</span><br>f := ((x ^ y) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="算法常用操作"><a href="#算法常用操作" class="headerlink" title="算法常用操作"></a>算法常用操作</h2><p><code>n &amp; (n - 1)</code> 技巧：作用是消除数字 <code>n</code> 的二进制表示中的最后一个 1。</p><p>其核心逻辑是：<code>n - 1</code> 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 <code>n</code> 做一次 <code>&amp;</code> 运算，就可以仅仅把最后一个 1 变成 0 了。</p><p><img src="https://labuladong.gitee.io/algo/images/%e4%bd%8d%e6%93%8d%e4%bd%9c/1.png"></p><h3 id="计算汉明权重（Hamming-Weight"><a href="#计算汉明权重（Hamming-Weight" class="headerlink" title="计算汉明权重（Hamming Weight"></a>计算汉明权重（Hamming Weight</h3><p><a href="https://leetcode-cn.com/problems/number-of-1-bits/">https://leetcode-cn.com/problems/number-of-1-bits/</a></p><p>因为 <code>n &amp; (n - 1)</code> 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 <code>n</code> 变成 0 为止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(n <span class="hljs-keyword">uint32</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> n != <span class="hljs-number">0</span> &#123;<br>        n = n &amp; (n - <span class="hljs-number">1</span>)<br>        res++<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断一个数是不是-2-的指数"><a href="#判断一个数是不是-2-的指数" class="headerlink" title="判断一个数是不是 2 的指数"></a>判断一个数是不是 2 的指数</h3><p><a href="https://leetcode-cn.com/problems/power-of-two/">https://leetcode-cn.com/problems/power-of-two/</a></p><p>一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1，用这个技巧消除 1 一次，如果变成 0 了就是 2 的幂。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> (n &amp; (n - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查找只出现一次的元素"><a href="#查找只出现一次的元素" class="headerlink" title="查找只出现一次的元素"></a>查找只出现一次的元素</h3><p><a href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></p><p>一个数和它本身做异或运算结果为 0，即 <code>a ^ a = 0</code>；一个数和 0 做异或运算的结果为它本身，即 <code>a ^ 0 = a</code>。</p><p>对于这道题目，我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        res ^= nums[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数学运算技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS 解决滑动谜题</title>
    <link href="/leetcode/fucking-algorithm/sliding-puzzle/"/>
    <url>/leetcode/fucking-algorithm/sliding-puzzle/</url>
    
    <content type="html"><![CDATA[<h1 id="BFS-解决滑动谜题"><a href="#BFS-解决滑动谜题" class="headerlink" title="BFS 解决滑动谜题"></a>BFS 解决滑动谜题</h1><p><a href="https://leetcode-cn.com/problems/sliding-puzzle/">https://leetcode-cn.com/problems/sliding-puzzle/</a></p><p>对于这种计算最小步数的问题，我们就要敏感地想到 BFS 算法。<strong>如何穷举出 <code>board</code> 当前局面下可能衍生出的所有局面</strong> ？这就简单了，看数字 0 的位置呗，和上下左右的数字进行交换就行了：</p><p><img src="https://labuladong.gitee.io/algo/images/sliding_puzzle/3.jpeg"></p><p>每次先找到数字 0，然后和周围的数字进行交换，形成新的局面加入队列…… 当第一次到达 <code>target</code> 时，就得到了赢得游戏的最少步数。由于棋盘只是 2 X 3 的小尺寸，可以将棋盘压缩为一个一维的字符串，这样方便传递参数和存入哈希表（记录已访问节点）。</p><p>为了能正确地移动数字 0，需要将一维字符串中对于二维的邻居手动写出来。</p><p><img src="https://labuladong.gitee.io/algo/images/sliding_puzzle/4.jpeg"></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">slidingPuzzle</span><span class="hljs-params">(board [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    target := <span class="hljs-string">&quot;123450&quot;</span><br>    neighbor := [][]<span class="hljs-keyword">int</span>&#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;,<br>        &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;,<br>    &#125;<br><br>    sb := strings.Builder&#123;&#125;<br>    <span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> board &#123;<br>        <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> i &#123;<br>            sb.WriteString(strconv.Itoa(v))<br>        &#125;<br>    &#125;<br>    start := sb.String()<br><br>    <span class="hljs-comment">/******* BFS 算法框架开始 *******/</span><br>    queue := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>)<br>    visited := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)<br><br>    queue = <span class="hljs-built_in">append</span>(queue, start)<br>    visited[start] = <span class="hljs-literal">true</span><br><br>    steps := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        sz := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; sz; i++ &#123;<br>            currState := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br><br>            <span class="hljs-keyword">if</span> currState == target &#123;<br>                <span class="hljs-keyword">return</span> steps<br>            &#125;<br><br>            zeroIdx := <span class="hljs-number">0</span><br>            <span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> currState &#123;<br>                <span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>                    zeroIdx = i<br>                    <span class="hljs-keyword">break</span><br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 尝试将 0 交换到每一个邻居节点上，形成新的棋盘状态</span><br>            <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> neighbor[zeroIdx] &#123;<br>                newState := moveZero(currState, zeroIdx, n)<br>                <span class="hljs-keyword">if</span> _, ok := visited[newState]; !ok &#123;<br>                    queue = <span class="hljs-built_in">append</span>(queue, newState)<br>                    visited[newState] = <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        steps++<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZero</span><span class="hljs-params">(state <span class="hljs-keyword">string</span>, from, to <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    chars := []<span class="hljs-keyword">rune</span>(state)<br>    chars[from], chars[to] = chars[to], chars[from]<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(chars)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>暴力搜索算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFS 算法</title>
    <link href="/leetcode/fucking-algorithm/bfs-basic/"/>
    <url>/leetcode/fucking-algorithm/bfs-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="BFS-算法"><a href="#BFS-算法" class="headerlink" title="BFS 算法"></a>BFS 算法</h1><p><strong>BFS 找到的路径一定是最短的</strong>, 问题的本质就是让你在一幅「图」中找到从起点 <code>start</code> 到终点 <code>target</code> 的最近距离。</p><h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * type TreeNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Left *TreeNode</span><br><span class="hljs-comment"> *     Right *TreeNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    queue := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">0</span>)<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    depth := <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        sz := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; sz; i++ &#123;<br>            curr := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br><br>            <span class="hljs-keyword">if</span> curr.Left == <span class="hljs-literal">nil</span> &amp;&amp; curr.Right == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> depth<br>            &#125;<br>            <span class="hljs-keyword">if</span> curr.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, curr.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> curr.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, curr.Right)<br>            &#125;<br>        &#125;<br>        depth++<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> depth<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="打开转盘锁"><a href="#打开转盘锁" class="headerlink" title="打开转盘锁"></a>打开转盘锁</h2><p><a href="https://leetcode-cn.com/problems/open-the-lock/">https://leetcode-cn.com/problems/open-the-lock/</a></p><p>如何穷举一个密码的所有组合？比如说从 <code>&quot;0000&quot;</code> 开始，转一次，可以穷举出 <code>&quot;1000&quot;, &quot;9000&quot;, &quot;0100&quot;, &quot;0900&quot;...</code> 共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出其他</p><p>这就可以抽象成一幅图，每个节点有 8 个相邻的节点，知道起点终点，求最短距离，典型的 BFS 问题了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">openLock</span><span class="hljs-params">(deadends []<span class="hljs-keyword">string</span>, target <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    queue := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>)<br>    visited := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)<br>    <span class="hljs-comment">// 将死亡密码也加入 visited 中，这样就不会遍历到</span><br>    <span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> deadends &#123;<br>        <span class="hljs-keyword">if</span> d == <span class="hljs-string">&quot;0000&quot;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>        &#125;<br>        visited[d] = <span class="hljs-literal">true</span><br>    &#125;<br><br>    queue = <span class="hljs-built_in">append</span>(queue, <span class="hljs-string">&quot;0000&quot;</span>)<br>    visited[<span class="hljs-string">&quot;0000&quot;</span>] = <span class="hljs-literal">true</span><br><br>    steps := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> &#123;<br>        sz := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; sz; i++ &#123;<br>            curr := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br><br>            <span class="hljs-keyword">if</span> curr == target &#123;<br>                <span class="hljs-keyword">return</span> steps<br>            &#125;<br><br>            <span class="hljs-comment">// 尝试拨动 4 个位置中的一个，作为当前节点的相邻节点</span><br>            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++ &#123;<br>                up, down := plusOne(curr, j), minusOne(curr, j)<br><br>                <span class="hljs-comment">// 如果没访问过，就加入队列</span><br>                <span class="hljs-keyword">if</span> _, ok := visited[up]; !ok &#123;<br>                    queue = <span class="hljs-built_in">append</span>(queue, up)<br>                    visited[up] = <span class="hljs-literal">true</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> _, ok := visited[down]; !ok &#123;<br>                    queue = <span class="hljs-built_in">append</span>(queue, down)<br>                    visited[down] = <span class="hljs-literal">true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        steps++<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-comment">// 将第 j 位转盘加一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plusOne</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    chars := []<span class="hljs-keyword">rune</span>(s)<br>    <span class="hljs-keyword">if</span> chars[j] == <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>        chars[j] = <span class="hljs-string">&#x27;0&#x27;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        chars[j] += <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(chars)<br>&#125;<br><br><span class="hljs-comment">// 将第 j 位转盘减一</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minusOne</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    chars := []<span class="hljs-keyword">rune</span>(s)<br>    <span class="hljs-keyword">if</span> chars[j] == <span class="hljs-string">&#x27;0&#x27;</span> &#123;<br>        chars[j] = <span class="hljs-string">&#x27;9&#x27;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        chars[j] -= <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(chars)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>暴力搜索算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>括号生成</title>
    <link href="/leetcode/fucking-algorithm/generate-parentheses/"/>
    <url>/leetcode/fucking-algorithm/generate-parentheses/</url>
    
    <content type="html"><![CDATA[<h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">https://leetcode-cn.com/problems/generate-parentheses/</a></p><p>括号问题的两个重要性质：</p><ol><li>一个「合法」括号组合的左括号数量一定等于右括号数量.   </li><li>对于一个「合法」的括号字符串组合 <code>p</code>，必然对于任何 <code>0 &lt;= i &lt; len(p)</code> 都有：子串 <code>p[0..i]</code> 中<strong>左括号的数量都大于或等于右括号</strong>的数量。</li></ol><p>这一题用两个参数 <code>left</code> 和 <code>right</code> 分别记录剩余可使用的左右括号数量，同时为 0 则表示合法组合。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res []<span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">string</span></span> &#123;<br>    res = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>)<br>    backtrack(n, n, <span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(left, right <span class="hljs-keyword">int</span>, track <span class="hljs-keyword">string</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 在某个子序列中，右括号比左括号多（剩余的右括号更少），不合法</span><br>    <span class="hljs-keyword">if</span> right &lt; left &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 括号数量小于 0，不合法</span><br>    <span class="hljs-keyword">if</span> left &lt; <span class="hljs-number">0</span> || right &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 同时用完所有的括号，合法</span><br>    <span class="hljs-keyword">if</span> left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span> &#123;<br>        res = <span class="hljs-built_in">append</span>(res, track)<br>    &#125;<br><br>    backtrack(left - <span class="hljs-number">1</span>, right, track + <span class="hljs-string">&quot;(&quot;</span>)<br>    backtrack(left, right - <span class="hljs-number">1</span>, track + <span class="hljs-string">&quot;)&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>暴力搜索算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解数独</title>
    <link href="/leetcode/fucking-algorithm/sudoku/"/>
    <url>/leetcode/fucking-algorithm/sudoku/</url>
    
    <content type="html"><![CDATA[<h1 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h1><p><a href="https://leetcode-cn.com/problems/sudoku-solver/">https://leetcode-cn.com/problems/sudoku-solver/</a></p><p>回溯算法可以通过返回布尔值，在得到一个正确的解法后就终止回溯。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveSudoku</span><span class="hljs-params">(board [][]<span class="hljs-keyword">byte</span>)</span></span>  &#123;<br>    backtrack(board, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(board [][]<span class="hljs-keyword">byte</span>, i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-comment">// 列越界，递归到下一行继续填</span><br>    <span class="hljs-keyword">if</span> j == <span class="hljs-number">9</span> &#123;<br>        <span class="hljs-keyword">return</span> backtrack(board, i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>    &#125;<br>    <span class="hljs-comment">// 行越界，说明已经填完了，返回</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">9</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 已经存在预设数字</span><br>    <span class="hljs-keyword">if</span> board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>        <span class="hljs-keyword">return</span> backtrack(board, i, j + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> n := <span class="hljs-string">&#x27;1&#x27;</span>; n &lt;= <span class="hljs-string">&#x27;9&#x27;</span>; n++ &#123;<br>        <span class="hljs-keyword">if</span> !isValid(board, i, j, <span class="hljs-keyword">byte</span>(n)) &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 做选择</span><br>        board[i][j] = <span class="hljs-keyword">byte</span>(n)<br>        <span class="hljs-comment">// 如果找到一个可行解，立即结束</span><br>        <span class="hljs-keyword">if</span> backtrack(board, i, j + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-comment">// 撤销选择</span><br>        board[i][j] = <span class="hljs-string">&#x27;.&#x27;</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// 判断 board[row][col] 是否可以填入 val</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(board [][]<span class="hljs-keyword">byte</span>, row, col <span class="hljs-keyword">int</span>, val <span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++ &#123;<br>        <span class="hljs-comment">// 判断行是否存在重复</span><br>        <span class="hljs-keyword">if</span> board[row][i] == val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-comment">// 判断列是否存在重复</span><br>        <span class="hljs-keyword">if</span> board[i][col] == val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-comment">// 判断 3 x 3 小方框内是否存在重复</span><br>        <span class="hljs-keyword">if</span> board[(row/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span> + i/<span class="hljs-number">3</span>][(col/<span class="hljs-number">3</span>)*<span class="hljs-number">3</span> + i%<span class="hljs-number">3</span>] == val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>暴力搜索算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯法解决排列、组合、子集</title>
    <link href="/leetcode/fucking-algorithm/permutation-combination-subset/"/>
    <url>/leetcode/fucking-algorithm/permutation-combination-subset/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯法解决排列、组合、子集"><a href="#回溯法解决排列、组合、子集" class="headerlink" title="回溯法解决排列、组合、子集"></a>回溯法解决排列、组合、子集</h1><p>回溯法基本框架：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs python">result = []<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">路径, 选择列表</span>):</span><br>    <span class="hljs-keyword">if</span> 满足结束条件:<br>        result.add(路径)<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure><h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p><a href="https://leetcode-cn.com/problems/subsets/">https://leetcode-cn.com/problems/subsets/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res [][]<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subsets</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    res = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    backtrack(nums, <span class="hljs-number">0</span>, []<span class="hljs-keyword">int</span>&#123;&#125;)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, start <span class="hljs-keyword">int</span>, track []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 直接将当前子集加入结果</span><br>    t := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(track))<br>    <span class="hljs-built_in">copy</span>(t, track)<br>    res = <span class="hljs-built_in">append</span>(res, t)<br><br>    <span class="hljs-keyword">for</span> i := start; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        track = <span class="hljs-built_in">append</span>(track, nums[i])<br>        backtrack(nums, i + <span class="hljs-number">1</span>, track)<br>        track = track[:<span class="hljs-built_in">len</span>(track)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p><a href="https://leetcode-cn.com/problems/combinations/">https://leetcode-cn.com/problems/combinations/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res [][]<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">combine</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    res = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    backtrack(n, k, <span class="hljs-number">1</span>, []<span class="hljs-keyword">int</span>&#123;&#125;)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(n, k, start <span class="hljs-keyword">int</span>, track []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 组合出足够的长度才要加到结果中</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(track) == k &#123;<br>        t := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(track))<br>        <span class="hljs-built_in">copy</span>(t, track)<br>        res = <span class="hljs-built_in">append</span>(res, t)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := start; i &lt;= n; i++ &#123;<br>        track = <span class="hljs-built_in">append</span>(track, i)<br>        backtrack(n, k, i + <span class="hljs-number">1</span>, track)<br>        track = track[:<span class="hljs-built_in">len</span>(track)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res [][]<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    res = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    backtrack(nums, <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, track []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 排列出足够的长度才要加到结果中</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(track) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        t := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(track))<br>        <span class="hljs-built_in">copy</span>(t, track)<br>        res = <span class="hljs-built_in">append</span>(res, t)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nums &#123;<br>        exist := <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> track &#123;<br>            <span class="hljs-keyword">if</span> m == n &#123;<br>                exist = <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> exist &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        track = <span class="hljs-built_in">append</span>(track, n)<br>        backtrack(nums, track)<br>        track = track[:<span class="hljs-built_in">len</span>(track)<span class="hljs-number">-1</span>]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>暴力搜索算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>集合划分问题</title>
    <link href="/leetcode/fucking-algorithm/partition-to-k-equal-sum-subsets/"/>
    <url>/leetcode/fucking-algorithm/partition-to-k-equal-sum-subsets/</url>
    
    <content type="html"><![CDATA[<h1 id="集合划分问题"><a href="#集合划分问题" class="headerlink" title="集合划分问题"></a>集合划分问题</h1><p><a href="https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/">https://leetcode-cn.com/problems/partition-to-k-equal-sum-subsets/</a></p><h2 id="以数字的视角"><a href="#以数字的视角" class="headerlink" title="以数字的视角"></a>以数字的视角</h2><p>遍历所有数字，穷举每个数字可能装进的桶。当所有数字都装完后检查桶是否达到目标。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> bucket []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> target <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartitionKSubsets</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    bucket = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, k)<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += v<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> sum % k != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <br>    &#125;<br><br>    target = sum / k<br><br>    <span class="hljs-comment">// 将数组降序排序，以更快地命中剪枝条件</span><br>    sort.Slice(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>        <span class="hljs-keyword">return</span> nums[i] &gt; nums[j]<br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> backtrace(nums, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, index <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-comment">// 所有数字已用完，检查桶是否都达到目标</span><br>    <span class="hljs-keyword">if</span> index == <span class="hljs-built_in">len</span>(nums) &#123;<br>        <span class="hljs-keyword">for</span> b := <span class="hljs-number">0</span>; b &lt; <span class="hljs-built_in">len</span>(bucket); b++ &#123;<br>            <span class="hljs-keyword">if</span> bucket[b] != target &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 遍历所有桶，决定自己要不要装进去</span><br>    <span class="hljs-keyword">for</span> b := <span class="hljs-number">0</span>; b &lt; <span class="hljs-built_in">len</span>(bucket); b++ &#123;<br>        <span class="hljs-keyword">if</span> bucket[b] + nums[index] &gt; target &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        bucket[b] += nums[index]<br>        <span class="hljs-keyword">if</span> backtrace(nums, index + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        bucket[b] -= nums[index]<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="以桶的视角"><a href="#以桶的视角" class="headerlink" title="以桶的视角"></a>以桶的视角</h2><p>每个桶需要遍历 <code>nums</code> 中的所有数字，决定是否把当前数字装进桶中；当装满一个桶之后，还要装下一个桶，直到所有桶都装满为止。</p><ul><li>需要记录数字是否已经被使用。使用位图的技巧，用一个整数 <code>used</code> + 位运算来记录数字是否被使用</li><li>由于算法会遍历所有的桶，而当有其中一个桶失败，相当于其他桶在当前状态下也是会失败的，应该将这个状态保存下来，其他桶再遇到这个状态就能直接返回结果，因此把 used 用哈希表记录。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> target <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> used   <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> memo   <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartitionKSubsets</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += v<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> sum % k != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <br>    &#125;<br><br>    target = sum / k<br>    used = <span class="hljs-number">0</span>                   <span class="hljs-comment">// 使用位运算技巧，第 i 位地 1/0 表示第 i 个数字是否已被使用</span><br>    memo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span>)  <span class="hljs-comment">// 记录数字被使用的状态，避免重复运算</span><br><br>    <span class="hljs-keyword">return</span> backtrace(nums, <span class="hljs-number">0</span>, k, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, index <span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>, bucket <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-comment">// 所有桶已装满</span><br>    <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 当前桶已装满</span><br>    <span class="hljs-keyword">if</span> bucket == target &#123;<br>        res := backtrace(nums, <span class="hljs-number">0</span>, k<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)<br>        memo[used] = res<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := memo[used]; ok &#123;<br>        <span class="hljs-keyword">return</span> v<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := index; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-comment">// 第 i 个数组已经被装入其他桶中</span><br>        <span class="hljs-keyword">if</span> ((used &gt;&gt; i) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-comment">// 当前桶装不下</span><br>        <span class="hljs-keyword">if</span> bucket + nums[i] &gt; target &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        <span class="hljs-comment">// 做选择</span><br>        used |= <span class="hljs-number">1</span> &lt;&lt; i  <span class="hljs-comment">// 将第 i 位设为 1</span><br>        bucket += nums[i]<br><br>        <span class="hljs-comment">// 递归穷举下一个数字是否装入当前桶</span><br>        <span class="hljs-keyword">if</span> backtrace(nums, i + <span class="hljs-number">1</span>, k, bucket) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br><br>        <span class="hljs-comment">// 撤销选择</span><br>        used ^= <span class="hljs-number">1</span> &lt;&lt; i  <span class="hljs-comment">// 使用异或运算将第 i 位恢复 0</span><br>        bucket -= nums[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>暴力搜索算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯法</title>
    <link href="/leetcode/fucking-algorithm/backtrace-algorithm/"/>
    <url>/leetcode/fucking-algorithm/backtrace-algorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><p>回溯法基本框架：</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs python">result = []<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">路径, 选择列表</span>):</span><br>    <span class="hljs-keyword">if</span> 满足结束条件:<br>        result.add(路径)<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><p><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> result [][]<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">permute</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    result = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    backtrace(nums, <span class="hljs-literal">nil</span>)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, path []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 回溯终点：排列的数字已经用完</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(path) == <span class="hljs-built_in">len</span>(nums) &#123;<br>        result = <span class="hljs-built_in">append</span>(result, path)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nums &#123;<br>        <span class="hljs-comment">// 检查数字是否已经用过了</span><br>        exist := <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> path &#123;<br>            <span class="hljs-keyword">if</span> m == n &#123;<br>                exist = <span class="hljs-literal">true</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> exist &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br><br>        backtrace(nums, <span class="hljs-built_in">append</span>(path, n))  <span class="hljs-comment">// 这里创建了新的切片递归下去，所以不用撤销</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="N-皇后"><a href="#N-皇后" class="headerlink" title="N 皇后"></a>N 皇后</h2><p><a href="https://leetcode-cn.com/problems/n-queens/">https://leetcode-cn.com/problems/n-queens/</a></p><p>需要有个函数来判断当前位置是否能放下皇后。由于是一行一行从上往下放的，只用判断当前位置的上方、左上、右上是否存在其他皇后即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res [][]<span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">string</span></span> &#123;<br>    res = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>)<br>    board := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">string</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> board &#123;<br>        board[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> board[i] &#123;<br>            board[i][j] = <span class="hljs-string">&quot;.&quot;</span><br>        &#125;<br>    &#125;<br>    backtrace(<span class="hljs-number">0</span>, board)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(row <span class="hljs-keyword">int</span>, board [][]<span class="hljs-keyword">string</span>)</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(board)<br>    <span class="hljs-keyword">if</span> row == n &#123;<br>        b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, n)<br>        sb := &amp;strings.Builder&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>            sb.Reset()<br>            <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>                sb.WriteString(board[i][j])<br>            &#125;<br>            b[i] = sb.String()<br>        &#125;<br>        res = <span class="hljs-built_in">append</span>(res, b)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> col := <span class="hljs-number">0</span>; col &lt; n; col++ &#123;<br>        <span class="hljs-keyword">if</span> !isValid(row, col, board) &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        board[row][col] = <span class="hljs-string">&quot;Q&quot;</span>      <span class="hljs-comment">// 做选择</span><br>        backtrace(row + <span class="hljs-number">1</span>, board)<br>        board[row][col] = <span class="hljs-string">&quot;.&quot;</span>      <span class="hljs-comment">// 撤销选择</span><br>    &#125; <br>&#125;<br><br><span class="hljs-comment">// 检查是否能在当前位置[row][col]放置皇后</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(row, col <span class="hljs-keyword">int</span>, board [][]<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(board)<br><br>    <span class="hljs-comment">// 当前皇后【上方】是否存在其他皇后</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">if</span> board[i][col] == <span class="hljs-string">&quot;Q&quot;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 当前皇后【左上方】是否存在其他皇后</span><br>    <span class="hljs-keyword">for</span> i, j := row - <span class="hljs-number">1</span>, col - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i, j = i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&quot;Q&quot;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 当前皇后【右上方】是否存在其他皇后</span><br>    <span class="hljs-keyword">for</span> i, j := row - <span class="hljs-number">1</span>, col + <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i, j = i<span class="hljs-number">-1</span>, j+<span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">if</span> board[i][j] == <span class="hljs-string">&quot;Q&quot;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>暴力搜索算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大频率栈</title>
    <link href="/leetcode/fucking-algorithm/maximum-frequency-stack/"/>
    <url>/leetcode/fucking-algorithm/maximum-frequency-stack/</url>
    
    <content type="html"><![CDATA[<h1 id="最大频率栈"><a href="#最大频率栈" class="headerlink" title="最大频率栈"></a>最大频率栈</h1><p><a href="https://leetcode-cn.com/problems/maximum-frequency-stack/">https://leetcode-cn.com/problems/maximum-frequency-stack/</a></p><p>需求分析：</p><ol><li>每次 <code>pop</code> 时，必须要知道频率最高的元素是什么：使用一个变量 <code>maxFreq</code> 记录最大频率</li><li>每次 <code>push</code> 时，要知道对应元素的频率：使用哈希表 <code>valToFreq</code> 记录频率</li><li>如果频率最高的元素有多个，还得知道哪个是最近 <code>push</code> 进来的元素是哪个：使用哈希表+栈 <code>freqToVal</code> 记录相同频率的元素，且栈储存了时间信息</li></ol><p><img src="https://labuladong.gitee.io/algo/images/%e9%ab%98%e9%a2%91%e6%a0%88/1.gif"></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> FreqStack <span class="hljs-keyword">struct</span> &#123;<br>    maxFreq   <span class="hljs-keyword">int</span><br>    valToFreq <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span><br>    freqToVal <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">FreqStack</span></span> &#123;<br>    VF := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    FV := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">return</span> FreqStack&#123;<span class="hljs-number">0</span>, VF, FV&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FreqStack)</span> <span class="hljs-title">Push</span><span class="hljs-params">(val <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    this.valToFreq[val] += <span class="hljs-number">1</span>  <span class="hljs-comment">// val 对应频次加一（如果没有的话默认是 0）</span><br>    f := this.valToFreq[val]<br>    this.freqToVal[f] = <span class="hljs-built_in">append</span>(this.freqToVal[f], val)  <span class="hljs-comment">// 在更新后频次的表中加入</span><br>    this.maxFreq = max(this.maxFreq, f)  <span class="hljs-comment">// 更新最大频次</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *FreqStack)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 最大频次的表中最后一个元素就是最近加入的，将它弹出</span><br>    p := this.freqToVal[this.maxFreq][<span class="hljs-built_in">len</span>(this.freqToVal[this.maxFreq])<span class="hljs-number">-1</span>]<br>    this.freqToVal[this.maxFreq] = this.freqToVal[this.maxFreq][:<span class="hljs-built_in">len</span>(this.freqToVal[this.maxFreq])<span class="hljs-number">-1</span>]  <span class="hljs-comment">//出栈</span><br>    <br>    <span class="hljs-comment">// 如果这个频次表变成空的了，就删除它，且最大频率减一</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(this.freqToVal[this.maxFreq]) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">delete</span>(this.freqToVal, this.maxFreq)<br>        this.maxFreq--<br>    &#125;<br><br>    this.valToFreq[p]--  <span class="hljs-comment">// 更新被弹出节点的频率</span><br><br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数据结构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>哈希表</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀树的实现和应用</title>
    <link href="/leetcode/fucking-algorithm/trie-prefix-tree/"/>
    <url>/leetcode/fucking-algorithm/trie-prefix-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀树的实现和应用"><a href="#前缀树的实现和应用" class="headerlink" title="前缀树的实现和应用"></a>前缀树的实现和应用</h1><p><a href="https://labuladong.gitee.io/algo/2/20/47/">https://labuladong.gitee.io/algo/2/20/47/</a></p><h2 id="实现前缀树"><a href="#实现前缀树" class="headerlink" title="实现前缀树"></a>实现前缀树</h2><h3 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h3><p>节点可以储存任意值，而节点所代表的字符是由父节点的 <code>Children</code> 数组索引确定的。</p><p>这个索引直接对应字符的 ASCII 码，例如 <code>int(&#39;A&#39;) -&gt; 65</code>。</p><p>节点储存了值，才认为根节点到这个节点路径所代表的单词被储存了。</p><p><img src="https://labuladong.gitee.io/algo/images/trie/9.jpeg" alt="橙色节点为储存了值的节点"></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> R = <span class="hljs-number">256</span><br><br><span class="hljs-keyword">type</span> TrieNode <span class="hljs-keyword">struct</span> &#123;<br>Val      <span class="hljs-keyword">interface</span>&#123;&#125;<br>Children [R]*TrieNode<br>&#125;<br><br><span class="hljs-keyword">type</span> TrieMap <span class="hljs-keyword">struct</span> &#123;<br>Size <span class="hljs-keyword">int</span><br>root *TrieNode<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前缀树的基本搜索"><a href="#前缀树的基本搜索" class="headerlink" title="前缀树的基本搜索"></a>前缀树的基本搜索</h3><p>根据字符串 <code>key</code> 中的每一个字符作为子节点索引，在前缀树走下去。</p><ul><li>如果字符串没遍历完就无法继续搜索了，显然这个字符串不存在。</li><li>如果字符串遍历完了，但对应节点没储存值，说明这个字符串也不存在。（它是其他更长前缀的一部分）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// GetNode 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">GetNode</span><span class="hljs-params">(node *TrieNode, key <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">TrieNode</span></span> &#123;<br>p := node<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(key); i++ &#123;<br>        <span class="hljs-comment">// 无法继续向下搜索</span><br><span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>c := key[i]<br>p = p.Children[<span class="hljs-keyword">int</span>(c)]<br>&#125;<br><span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-comment">// Get 搜索 key 对应的值，不存在则返回 nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>x := t.GetNode(t.root, key)<br><br><span class="hljs-comment">// x 为空或 x 的 val 字段为空都说明 key 没有对应的值</span><br><span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> || x.Val == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> x.Val<br>&#125;<br><br><span class="hljs-comment">// ContainsKey 判断 key 是否存在在 Map 中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">ContainsKey</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> t.Get(key) != <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="是否存在以-prefix-开头的键"><a href="#是否存在以-prefix-开头的键" class="headerlink" title="是否存在以 prefix 开头的键"></a>是否存在以 <code>prefix</code> 开头的键</h3><p>同理，在前缀树中搜索这个字符串，只要能遍历完它，就说明存在以这个字符串为前缀的单词。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HasKeyWithPrefix 判断是否存在前缀为 prefix 的键</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">HasKeyWithPrefix</span><span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> t.GetNode(t.root, prefix) != <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索某个单词在-TrieMap-中储存的前缀"><a href="#搜索某个单词在-TrieMap-中储存的前缀" class="headerlink" title="搜索某个单词在 TrieMap 中储存的前缀"></a>搜索某个单词在 TrieMap 中储存的前缀</h3><p>只有当搜索到的节点储存了值，它才是一个储存了的前缀。</p><ul><li>找最短前缀，见到一个储存了值的节点就直接返回</li><li>找最长前缀，记录最长前缀长度，搜索完前缀树再返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ShortestPrefixOf 在所有键中寻找 query 的最短前缀</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">ShortestPrefixOf</span><span class="hljs-params">(query <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>p := t.root<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(query); i++ &#123;<br><span class="hljs-comment">// 无法向下搜索</span><br><span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 找到一个键是 query 的前缀就直接返回</span><br><span class="hljs-keyword">if</span> p.Val != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> query[:i]<br>&#125;<br><br><span class="hljs-comment">// 继续向下搜索</span><br>c := query[i]<br>p = p.Children[<span class="hljs-keyword">int</span>(c)]<br>&#125;<br><br><span class="hljs-comment">// query 本身就是一个键</span><br><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &amp;&amp; p.Val != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> query<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// LongestPrefixOf 在所有键中寻找 query 的最长前缀</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">LongestPrefixOf</span><span class="hljs-params">(query <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>p := t.root<br>maxLen := <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(query); i++ &#123;<br><span class="hljs-comment">// 无法向下搜索</span><br><span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-comment">// 找到一个键是 query 的前缀，更新前缀的最大长度</span><br><span class="hljs-keyword">if</span> p.Val != <span class="hljs-literal">nil</span> &#123;<br>maxLen = i<br>&#125;<br><br><span class="hljs-comment">// 向下搜索</span><br>c := query[i]<br>p = p.Children[<span class="hljs-keyword">int</span>(c)]<br>&#125;<br><br><span class="hljs-comment">// query 本身就是一个键</span><br><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &amp;&amp; p.Val != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> query<br>&#125;<br><br><span class="hljs-keyword">return</span> query[<span class="hljs-number">0</span>:maxLen]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索具有某个-prefix-的所有键"><a href="#搜索具有某个-prefix-的所有键" class="headerlink" title="搜索具有某个 prefix 的所有键"></a>搜索具有某个 <code>prefix</code> 的所有键</h3><p>实际上就是先定位到 <code>prefix</code> 的节点，以它为根节点，找出所有储存了值的子节点。</p><p>搜索时，使用回溯法搜索所有可能的子节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// KeysWithPrefix 搜索前缀为 prefix 的所有键</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">KeysWithPrefix</span><span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;<br>res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>)<br>    <span class="hljs-comment">// 先找到 prefix 所在的节点</span><br>x := t.GetNode(t.root, prefix)<br><span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br>    <span class="hljs-comment">// 遍历搜索 prefix 的所有子节点，找出所有存在的键</span><br>t.prefixTraverse(x, prefix, &amp;res)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// 遍历以 node 节点为根的 Trie 树，找到所有键</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">prefixTraverse</span><span class="hljs-params">(node *TrieNode, path <span class="hljs-keyword">string</span>, res *[]<span class="hljs-keyword">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>    <span class="hljs-comment">// 搜索到存了值的节点就是一个键</span><br><span class="hljs-keyword">if</span> node.Val != <span class="hljs-literal">nil</span> &#123;<br>*res = <span class="hljs-built_in">append</span>(*res, path)<br>&#125;<br><br><span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; R; c++ &#123;<br><span class="hljs-comment">// 做选择</span><br>path += <span class="hljs-keyword">string</span>(c)<br>t.prefixTraverse(node.Children[c], path, res)<br><span class="hljs-comment">// 撤销选择</span><br>path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="搜索具有某个-pattern-的所有键"><a href="#搜索具有某个-pattern-的所有键" class="headerlink" title="搜索具有某个 pattern 的所有键"></a>搜索具有某个 <code>pattern</code> 的所有键</h3><p>这里只匹配通配符 <code>.</code>，类似于基础搜索，但是如果遇到了通配符，要搜索当前节点的<strong>所有子节点</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// KeysWithPattern 搜索模式为 pattern 的所有键</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">KeysWithPattern</span><span class="hljs-params">(pattern <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;<br>res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>)<br>t.patternTraverse(t.root, <span class="hljs-string">&quot;&quot;</span>, pattern, <span class="hljs-number">0</span>, &amp;res)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">patternTraverse</span><span class="hljs-params">(node *TrieNode, path <span class="hljs-keyword">string</span>, pattern <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>, res *[]<span class="hljs-keyword">string</span>)</span></span> &#123;<br><span class="hljs-comment">// 匹配失败</span><br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// pattern 匹配完成</span><br><span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(pattern) &#123;<br><span class="hljs-keyword">if</span> node.Val != <span class="hljs-literal">nil</span> &#123;<br>*res = <span class="hljs-built_in">append</span>(*res, path)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>c := pattern[i]<br><span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br><span class="hljs-comment">// 用回溯法匹配任意字符（搜索所有子节点）</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; R; j++ &#123;<br>path += <span class="hljs-keyword">string</span>(j)<br>t.patternTraverse(node.Children[j], path, pattern, i+<span class="hljs-number">1</span>, res)<br>path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>path += <span class="hljs-keyword">string</span>(c)<br>t.patternTraverse(node.Children[<span class="hljs-keyword">int</span>(c)], path, pattern, i+<span class="hljs-number">1</span>, res)<br>path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模式-pattern-是否存在"><a href="#模式-pattern-是否存在" class="headerlink" title="模式 pattern 是否存在"></a>模式 <code>pattern</code> 是否存在</h3><p>类似基本搜索，加入了对通配符的特殊判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HasKeyWithPattern 判断是和否存在模式为 pattern 的键</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">HasKeyWithPattern</span><span class="hljs-params">(pattern <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> t.hasKeyWithPattern(t.root, pattern, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-comment">// 从 node 节点开始匹配 pattern[i..]，返回是否成功匹配</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">hasKeyWithPattern</span><span class="hljs-params">(node *TrieNode, pattern <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(pattern) &#123;<br><span class="hljs-keyword">return</span> node.Val != <span class="hljs-literal">nil</span><br>&#125;<br><br>c := pattern[i]<br><br><span class="hljs-comment">// 不是通配符，则从对应的子节点开始匹配</span><br><span class="hljs-keyword">if</span> c != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br><span class="hljs-keyword">return</span> t.hasKeyWithPattern(node.Children[<span class="hljs-keyword">int</span>(c)], pattern, i+<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 是通配符，尝试匹配所有字符</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; R; j++ &#123;<br><span class="hljs-keyword">if</span> t.hasKeyWithPattern(node.Children[j], pattern, i+<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>按照给定的 <code>key</code> 的路径遍历前缀树，遇到空节点就新建一个，直到遍历完 <code>key</code>，将值储存在最后的节点中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Put 在 map 中添加或修改键值对</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">Put</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">if</span> !t.ContainsKey(key) &#123;<br>t.Size++<br>&#125;<br>t.root = t.put(t.root, key, val, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-comment">// 向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">put</span><span class="hljs-params">(node *TrieNode, key <span class="hljs-keyword">string</span>, val <span class="hljs-keyword">interface</span>&#123;&#125;, i <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TrieNode</span></span> &#123;<br><span class="hljs-comment">// 如果树枝不存在，新建</span><br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>node = <span class="hljs-built_in">new</span>(TrieNode)<br>&#125;<br><span class="hljs-comment">// key 的路径已插入完成，将值 val 存入节点</span><br><span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(key) &#123;<br>node.Val = val<br><span class="hljs-keyword">return</span> node<br>&#125;<br><br>c := key[i]<br><span class="hljs-comment">// 递归插入子节点，并接收返回值</span><br>node.Children[<span class="hljs-keyword">int</span>(c)] = t.put(node.Children[<span class="hljs-keyword">int</span>(c)], key, val, i+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>也是先遍历到 <code>key</code> 所在的节点，将这个节点储存的值设空，然后在后序位置清理递归路径上的孤儿节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Remove 在 Map 中删除 key</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">Remove</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> !t.ContainsKey(key) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>t.root = t.remove(t.root, key, <span class="hljs-number">0</span>)<br>t.Size--<br>&#125;<br><br><span class="hljs-comment">// 在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">remove</span><span class="hljs-params">(node *TrieNode, key <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TrieNode</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// 找到了 key 对应的 TrieNode，删除 val</span><br><span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(key) &#123;<br>node.Val = <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c := key[i]<br>node.Children[<span class="hljs-keyword">int</span>(c)] = t.remove(node.Children[<span class="hljs-keyword">int</span>(c)], key, i+<span class="hljs-number">1</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 在后序位置上清理递归路径上的节点</span><br><br>    <span class="hljs-comment">// 如果节点储存了值（说明此节点代表了别的单词），则不需要删除</span><br><span class="hljs-keyword">if</span> node.Val != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> node<br>&#125;<br>    <span class="hljs-comment">// 只要存在子节点，也不需要被删除</span><br><span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; R; c++ &#123;<br><span class="hljs-keyword">if</span> node.Children[c] != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> node<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">// 既没有储存值，也没有子节点，那就可以删除这个节点了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode：实现-Trie-前缀树"><a href="#LeetCode：实现-Trie-前缀树" class="headerlink" title="LeetCode：实现 Trie (前缀树)"></a>LeetCode：实现 Trie (前缀树)</h2><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p><p>直接复制粘贴，嵌套一层即可。</p><p>这里不需要用到 <code>TrieMap</code> 节点中储存的值，只要它不是空的就行了，设为 true。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Trie <span class="hljs-keyword">struct</span> &#123;<br>trieMap *TrieMap<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">Trie</span></span> &#123;<br>    <span class="hljs-keyword">return</span> Trie&#123;trieMap: &amp;TrieMap&#123;<br>Size: <span class="hljs-number">0</span>,<br>root: <span class="hljs-literal">nil</span>,<br>&#125;&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span> <span class="hljs-title">Insert</span><span class="hljs-params">(word <span class="hljs-keyword">string</span>)</span></span>  &#123;<br>this.trieMap.Put(word, <span class="hljs-literal">true</span>)  <span class="hljs-comment">// 节点可以储存任意值</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span> <span class="hljs-title">Search</span><span class="hljs-params">(word <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> this.trieMap.ContainsKey(word)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Trie)</span> <span class="hljs-title">StartsWith</span><span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> this.trieMap.HasKeyWithPrefix(prefix)<br>&#125;<br><br><span class="hljs-keyword">type</span> TrieMap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">/* 见上文 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode：单词替换"><a href="#LeetCode：单词替换" class="headerlink" title="LeetCode：单词替换"></a>LeetCode：单词替换</h2><p><a href="https://leetcode-cn.com/problems/replace-words/">https://leetcode-cn.com/problems/replace-words/</a></p><p>将所有词根放入前缀树中，然后对于句子中所有的单词都查找它的最短前缀，替换回去即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">replaceWords</span><span class="hljs-params">(dictionary []<span class="hljs-keyword">string</span>, sentence <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    m := TrieMap&#123;<span class="hljs-number">0</span>, <span class="hljs-literal">nil</span>&#125;<br>    <span class="hljs-comment">// 将词根放入前缀树中</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> dictionary &#123;<br>        m.Put(v, <span class="hljs-literal">true</span>)<br>    &#125;<br><br>    words := strings.Fields(sentence)<br>    sb := &amp;strings.Builder&#123;&#125;<br>    <span class="hljs-comment">// 查找每个单词的最短前缀</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(words); i++ &#123;<br>        prefix := m.ShortestPrefixOf(words[i])<br>        <span class="hljs-keyword">if</span> prefix == <span class="hljs-string">&quot;&quot;</span> &#123;<br>            sb.WriteString(words[i])<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sb.WriteString(prefix)<br>        &#125;<br>        <br>        <span class="hljs-comment">// 单词之间加上空格</span><br>        <span class="hljs-keyword">if</span> i != <span class="hljs-built_in">len</span>(words) - <span class="hljs-number">1</span> &#123;<br>            sb.WriteString(<span class="hljs-string">&quot; &quot;</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sb.String()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode：添加与搜索单词-数据结构设计"><a href="#LeetCode：添加与搜索单词-数据结构设计" class="headerlink" title="LeetCode：添加与搜索单词 - 数据结构设计"></a>LeetCode：添加与搜索单词 - 数据结构设计</h2><p><a href="https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/">https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/</a></p><p>这题就是我们已经实现好的功能，嵌套一层即可。注：直接套用代码会超时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> WordDictionary <span class="hljs-keyword">struct</span> &#123;<br>    trieMap *TrieMap<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">WordDictionary</span></span> &#123;<br>    <span class="hljs-keyword">return</span> WordDictionary&#123;trieMap: &amp;TrieMap&#123;<br>Size: <span class="hljs-number">0</span>,<br>root: <span class="hljs-literal">nil</span>,<br>&#125;&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *WordDictionary)</span> <span class="hljs-title">AddWord</span><span class="hljs-params">(word <span class="hljs-keyword">string</span>)</span></span>  &#123;<br>    this.trieMap.Put(word, <span class="hljs-literal">true</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *WordDictionary)</span> <span class="hljs-title">Search</span><span class="hljs-params">(word <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> this.trieMap.HasKeyWithPattern(word)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="LeetCode：键值映射"><a href="#LeetCode：键值映射" class="headerlink" title="LeetCode：键值映射"></a>LeetCode：键值映射</h2><p><a href="https://leetcode-cn.com/problems/map-sum-pairs/">https://leetcode-cn.com/problems/map-sum-pairs/</a></p><p>这题用到了节点储存的值，类型是 int，因此在取出来的时候记得使用类型断言。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MapSum <span class="hljs-keyword">struct</span> &#123;<br>    trieMap *TrieMap<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">MapSum</span></span> &#123;<br>    <span class="hljs-keyword">return</span> MapSum&#123;trieMap: &amp;TrieMap&#123;<br>Size: <span class="hljs-number">0</span>,<br>root: <span class="hljs-literal">nil</span>,<br>&#125;&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MapSum)</span> <span class="hljs-title">Insert</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>, val <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    this.trieMap.Put(key, val)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *MapSum)</span> <span class="hljs-title">Sum</span><span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    keys := this.trieMap.KeysWithPrefix(prefix)<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> keys &#123;<br>        res += this.trieMap.Get(k).(<span class="hljs-keyword">int</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> R = <span class="hljs-number">256</span><br><br><span class="hljs-keyword">type</span> TrieNode <span class="hljs-keyword">struct</span> &#123;<br>Val      <span class="hljs-keyword">interface</span>&#123;&#125;<br>Children [R]*TrieNode<br>&#125;<br><br><span class="hljs-keyword">type</span> TrieMap <span class="hljs-keyword">struct</span> &#123;<br>Size <span class="hljs-keyword">int</span><br>root *TrieNode<br>&#125;<br><br><span class="hljs-comment">// GetNode 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">GetNode</span><span class="hljs-params">(node *TrieNode, key <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">TrieNode</span></span> &#123;<br>p := node<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(key); i++ &#123;<br><span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 无法继续向下搜索</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>c := key[i]<br>p = p.Children[<span class="hljs-keyword">int</span>(c)]<br>&#125;<br><span class="hljs-keyword">return</span> p<br>&#125;<br><br><span class="hljs-comment">// Get 搜索 key 对应的值，不存在则返回 null</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>x := t.GetNode(t.root, key)<br><br><span class="hljs-comment">// x 为空或 x 的 val 字段为空都说明 key 没有对应的值</span><br><span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> || x.Val == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> x.Val<br>&#125;<br><br><span class="hljs-comment">// ContainsKey 判断 key 是否存在在 Map 中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">ContainsKey</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> t.Get(key) != <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// HasKeyWithPrefix 判断是否存在前缀为 prefix 的键</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">HasKeyWithPrefix</span><span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> t.GetNode(t.root, prefix) != <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// ShortestPrefixOf 在所有键中寻找 query 的最短前缀</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">ShortestPrefixOf</span><span class="hljs-params">(query <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>p := t.root<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(query); i++ &#123;<br><span class="hljs-comment">// 无法向下搜索</span><br><span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 找到一个键是 query 的前缀</span><br><span class="hljs-keyword">if</span> p.Val != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> query[:i]<br>&#125;<br><br><span class="hljs-comment">// 继续向下搜索</span><br>c := query[i]<br>p = p.Children[<span class="hljs-keyword">int</span>(c)]<br>&#125;<br><br><span class="hljs-comment">// query 本身就是一个键</span><br><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &amp;&amp; p.Val != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> query<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// LongestPrefixOf 在所有键中寻找 query 的最长前缀</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">LongestPrefixOf</span><span class="hljs-params">(query <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>p := t.root<br>maxLen := <span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(query); i++ &#123;<br><span class="hljs-comment">// 无法向下搜索</span><br><span class="hljs-keyword">if</span> p == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br><span class="hljs-comment">// 找到一个键是 query 的前缀，更新前缀的最大长度</span><br><span class="hljs-keyword">if</span> p.Val != <span class="hljs-literal">nil</span> &#123;<br>maxLen = i<br>&#125;<br><br><span class="hljs-comment">// 向下搜索</span><br>c := query[i]<br>p = p.Children[<span class="hljs-keyword">int</span>(c)]<br>&#125;<br><br><span class="hljs-comment">// query 本身就是一个键</span><br><span class="hljs-keyword">if</span> p != <span class="hljs-literal">nil</span> &amp;&amp; p.Val != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> query<br>&#125;<br><br><span class="hljs-keyword">return</span> query[<span class="hljs-number">0</span>:maxLen]<br>&#125;<br><br><span class="hljs-comment">// KeysWithPrefix 搜索前缀为 prefix 的所有键</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">KeysWithPrefix</span><span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;<br>res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>)<br>x := t.GetNode(t.root, prefix)<br><span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> res<br>&#125;<br>t.prefixTraverse(x, prefix, &amp;res)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// 遍历以 node 节点为根的 Trie 树，找到所有键</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">prefixTraverse</span><span class="hljs-params">(node *TrieNode, path <span class="hljs-keyword">string</span>, res *[]<span class="hljs-keyword">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> node.Val != <span class="hljs-literal">nil</span> &#123;<br>*res = <span class="hljs-built_in">append</span>(*res, path)<br>&#125;<br><br><span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; R; c++ &#123;<br><span class="hljs-comment">// 做选择</span><br>path += <span class="hljs-keyword">string</span>(c)<br>t.prefixTraverse(node.Children[c], path, res)<br><span class="hljs-comment">// 撤销选择</span><br>path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// KeysWithPattern 搜索模式为 pattern 的所有键</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">KeysWithPattern</span><span class="hljs-params">(pattern <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;<br>res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>)<br>t.patternTraverse(t.root, <span class="hljs-string">&quot;&quot;</span>, pattern, <span class="hljs-number">0</span>, &amp;res)<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">patternTraverse</span><span class="hljs-params">(node *TrieNode, path <span class="hljs-keyword">string</span>, pattern <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>, res *[]<span class="hljs-keyword">string</span>)</span></span> &#123;<br><span class="hljs-comment">// 匹配失败</span><br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// pattern 匹配完成</span><br><span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(pattern) &#123;<br><span class="hljs-keyword">if</span> node.Val != <span class="hljs-literal">nil</span> &#123;<br>*res = <span class="hljs-built_in">append</span>(*res, path)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>c := pattern[i]<br><span class="hljs-keyword">if</span> c == <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br><span class="hljs-comment">// 用回溯法匹配任意字符</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; R; j++ &#123;<br>path += <span class="hljs-keyword">string</span>(j)<br>t.patternTraverse(node.Children[j], path, pattern, i+<span class="hljs-number">1</span>, res)<br>path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>path += <span class="hljs-keyword">string</span>(c)<br>t.patternTraverse(node.Children[<span class="hljs-keyword">int</span>(c)], path, pattern, i+<span class="hljs-number">1</span>, res)<br>path = path[:<span class="hljs-built_in">len</span>(path)<span class="hljs-number">-1</span>]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// HasKeyWithPattern 判断是和否存在模式为 pattern 的键</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">HasKeyWithPattern</span><span class="hljs-params">(pattern <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> t.hasKeyWithPattern(t.root, pattern, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-comment">// 从 node 节点开始匹配 pattern[i..]，返回是否成功匹配</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">hasKeyWithPattern</span><span class="hljs-params">(node *TrieNode, pattern <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(pattern) &#123;<br><span class="hljs-keyword">return</span> node.Val != <span class="hljs-literal">nil</span><br>&#125;<br><br>c := pattern[i]<br><br><span class="hljs-comment">// 不是通配符，则从对应的子节点开始匹配</span><br><span class="hljs-keyword">if</span> c != <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br><span class="hljs-keyword">return</span> t.hasKeyWithPattern(node.Children[<span class="hljs-keyword">int</span>(c)], pattern, i+<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">// 是通配符，尝试匹配所有字符</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; R; j++ &#123;<br><span class="hljs-keyword">if</span> t.hasKeyWithPattern(node.Children[j], pattern, i+<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// Put 在 map 中添加或修改键值对</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">Put</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>, val <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">if</span> !t.ContainsKey(key) &#123;<br>t.Size++<br>&#125;<br>t.root = t.put(t.root, key, val, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-comment">// 向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">put</span><span class="hljs-params">(node *TrieNode, key <span class="hljs-keyword">string</span>, val <span class="hljs-keyword">interface</span>&#123;&#125;, i <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TrieNode</span></span> &#123;<br><span class="hljs-comment">// 如果树枝不存在，新建</span><br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>node = <span class="hljs-built_in">new</span>(TrieNode)<br>&#125;<br><span class="hljs-comment">// key 的路径已插入完成，将值 val 存入节点</span><br><span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(key) &#123;<br>node.Val = val<br><span class="hljs-keyword">return</span> node<br>&#125;<br><br>c := key[i]<br><span class="hljs-comment">// 递归插入子节点，并接收返回值</span><br>node.Children[<span class="hljs-keyword">int</span>(c)] = t.put(node.Children[<span class="hljs-keyword">int</span>(c)], key, val, i+<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> node<br>&#125;<br><br><span class="hljs-comment">// Remove 在 Map 中删除 key</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">Remove</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> !t.ContainsKey(key) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>t.root = t.remove(t.root, key, <span class="hljs-number">0</span>)<br>t.Size--<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *TrieMap)</span> <span class="hljs-title">remove</span><span class="hljs-params">(node *TrieNode, key <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TrieNode</span></span> &#123;<br><span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// 找到了 key 对应的 TrieNode，删除 val</span><br><span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(key) &#123;<br>node.Val = <span class="hljs-literal">nil</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>c := key[i]<br>node.Children[<span class="hljs-keyword">int</span>(c)] = t.remove(node.Children[<span class="hljs-keyword">int</span>(c)], key, i+<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> node.Val != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> node<br>&#125;<br><span class="hljs-keyword">for</span> c := <span class="hljs-number">0</span>; c &lt; R; c++ &#123;<br><span class="hljs-keyword">if</span> node.Children[c] != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> node<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数据结构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现 LFU 缓存算法</title>
    <link href="/leetcode/fucking-algorithm/lfu/"/>
    <url>/leetcode/fucking-algorithm/lfu/</url>
    
    <content type="html"><![CDATA[<h1 id="实现-LFU-缓存算法"><a href="#实现-LFU-缓存算法" class="headerlink" title="实现 LFU 缓存算法"></a>实现 LFU 缓存算法</h1><p><a href="https://leetcode-cn.com/problems/lfu-cache/">https://leetcode-cn.com/problems/lfu-cache/</a></p><p><a href="https://mp.weixin.qq.com/s/oXv03m1J8TwtHwMJEZ1ApQ">https://mp.weixin.qq.com/s/oXv03m1J8TwtHwMJEZ1ApQ</a></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>上一个 LRU 只需要替换最长时间未使用的，因此只需要一个哈希链表维护时序信息就够了。</p><p>而 LFU 需要维护频次信息，删除时如果有多个频次相同的，还要删除最长时间未使用的。</p><ul><li>调用 <code>get(key)</code> 方法时，要返回该 <code>key</code> 对应的 <code>val</code>：使用哈希表 <code>keyToVal</code></li><li>只要用 <code>get</code> 或者 <code>put</code> 方法访问一次某个 <code>key</code>，该 <code>key</code> 的 <code>freq</code> 就要加一：使用哈希表 <code>keyToFreq</code> 快速操作对应的频率</li><li>要将 <code>freq</code> 最小的 <code>key</code> 删除：<ol><li>要得知最小的 <code>freq</code> 是多少：用一个变量 <code>minFreq</code> 储存</li><li>要得知哪些 <code>key</code> 的频次是 <code>freq</code>：用哈希表 <code>freqToKeys</code> 储存 <code>freq</code> 对应的<strong>所有</strong> <code>key</code></li><li>如果最小 <code>freq</code> 有多个 <code>key</code>，删除最长时间未使用的：类似 LRU，用哈希链表储存 <code>key</code></li><li>要快速删除 <code>key</code> 列表中的任意一个，因为它频次更新为 <code>freq + 1</code>后，应该从 <code>freqToKeys[freq]</code> 中删除，并加入到 <code>freqToKeys[freq + 1]</code> 中：还是类似 LRU，用哈希链表储存 <code>key</code></li></ol></li></ul><p>至此，可以写出 LFU 所需要的所有数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LFUCache <span class="hljs-keyword">struct</span> &#123;<br>    keyToVal  <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>             <span class="hljs-comment">// key 映射为 val，用于记录 key 的值</span><br>    keyToFreq <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>             <span class="hljs-comment">// key 映射为 freq，用于记录 key 的频率</span><br>    freqToKeys <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*LinkedHashSet  <span class="hljs-comment">// freq 映射为 key 的哈希链表，用于找到最小频率且包含时序信息的 key</span><br><br>    minFreq <span class="hljs-keyword">int</span>  <span class="hljs-comment">// 记录最小频次</span><br>    <span class="hljs-built_in">cap</span>     <span class="hljs-keyword">int</span>  <span class="hljs-comment">// 记录最大容量</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h2><h3 id="哈希链表实现"><a href="#哈希链表实现" class="headerlink" title="哈希链表实现"></a>哈希链表实现</h3><p>Golang 没有内置的哈希链表实现，按照 LRU 中的写法再实现一次</p><p>实现双链表和链表节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 链表节点类 */</span><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    Key, Value <span class="hljs-keyword">int</span><br>    Next, Prev *Node<br>&#125;<br><br><span class="hljs-comment">/* 双链表类 */</span><br><span class="hljs-keyword">type</span> LinkedList <span class="hljs-keyword">struct</span> &#123;<br>    Head, Tail *Node<br>    Len <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">/* 双链表类构造方法 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewList</span><span class="hljs-params">()</span> <span class="hljs-title">LinkedList</span></span> &#123;<br>    head := <span class="hljs-built_in">new</span>(Node)<br>    tail := <span class="hljs-built_in">new</span>(Node)<br>    head.Next = tail<br>    tail.Prev = head<br>    <span class="hljs-keyword">return</span> LinkedList&#123;head, tail, <span class="hljs-number">0</span>&#125;<br>&#125;<br><br><span class="hljs-comment">/* 向双链表尾部添加节点 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedList)</span> <span class="hljs-title">AddLast</span><span class="hljs-params">(x *Node)</span></span> &#123;<br>    x.Prev = this.Tail.Prev<br>    x.Next = this.Tail<br><br>    this.Tail.Prev.Next = x<br>    this.Tail.Prev = x<br><br>    this.Len++<br>&#125;<br><br><span class="hljs-comment">/* 删除双链表特定节点 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedList)</span> <span class="hljs-title">Remove</span><span class="hljs-params">(x *Node)</span></span> &#123;<br>    x.Prev.Next = x.Next<br>    x.Next.Prev = x.Prev<br>    this.Len--<br>&#125;<br><br><span class="hljs-comment">/* 删除双链表头部节点并返回 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedList)</span> <span class="hljs-title">RemoveFirst</span><span class="hljs-params">()</span> *<span class="hljs-title">Node</span></span> &#123;<br>    <span class="hljs-keyword">if</span> this.Head.Next == this.Tail &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    x := this.Head.Next<br>    this.Remove(x)<br><br>    <span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>根据双链表，实现哈希链表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 哈希链表类 */</span><br><span class="hljs-keyword">type</span> LinkedHashSet <span class="hljs-keyword">struct</span> &#123;<br>    keyToNode <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*Node<br>    cache LinkedList<br>&#125;<br><br><span class="hljs-comment">/* 哈希链表类构造方法 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLinkedHashSet</span><span class="hljs-params">()</span> *<span class="hljs-title">LinkedHashSet</span></span> &#123;<br>    <span class="hljs-keyword">return</span> &amp;LinkedHashSet&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*Node), NewList()&#125;<br>&#125;<br><br><span class="hljs-comment">/* 向哈希链表添加元素 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedHashSet)</span> <span class="hljs-title">AddRecently</span><span class="hljs-params">(key, val <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    x := &amp;Node&#123;key, val, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    this.cache.AddLast(x)<br>    this.keyToNode[key] = x<br>&#125;<br><br><span class="hljs-comment">/* 删除哈希链表指定元素 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedHashSet)</span> <span class="hljs-title">DeleteKey</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    x := this.keyToNode[key]<br>    this.cache.Remove(x)<br>    <span class="hljs-built_in">delete</span>(this.keyToNode, key)<br>&#125;<br><br><span class="hljs-comment">/* 删除哈希链表头部元素 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedHashSet)</span> <span class="hljs-title">DeleteLeastRecently</span><span class="hljs-params">()</span> *<span class="hljs-title">Node</span></span> &#123;<br>    detetedNode := this.cache.RemoveFirst()<br>    <span class="hljs-built_in">delete</span>(this.keyToNode, detetedNode.Key)<br>    <span class="hljs-keyword">return</span> detetedNode<br>&#125;<br><br><span class="hljs-comment">/* 哈希链表长度 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedHashSet)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> this.cache.Len<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现-LFU"><a href="#实现-LFU" class="headerlink" title="实现 LFU"></a>实现 LFU</h3><p>实现 LFU 时，遇到跟频次有关的操作，先抽象为一个函数，后面再去实现函数具体逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> LFUCache <span class="hljs-keyword">struct</span> &#123;<br>    keyToVal  <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>             <span class="hljs-comment">// key 映射为 val，用于记录 key 的值</span><br>    keyToFreq <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>             <span class="hljs-comment">// key 映射为 freq，用于记录 key 的频率</span><br>    freqToKeys <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*LinkedHashSet  <span class="hljs-comment">// freq 映射为 key 的哈希列表，用于找到最小频率且包含时序信息的 key</span><br><br>    minFreq <span class="hljs-keyword">int</span>  <span class="hljs-comment">// 记录最小频次</span><br>    <span class="hljs-built_in">cap</span>     <span class="hljs-keyword">int</span>  <span class="hljs-comment">// 记录最大容量</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">LFUCache</span></span> &#123;<br>    keyToVal := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    keyToFreq := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    freqToKeys := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*LinkedHashSet)<br><br>    <span class="hljs-keyword">return</span> LFUCache&#123;keyToVal, keyToFreq, freqToKeys, <span class="hljs-number">0</span>, capacity&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LFUCache)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> _, ok := this.keyToVal[key]; !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    this.increaseFreq(key)  <span class="hljs-comment">// 增加 key 对应的频率</span><br>    <span class="hljs-keyword">return</span> this.keyToVal[key]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LFUCache)</span> <span class="hljs-title">Put</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>, value <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    <span class="hljs-comment">// 注：测试用例有传入 0 容量的情况</span><br>    <span class="hljs-keyword">if</span> this.<span class="hljs-built_in">cap</span> &lt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果 key 存在，只用更新它的 value，且增加对应频率</span><br>    <span class="hljs-keyword">if</span> _, ok := this.keyToVal[key]; ok &#123;<br>        this.keyToVal[key] = value<br>        this.increaseFreq(key)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果超出容量，移除最小频率的 key</span><br>    <span class="hljs-keyword">if</span> this.<span class="hljs-built_in">cap</span> &lt;= <span class="hljs-built_in">len</span>(this.keyToVal) &#123;<br>        this.removeMinFreqKey()<br>    &#125;<br><br>    <span class="hljs-comment">// 插入 key 和 val</span><br>    this.keyToVal[key] = value<br>    this.keyToFreq[key] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> _, ok := this.freqToKeys[<span class="hljs-number">1</span>]; !ok &#123;<br>        this.freqToKeys[<span class="hljs-number">1</span>] = NewLinkedHashSet()<br>    &#125;<br>    this.freqToKeys[<span class="hljs-number">1</span>].AddRecently(key, value)<br>    this.minFreq = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将跟新频率、移除最小频率元素的两个方法抽象了出来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 两个频次相关的实用函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LFUCache)</span> <span class="hljs-title">removeMinFreqKey</span><span class="hljs-params">()</span></span> &#123;<br>    keyList := this.freqToKeys[this.minFreq]<br><br>    deletedNode := keyList.DeleteLeastRecently()<br>    <span class="hljs-keyword">if</span> keyList.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">delete</span>(this.freqToKeys, this.minFreq)<br>        <span class="hljs-comment">// 由于此方法只会再插入新元素时调用，而插入后 minFreq 一定会更新为 1，因此这里不需要更新 minFreq 的值</span><br>    &#125;<br><br>    <span class="hljs-built_in">delete</span>(this.keyToVal, deletedNode.Key)<br>    <span class="hljs-built_in">delete</span>(this.keyToFreq, deletedNode.Key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LFUCache)</span> <span class="hljs-title">increaseFreq</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    freq := this.keyToFreq[key]<br>    this.keyToFreq[key] = freq + <span class="hljs-number">1</span>  <span class="hljs-comment">// 更新对应的频率</span><br><br>    <span class="hljs-comment">// 在新的频率链表中加上它</span><br>    <span class="hljs-keyword">if</span> _, ok := this.freqToKeys[freq + <span class="hljs-number">1</span>]; !ok &#123;<br>        this.freqToKeys[freq + <span class="hljs-number">1</span>] = NewLinkedHashSet()<br>    &#125;<br>    this.freqToKeys[freq + <span class="hljs-number">1</span>].AddRecently(key, this.keyToVal[key])<br><br>    <span class="hljs-comment">// 在旧的频率链表中删除它</span><br>    this.freqToKeys[freq].DeleteKey(key)<br>    <span class="hljs-keyword">if</span> this.freqToKeys[freq].Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">delete</span>(this.freqToKeys, freq)<br>        <span class="hljs-keyword">if</span> freq == this.minFreq &#123;<br>            this.minFreq++<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 链表节点类 */</span><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    Key, Value <span class="hljs-keyword">int</span><br>    Next, Prev *Node<br>&#125;<br><br><span class="hljs-comment">/* 双链表类 */</span><br><span class="hljs-keyword">type</span> LinkedList <span class="hljs-keyword">struct</span> &#123;<br>    Head, Tail *Node<br>    Len <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">/* 双链表类构造方法 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewList</span><span class="hljs-params">()</span> <span class="hljs-title">LinkedList</span></span> &#123;<br>    head := <span class="hljs-built_in">new</span>(Node)<br>    tail := <span class="hljs-built_in">new</span>(Node)<br>    head.Next = tail<br>    tail.Prev = head<br>    <span class="hljs-keyword">return</span> LinkedList&#123;head, tail, <span class="hljs-number">0</span>&#125;<br>&#125;<br><br><span class="hljs-comment">/* 向双链表尾部添加节点 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedList)</span> <span class="hljs-title">AddLast</span><span class="hljs-params">(x *Node)</span></span> &#123;<br>    x.Prev = this.Tail.Prev<br>    x.Next = this.Tail<br><br>    this.Tail.Prev.Next = x<br>    this.Tail.Prev = x<br><br>    this.Len++<br>&#125;<br><br><span class="hljs-comment">/* 删除双链表特定节点 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedList)</span> <span class="hljs-title">Remove</span><span class="hljs-params">(x *Node)</span></span> &#123;<br>    x.Prev.Next = x.Next<br>    x.Next.Prev = x.Prev<br>    this.Len--<br>&#125;<br><br><span class="hljs-comment">/* 删除双链表头部节点并返回 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedList)</span> <span class="hljs-title">RemoveFirst</span><span class="hljs-params">()</span> *<span class="hljs-title">Node</span></span> &#123;<br>    <span class="hljs-keyword">if</span> this.Head.Next == this.Tail &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    x := this.Head.Next<br>    this.Remove(x)<br><br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">/* 哈希链表类 */</span><br><span class="hljs-keyword">type</span> LinkedHashSet <span class="hljs-keyword">struct</span> &#123;<br>    keyToNode <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*Node<br>    cache LinkedList<br>&#125;<br><br><span class="hljs-comment">/* 哈希链表类构造方法 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewLinkedHashSet</span><span class="hljs-params">()</span> *<span class="hljs-title">LinkedHashSet</span></span> &#123;<br>    <span class="hljs-keyword">return</span> &amp;LinkedHashSet&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*Node), NewList()&#125;<br>&#125;<br><br><span class="hljs-comment">/* 向哈希链表添加元素 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedHashSet)</span> <span class="hljs-title">AddRecently</span><span class="hljs-params">(key, val <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    x := &amp;Node&#123;key, val, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    this.cache.AddLast(x)<br>    this.keyToNode[key] = x<br>&#125;<br><br><span class="hljs-comment">/* 删除哈希链表指定元素 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedHashSet)</span> <span class="hljs-title">DeleteKey</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    x := this.keyToNode[key]<br>    this.cache.Remove(x)<br>    <span class="hljs-built_in">delete</span>(this.keyToNode, key)<br>&#125;<br><br><span class="hljs-comment">/* 删除哈希链表头部元素 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedHashSet)</span> <span class="hljs-title">DeleteLeastRecently</span><span class="hljs-params">()</span> *<span class="hljs-title">Node</span></span> &#123;<br>    detetedNode := this.cache.RemoveFirst()<br>    <span class="hljs-built_in">delete</span>(this.keyToNode, detetedNode.Key)<br>    <span class="hljs-keyword">return</span> detetedNode<br>&#125;<br><br><span class="hljs-comment">/* 哈希链表长度 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LinkedHashSet)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> this.cache.Len<br>&#125;<br><br><span class="hljs-keyword">type</span> LFUCache <span class="hljs-keyword">struct</span> &#123;<br>    keyToVal  <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>             <span class="hljs-comment">// key 映射为 val，用于记录 key 的值</span><br>    keyToFreq <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>             <span class="hljs-comment">// key 映射为 freq，用于记录 key 的频率</span><br>    freqToKeys <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*LinkedHashSet  <span class="hljs-comment">// freq 映射为 key 的哈希列表，用于找到最小频率且包含时序信息的 key</span><br><br>    minFreq <span class="hljs-keyword">int</span>  <span class="hljs-comment">// 记录最小频次</span><br>    <span class="hljs-built_in">cap</span>     <span class="hljs-keyword">int</span>  <span class="hljs-comment">// 记录最大容量</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">LFUCache</span></span> &#123;<br>    keyToVal := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    keyToFreq := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    freqToKeys := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*LinkedHashSet)<br><br>    <span class="hljs-keyword">return</span> LFUCache&#123;keyToVal, keyToFreq, freqToKeys, <span class="hljs-number">0</span>, capacity&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LFUCache)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> _, ok := this.keyToVal[key]; !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    this.increaseFreq(key)  <span class="hljs-comment">// 增加 key 对应的频率</span><br>    <span class="hljs-keyword">return</span> this.keyToVal[key]<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LFUCache)</span> <span class="hljs-title">Put</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>, value <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    <span class="hljs-comment">// 注：测试用例有传入 0 容量的情况</span><br>    <span class="hljs-keyword">if</span> this.<span class="hljs-built_in">cap</span> &lt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果 key 存在，只用更新它的 value，且增加对应频率</span><br>    <span class="hljs-keyword">if</span> _, ok := this.keyToVal[key]; ok &#123;<br>        this.keyToVal[key] = value<br>        this.increaseFreq(key)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 如果超出容量，移除最小频率的 key</span><br>    <span class="hljs-keyword">if</span> this.<span class="hljs-built_in">cap</span> &lt;= <span class="hljs-built_in">len</span>(this.keyToVal) &#123;<br>        this.removeMinFreqKey()<br>    &#125;<br><br>    <span class="hljs-comment">// 插入 key 和 val</span><br>    this.keyToVal[key] = value<br>    this.keyToFreq[key] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> _, ok := this.freqToKeys[<span class="hljs-number">1</span>]; !ok &#123;<br>        this.freqToKeys[<span class="hljs-number">1</span>] = NewLinkedHashSet()<br>    &#125;<br>    this.freqToKeys[<span class="hljs-number">1</span>].AddRecently(key, value)<br>    this.minFreq = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">/* 两个频次相关的实用函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LFUCache)</span> <span class="hljs-title">removeMinFreqKey</span><span class="hljs-params">()</span></span> &#123;<br>    keyList := this.freqToKeys[this.minFreq]<br><br>    deletedNode := keyList.DeleteLeastRecently()<br>    <span class="hljs-keyword">if</span> keyList.Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">delete</span>(this.freqToKeys, this.minFreq)<br>        <span class="hljs-comment">// 由于此方法只会再插入新元素时调用，而插入后 minFreq 一定会更新为 1，因此这里不需要更新 minFreq 的值</span><br>    &#125;<br><br>    <span class="hljs-built_in">delete</span>(this.keyToVal, deletedNode.Key)<br>    <span class="hljs-built_in">delete</span>(this.keyToFreq, deletedNode.Key)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LFUCache)</span> <span class="hljs-title">increaseFreq</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    freq := this.keyToFreq[key]<br>    this.keyToFreq[key] = freq + <span class="hljs-number">1</span>  <span class="hljs-comment">// 更新对应的频率</span><br><br>    <span class="hljs-comment">// 在新的频率链表中加上它</span><br>    <span class="hljs-keyword">if</span> _, ok := this.freqToKeys[freq + <span class="hljs-number">1</span>]; !ok &#123;<br>        this.freqToKeys[freq + <span class="hljs-number">1</span>] = NewLinkedHashSet()<br>    &#125;<br>    this.freqToKeys[freq + <span class="hljs-number">1</span>].AddRecently(key, this.keyToVal[key])<br><br>    <span class="hljs-comment">// 在旧的频率链表中删除它</span><br>    this.freqToKeys[freq].DeleteKey(key)<br>    <span class="hljs-keyword">if</span> this.freqToKeys[freq].Len() == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-built_in">delete</span>(this.freqToKeys, freq)<br>        <span class="hljs-keyword">if</span> freq == this.minFreq &#123;<br>            this.minFreq++<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LFUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * obj := Constructor(capacity);</span><br><span class="hljs-comment"> * param_1 := obj.Get(key);</span><br><span class="hljs-comment"> * obj.Put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数据结构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现 LRU 缓存算法</title>
    <link href="/leetcode/fucking-algorithm/lru/"/>
    <url>/leetcode/fucking-algorithm/lru/</url>
    
    <content type="html"><![CDATA[<h1 id="实现-LRU-缓存算法"><a href="#实现-LRU-缓存算法" class="headerlink" title="实现 LRU 缓存算法"></a>实现 LRU 缓存算法</h1><p><a href="https://leetcode-cn.com/problems/lru-cache/">https://leetcode-cn.com/problems/lru-cache/</a></p><p>链表有时序，插入删除快；哈希表查找快。结合这两种数据结构实现哈希链表。</p><ul><li>双链表负责按时序储存，可以做到从头部删除节点和从尾部加入节点，这样尾部的节点是最近使用过的，头部的是最长时间未使用的</li><li>哈希表负责查找特定节点，以便于查找、提升、删除链表任意一个元素</li></ul><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/* 首先实现双链表和链表节点 */</span><br><br><span class="hljs-comment">// 链表节点类</span><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;<br>    Key, Value <span class="hljs-keyword">int</span><br>    Next, Prev *Node<br>&#125;<br><br><span class="hljs-comment">// 双链表类：新元素从尾部加入，表头元素是最久未被使用的</span><br><span class="hljs-keyword">type</span> LinkedList <span class="hljs-keyword">struct</span> &#123;<br>    Head, Tail *Node<br>    Len <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// 双链表类构造方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewList</span><span class="hljs-params">()</span> <span class="hljs-title">LinkedList</span></span> &#123;<br>    head := <span class="hljs-built_in">new</span>(Node)<br>    tail := <span class="hljs-built_in">new</span>(Node)<br>    head.Next = tail<br>    tail.Prev = head<br>    <span class="hljs-keyword">return</span> LinkedList&#123;head, tail, <span class="hljs-number">0</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// 链表尾部添加节点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *LinkedList)</span> <span class="hljs-title">AddLast</span><span class="hljs-params">(x *Node)</span></span> &#123;<br>    x.Prev = list.Tail.Prev<br>    x.Next = list.Tail<br><br>    list.Tail.Prev.Next = x<br>    list.Tail.Prev = x<br><br>    list.Len++<br>&#125;<br><br><span class="hljs-comment">// 删除链表的节点 x</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *LinkedList)</span> <span class="hljs-title">Remove</span><span class="hljs-params">(x *Node)</span></span> &#123;<br>    x.Prev.Next = x.Next<br>    x.Next.Prev = x.Prev<br><br>    list.Len--<br>&#125;<br><br><span class="hljs-comment">// 删除链表第一个节点并返回（返回的节点用于获取 key value）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *LinkedList)</span> <span class="hljs-title">RemoveFirst</span><span class="hljs-params">()</span> *<span class="hljs-title">Node</span></span> &#123;<br>    <span class="hljs-keyword">if</span> list.Head.Next == list.Tail &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    first := list.Head.Next<br>    list.Remove(first)<br>    <span class="hljs-keyword">return</span> first<br>&#125;<br><br><br><span class="hljs-keyword">type</span> LRUCache <span class="hljs-keyword">struct</span> &#123;<br>    m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*Node   <span class="hljs-comment">// 把 key 映射到链表节点</span><br>    cache LinkedList<br>    <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">/* 定义几个 API 方法，屏蔽 map 和链表的操作细节 */</span><br><br><span class="hljs-comment">// 将某个 key 提升为最近使用的</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    x := this.m[key]       <span class="hljs-comment">// 找到 key 对应的节点</span><br>    this.cache.Remove(x)   <span class="hljs-comment">// 删除它</span><br>    this.cache.AddLast(x)  <span class="hljs-comment">// 再把它加到最后</span><br>&#125;<br><br><span class="hljs-comment">// 添加一个 key</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span> <span class="hljs-title">addRecently</span><span class="hljs-params">(key, val <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    x := Node&#123;key, val, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    this.cache.AddLast(&amp;x)<br>    this.m[key] = &amp;x<br>&#125;<br><br><span class="hljs-comment">// 删除 key</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span> <span class="hljs-title">deleteKey</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    x := this.m[key]<br>    this.cache.Remove(x)<br>    <span class="hljs-built_in">delete</span>(this.m, key)<br>&#125;<br><br><span class="hljs-comment">// 删除最久未使用的元素</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span> <span class="hljs-title">removeLeastRecently</span><span class="hljs-params">()</span></span> &#123;<br>    deletedNode := this.cache.RemoveFirst()<br>    k := deletedNode.Key<br>    <span class="hljs-built_in">delete</span>(this.m, k)<br>&#125;<br><br><span class="hljs-comment">/* LRU 方法 */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(capacity <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">LRUCache</span></span> &#123;<br>    <span class="hljs-keyword">return</span> LRUCache&#123;<span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*Node), NewList(), capacity&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> _, ok := this.m[key]; !ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    this.makeRecently(key)<br>    <span class="hljs-keyword">return</span> this.m[key].Value<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *LRUCache)</span> <span class="hljs-title">Put</span><span class="hljs-params">(key <span class="hljs-keyword">int</span>, value <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    <span class="hljs-comment">// 如果 key 存在，则更新 key 值并提升（相当于删了再加）</span><br>    <span class="hljs-keyword">if</span> _, ok := this.m[key]; ok &#123;<br>        this.deleteKey(key)<br>        this.addRecently(key, value)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 如果容量满了，删除最久未使用的</span><br>    <span class="hljs-keyword">if</span> this.<span class="hljs-built_in">cap</span> == this.cache.Len &#123;<br>        this.removeLeastRecently()<br>    &#125;<br>    this.addRecently(key, value)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数据结构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>O(1) 时间删除查找数组中的任意元素</title>
    <link href="/leetcode/fucking-algorithm/insert-delete-getrandom-o1/"/>
    <url>/leetcode/fucking-algorithm/insert-delete-getrandom-o1/</url>
    
    <content type="html"><![CDATA[<h1 id="O-1-时间删除查找数组中的任意元素"><a href="#O-1-时间删除查找数组中的任意元素" class="headerlink" title="O(1) 时间删除查找数组中的任意元素"></a>O(1) 时间删除查找数组中的任意元素</h1><p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">https://leetcode-cn.com/problems/split-array-largest-sum/</a></p><p>底层用数组实现，用哈希表记录一个元素在数组的索引。</p><ul><li><p>插入：检查哈希表，将元素插入数组尾部，更新哈希表</p></li><li><p>删除：通过哈希表寻到索引，和数组尾部元素交换，删除尾部元素，更新哈希表</p></li><li><p>获得随机元素：生成数组大小的随机数</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> RandomizedSet <span class="hljs-keyword">struct</span> &#123;<br>    nums []<span class="hljs-keyword">int</span><br>    valToIndex <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-title">RandomizedSet</span></span> &#123;<br>    <span class="hljs-keyword">return</span> RandomizedSet&#123;<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *RandomizedSet)</span> <span class="hljs-title">Insert</span><span class="hljs-params">(val <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> _, ok := this.valToIndex[val]; ok &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    this.valToIndex[val] = <span class="hljs-built_in">len</span>(this.nums)<br>    this.nums = <span class="hljs-built_in">append</span>(this.nums, val)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *RandomizedSet)</span> <span class="hljs-title">Remove</span><span class="hljs-params">(val <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> index, ok := this.valToIndex[val]; ok &#123;<br>        last := <span class="hljs-built_in">len</span>(this.nums) - <span class="hljs-number">1</span><br>        <span class="hljs-comment">// 交换尾部元素并更新哈希表</span><br>        this.nums[index] = this.nums[last]<br>        this.valToIndex[this.nums[index]] = index<br>        <span class="hljs-comment">// 删除元素以及哈希表的索引</span><br>        this.nums = this.nums[:last]<br>        <span class="hljs-built_in">delete</span>(this.valToIndex, val)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *RandomizedSet)</span> <span class="hljs-title">GetRandom</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    r := rand.Intn(<span class="hljs-built_in">len</span>(this.nums))<br>    <span class="hljs-keyword">return</span> this.nums[r]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数据结构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除有序数组的重复元素</title>
    <link href="/leetcode/fucking-algorithm/remove-duplicated-elements/"/>
    <url>/leetcode/fucking-algorithm/remove-duplicated-elements/</url>
    
    <content type="html"><![CDATA[<h1 id="删除有序数组的重复元素"><a href="#删除有序数组的重复元素" class="headerlink" title="删除有序数组的重复元素"></a>删除有序数组的重复元素</h1><p>此类题目都可以用快慢指针，快指针一直走，遇到重复的元素就跳过，否则赋值给慢指针且慢指针走一步，这样慢指针走过的路全都是不重复的了。</p><h2 id="删除有序数组中的重复项"><a href="#删除有序数组中的重复项" class="headerlink" title="删除有序数组中的重复项"></a>删除有序数组中的重复项</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    slow, fast := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> fast &lt; <span class="hljs-built_in">len</span>(nums) &#123;<br>        <span class="hljs-keyword">if</span> nums[fast] != nums[slow] &#123;<br>            slow++<br>            nums[slow] = nums[fast]<br>        &#125;<br>        fast++<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除排序链表中的重复元素"><a href="#删除排序链表中的重复元素" class="headerlink" title="删除排序链表中的重复元素"></a>删除排序链表中的重复元素</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></p><p>与上一题十分泪湿，只不过将数组换成了链表。末尾记得要将慢指针所指的节点以后的元素都删掉（断开链接）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    slow, fast := head, head<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> fast.Val != slow.Val &#123;<br>            slow = slow.Next<br>            slow.Val = fast.Val<br>        &#125;<br>        fast = fast.Next<br>    &#125;<br>    slow.Next = <span class="hljs-literal">nil</span>  <span class="hljs-comment">// 断开不重复部分和后面的链接</span><br>    <span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p><a href="https://leetcode-cn.com/problems/remove-element/">https://leetcode-cn.com/problems/remove-element/</a></p><p>快指针遇到要移除的元素就跳过，否则告诉慢指针，一样的道理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, val <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    slow, fast := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> fast &lt; <span class="hljs-built_in">len</span>(nums) &#123;<br>        <span class="hljs-keyword">if</span> nums[fast] != val &#123;<br>            nums[slow] = nums[fast]<br>            slow++<br>        &#125;<br>        fast++<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><p><a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p><p>快指针遇到 0 就跳过，否则告诉慢指针。完成后将慢指针以后的元素都变成 0 即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    slow, fast := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> fast &lt; <span class="hljs-built_in">len</span>(nums) &#123;<br>        <span class="hljs-keyword">if</span> nums[fast] != <span class="hljs-number">0</span> &#123;<br>            nums[slow] = nums[fast]<br>            slow++<br>        &#125;<br>        fast++<br>    &#125;<br>    <span class="hljs-keyword">for</span> slow &lt; <span class="hljs-built_in">len</span>(nums) &#123;<br>        nums[slow] = <span class="hljs-number">0</span><br>        slow++<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分割数组的最大值</title>
    <link href="/leetcode/fucking-algorithm/split-array-largest-sum/"/>
    <url>/leetcode/fucking-algorithm/split-array-largest-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="分割数组的最大值"><a href="#分割数组的最大值" class="headerlink" title="分割数组的最大值"></a>分割数组的最大值</h1><p><a href="https://leetcode-cn.com/problems/split-array-largest-sum/">https://leetcode-cn.com/problems/split-array-largest-sum/</a></p><h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><p>重新抽象问题，假设每个小数组和的最大值为 <code>max</code> 时，能把数组分割成 n 个，问题就变成了搜索一个最小的 <code>max</code>，使得能把数组分割成 m 个。 </p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, m <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    left, right := max(nums...), sum(nums...)<br><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        mid := left + (right - left) / <span class="hljs-number">2</span><br>        midValue := split(nums, mid)<br>        <span class="hljs-keyword">if</span> midValue &lt; m &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> midValue &gt; m &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left<br>&#125;<br><br><span class="hljs-comment">// 最大值为 max 时能分出的数组个数为 split(nums, max)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">split</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, max <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    count := <span class="hljs-number">0</span><br>    remains := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> remains - nums[i] &lt; <span class="hljs-number">0</span> &#123;<br>            remains = max<br>            count++<br>        &#125;<br>        remains -= nums[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> count<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &gt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        res += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分搜索的应用</title>
    <link href="/leetcode/fucking-algorithm/binary-search-application/"/>
    <url>/leetcode/fucking-algorithm/binary-search-application/</url>
    
    <content type="html"><![CDATA[<h1 id="二分搜索的应用"><a href="#二分搜索的应用" class="headerlink" title="二分搜索的应用"></a>二分搜索的应用</h1><p>将问题抽象成一个关于 <code>x</code> 的<strong>单调函数</strong> <code>f(x)</code>，问题就是让我们求一个 <code>x</code>，使得 <code>f(x) == target</code>，就可以使用二分搜索来寻找这个 <code>x</code> 值了。通常不仅要使得 <code>f(x) == target</code>，还要使得 <code>x</code> 最大或最小，这就是用二分搜索寻找边界值的问题。</p><p><img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%88%86%e8%bf%90%e7%94%a8/3.jpeg" alt="问题的抽象"></p><h2 id="爱吃香蕉的珂珂"><a href="#爱吃香蕉的珂珂" class="headerlink" title="爱吃香蕉的珂珂"></a>爱吃香蕉的珂珂</h2><p><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">https://leetcode-cn.com/problems/koko-eating-bananas/</a></p><p>题目让我们求吃香蕉的速度，那它就是自变量 <code>x</code>，吃香蕉所用的时间就是 <code>f(x)</code>，题目希望我们求得 <code>f(x) == H</code> 时 <code>x</code> 的最小值，就是寻找一个左边界。</p><p>把 <code>f(x)</code> 的逻辑实现出来，确定搜索区间的起点和终点，就可以用二分查找搜索了。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minEatingSpeed</span><span class="hljs-params">(piles []<span class="hljs-keyword">int</span>, h <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 起点：一次只吃一根香蕉 终点：一次最多吃掉最大那一堆香蕉</span><br>    left, right := <span class="hljs-number">1</span>, max(piles...)<br><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        mid := left + (right - left) / <span class="hljs-number">2</span><br>        midValue := f(mid, piles)<br>        <span class="hljs-keyword">if</span> midValue &lt; h &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> midValue &gt; h &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 由于不是搜索数组所以不会越界，只要搜索区间合理，一定能找出结果</span><br>    <span class="hljs-keyword">return</span> left<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>, piles []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    hours := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(piles); i++ &#123;<br>        hours += piles[i] / x<br>        <span class="hljs-keyword">if</span> piles[i] % x &gt; <span class="hljs-number">0</span> &#123;<br>            hours += <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hours<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &gt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="在-D-天内送达包裹的能力"><a href="#在-D-天内送达包裹的能力" class="headerlink" title="在 D 天内送达包裹的能力"></a>在 D 天内送达包裹的能力</h2><p><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/</a></p><p>这题十分类似，要注意的是搜索区间，最小运载能力就是运载最大货物的能力，而最大运载能力是一次将所有货物都运走。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shipWithinDays</span><span class="hljs-params">(weights []<span class="hljs-keyword">int</span>, days <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    left, right := max(weights...), sum(weights...)<br><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        mid := left + (right - left) / <span class="hljs-number">2</span><br>        midValue := f(mid, weights)<br>        <span class="hljs-keyword">if</span> midValue &lt; days &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> midValue &gt; days &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> left<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>, weights []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    days := <span class="hljs-number">0</span><br>    remains := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(weights); i++ &#123;<br>        <span class="hljs-keyword">if</span> remains - weights[i] &lt; <span class="hljs-number">0</span> &#123;<br>            remains = x<br>            days++<br>        &#125;<br>        remains -= weights[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> days<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &gt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        res += v<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/leetcode/fucking-algorithm/binary-search/"/>
    <url>/leetcode/fucking-algorithm/binary-search/</url>
    
    <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><a href="https://labuladong.gitee.io/algo/2/21/61/">https://labuladong.gitee.io/algo/2/21/61/</a></p><h2 id="基本二分查找：查找一个元素"><a href="#基本二分查找：查找一个元素" class="headerlink" title="基本二分查找：查找一个元素"></a>基本二分查找：查找一个元素</h2><p><a href="https://leetcode-cn.com/problems/binary-search/">https://leetcode-cn.com/problems/binary-search/</a></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>       <span class="hljs-comment">// 搜索区间两头都包含</span><br><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;                   <span class="hljs-comment">// while 循环中取等于号</span><br>        mid := left + (right - left) / <span class="hljs-number">2</span>  <span class="hljs-comment">// 防止 left+right 溢出</span><br>        <span class="hljs-keyword">if</span> nums[mid] == target &#123;<br>            <span class="hljs-keyword">return</span> mid<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;    <br>            left = mid + <span class="hljs-number">1</span>                <span class="hljs-comment">// 搜索区间两头都包含了，mid可以 +1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>               <span class="hljs-comment">// 搜索区间两头都包含了，mid可以 -1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查找左右侧边界"><a href="#查找左右侧边界" class="headerlink" title="查找左右侧边界"></a>查找左右侧边界</h2><ul><li>统一所有的二分查找为查找两头闭区间，左右指针初始化为 <code>0, len(nums) - 1</code></li><li>while 循环条件全都是  <code>left &lt;= right</code></li><li>所有的区间更新都是 <code>left = mid + 1</code> 或 <code>right = mid - 1</code></li><li>找到目标后不马上返回，而是收缩另一侧的边界（想要得到哪一侧，就收缩另一侧）</li><li>while 循环结束后返回想要的边界指针，需要判断有没有溢出、以及目标有没有找到。</li></ul><h2 id="实战：在排序数组中查找元素的第一个和最后一个位置"><a href="#实战：在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="实战：在排序数组中查找元素的第一个和最后一个位置"></a>实战：在排序数组中查找元素的第一个和最后一个位置</h2><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><p>分别以寻找左侧和右侧边界作为例子。注意，两段代码只有在有注释的地方不同，其余都是一样的。</p><p>这寻找左侧边界：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        mid := left + (right - left) / <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 不马上返回，锁定左侧边界</span><br>            right = mid - <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 边界条件判断、是否找到判断</span><br>    <span class="hljs-keyword">if</span> left &gt;= <span class="hljs-built_in">len</span>(nums) || nums[left] != target &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到左侧边界后，顺序寻找到右侧即可</span><br>    <span class="hljs-keyword">for</span> i := left; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] != target &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        right = i<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;left, right&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果改成寻找右边界：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchRange</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> left &lt;= right &#123;<br>        mid := left + (right - left) / <span class="hljs-number">2</span><br>        <br>        <span class="hljs-keyword">if</span> nums[mid] &lt; target &#123;<br>            left = mid + <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> nums[mid] &gt; target &#123;<br>            right = mid - <span class="hljs-number">1</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 不马上返回，锁定右侧边界</span><br>            left = mid + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 边界条件判断、是否找到判断</span><br>    <span class="hljs-keyword">if</span> right &lt; <span class="hljs-number">0</span> || nums[right] != target &#123;<br>        <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到右侧边界后，顺序寻找到左侧即可</span><br>    <span class="hljs-keyword">for</span> i := right; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">if</span> nums[i] != target &#123;<br>            <span class="hljs-keyword">break</span><br>        &#125;<br>        left = i<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;left, right&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针基础</title>
    <link href="/leetcode/fucking-algorithm/array-double-pointer/"/>
    <url>/leetcode/fucking-algorithm/array-double-pointer/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针基础"><a href="#双指针基础" class="headerlink" title="双指针基础"></a>双指针基础</h1><h2 id="两数之和-II-输入有序数组"><a href="#两数之和-II-输入有序数组" class="headerlink" title="两数之和 II - 输入有序数组"></a>两数之和 II - 输入有序数组</h2><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p><p>只要数组有序，就应该想到双指针技巧，一左一右不断向目标值逼近。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(numbers []<span class="hljs-keyword">int</span>, target <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(numbers) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        <span class="hljs-keyword">if</span> numbers[left] + numbers[right] == target &#123;<br>            <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;left+<span class="hljs-number">1</span>, right+<span class="hljs-number">1</span>&#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> numbers[left] + numbers[right] &lt; target &#123;<br>            left++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right--<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(s []<span class="hljs-keyword">byte</span>)</span></span>  &#123;<br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> left &lt; right &#123;<br>        s[left], s[right] = s[right], s[left]<br>        left++<br>        right--<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针：滑动窗口</title>
    <link href="/leetcode/fucking-algorithm/sliding-window/"/>
    <url>/leetcode/fucking-algorithm/sliding-window/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针：滑动窗口"><a href="#双指针：滑动窗口" class="headerlink" title="双指针：滑动窗口"></a>双指针：滑动窗口</h1><p>滑动窗口框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 滑动窗口算法框架 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">slidingWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; need, window;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) need[c]++;<br>    <br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span> (right &lt; s.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-comment">// c 是将移入窗口的字符</span><br>        <span class="hljs-keyword">char</span> c = s[right];<br>        <span class="hljs-comment">// 右移窗口</span><br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        ...<br><br>        <span class="hljs-comment">/*** debug 输出的位置 ***/</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;window: [%d, %d)\n&quot;</span>, left, right);<br>        <span class="hljs-comment">/********************/</span><br>        <br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (window needs shrink) &#123;<br>            <span class="hljs-comment">// d 是将移出窗口的字符</span><br>            <span class="hljs-keyword">char</span> d = s[left];<br>            <span class="hljs-comment">// 左移窗口</span><br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h2><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">https://leetcode-cn.com/problems/minimum-window-substring/</a></p><p>右指针一直前进，知道找齐所有的字符；找齐字符后再收缩左指针，尽量取最短的子串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minWindow</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, t <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    window := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">int</span>)  <span class="hljs-comment">// 记录当前窗口内的字符情况</span><br>    need := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">int</span>)    <span class="hljs-comment">// 记录需要的字符</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(t); i++ &#123;<br>        need[t[i]] += <span class="hljs-number">1</span><br>    &#125;<br><br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>  <span class="hljs-comment">// 左右指针</span><br>    valid := <span class="hljs-number">0</span>           <span class="hljs-comment">// 记录已找齐字母数量</span><br><br>    start, minLen := <span class="hljs-number">0</span>, math.MaxInt32<br><br>    <span class="hljs-keyword">for</span> right &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>        c := s[right]<br>        right++<br>        <br>        <span class="hljs-comment">// 如果需求这个字符，就记录它，并且</span><br>        <span class="hljs-keyword">if</span> val, ok := need[c]; ok &#123;<br>            window[c]++<br>            <span class="hljs-comment">// 判断它的数量是否已经足够</span><br>            <span class="hljs-keyword">if</span> window[c] == val &#123;<br>                valid++<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 在所有字母都已经找到时开始收缩窗口</span><br>        <span class="hljs-keyword">for</span> valid == <span class="hljs-built_in">len</span>(need) &#123;<br>            <span class="hljs-keyword">if</span> right - left &lt; minLen &#123;<br>                minLen = right - left<br>                start = left<br>            &#125;<br><br>            d := s[left]<br>            left++  <span class="hljs-comment">// 窗口收缩</span><br><br>            <span class="hljs-comment">// 每次收缩窗口兜要判断字符是否需求</span><br>            <span class="hljs-keyword">if</span> val, ok := need[d]; ok &#123;<br>                <span class="hljs-keyword">if</span> window[d] == val &#123;<br>                    valid--<br>                &#125;<br>                window[d]--<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> minLen == math.MaxInt32 &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> s[start : start+minLen]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h2><p><a href="https://leetcode-cn.com/problems/permutation-in-string/">https://leetcode-cn.com/problems/permutation-in-string/</a></p><p>还是类似的思路</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(s1 <span class="hljs-keyword">string</span>, s2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    window, need := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">int</span>), <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s1); i++ &#123;<br>        need[s1[i]]++<br>    &#125;<br><br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    valid := <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> right &lt; <span class="hljs-built_in">len</span>(s2) &#123;<br>        c := s2[right]<br>        right++<br><br>        <span class="hljs-comment">// 每处理一个字符，都要检查这个字符是不是需求的</span><br>        <span class="hljs-keyword">if</span> val, ok := need[c]; ok &#123;<br>            window[c]++<br>            <span class="hljs-keyword">if</span> window[c] == val &#123;<br>                valid++<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 左指针收缩条件：字符串太长</span><br>        <span class="hljs-keyword">for</span> right - left &gt;= <span class="hljs-built_in">len</span>(s1) &#123;<br>            <span class="hljs-keyword">if</span> valid == <span class="hljs-built_in">len</span>(need) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>            &#125;<br>            d := s2[left]<br>            left++<br>            <span class="hljs-comment">// 每处理一个字符，都要检查这个字符是不是需求的</span><br>            <span class="hljs-keyword">if</span> val, ok := need[d]; ok &#123;<br>                <span class="hljs-keyword">if</span> window[d] == val &#123;<br>                    valid--<br>                &#125;<br>                window[d]--<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h2><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p><p>一样的题，不过是要输出字符串的开始位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findAnagrams</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, p <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    window, need := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">int</span>), <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(p); i++ &#123;<br>        need[p[i]]++<br>    &#125;<br><br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    valid := <span class="hljs-number">0</span><br>    res := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">for</span> right &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>        c := s[right]<br>        right++<br><br>        <span class="hljs-keyword">if</span> val, ok := need[c]; ok &#123;<br>            window[c]++<br>            <span class="hljs-keyword">if</span> window[c] == val &#123;<br>                valid++<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> right - left &gt;= <span class="hljs-built_in">len</span>(p) &#123;<br>            <span class="hljs-keyword">if</span> valid == <span class="hljs-built_in">len</span>(need) &#123;<br>                res = <span class="hljs-built_in">append</span>(res, left)<br>            &#125;<br><br>            d := s[left]<br>            left++<br><br>            <span class="hljs-keyword">if</span> val, ok := need[d]; ok &#123;<br>                <span class="hljs-keyword">if</span> window[d] == val &#123;<br>                    valid--<br>                &#125;<br>                window[d]--<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><p>这题还要更简单一些，无重复字串直接查看窗口内的哈希表就好了，一旦右指针前进使得有字符重复就收缩左指针，直到没有重复位置，再计算新的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    window := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">byte</span>]<span class="hljs-keyword">int</span>)<br><br>    left, right := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    maxLen := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> right &lt; <span class="hljs-built_in">len</span>(s) &#123;<br>        c := s[right]<br>        right++<br>        window[c]++<br>        <br>        <span class="hljs-keyword">for</span> window[c] &gt; <span class="hljs-number">1</span> &#123;<br>            d := s[left]<br>            left++<br>            window[d]--<br>        &#125;<br>        <span class="hljs-keyword">if</span> right - left &gt; maxLen &#123;<br>            maxLen = right - left<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxLen<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维数组的花式遍历技巧</title>
    <link href="/leetcode/fucking-algorithm/fancy-array-iteration/"/>
    <url>/leetcode/fucking-algorithm/fancy-array-iteration/</url>
    
    <content type="html"><![CDATA[<h1 id="二维数组的花式遍历技巧"><a href="#二维数组的花式遍历技巧" class="headerlink" title="二维数组的花式遍历技巧"></a>二维数组的花式遍历技巧</h1><h2 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h2><p><a href="https://leetcode-cn.com/problems/rotate-image/">https://leetcode-cn.com/problems/rotate-image/</a></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rotate</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    n := <span class="hljs-built_in">len</span>(matrix)<br>    <span class="hljs-comment">// 对角线反转矩阵</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 反转每一行</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        reverse(matrix[i])<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(list []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(list) - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i &lt; j &#123;<br>        list[i], list[j] = list[j], list[i]<br>        i++<br>        j--<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h2><p><a href="https://leetcode-cn.com/problems/spiral-matrix/">https://leetcode-cn.com/problems/spiral-matrix/</a></p><p><img src="https://labuladong.gitee.io/algo/images/%e8%8a%b1%e5%bc%8f%e9%81%8d%e5%8e%86/6.png"></p><p>定义好这几个 bound，然后在它们的范围内螺旋遍历即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spiralOrder</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    upperBound, rightBound, lowerBound, leftBound := <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, m<span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>    result := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, m * n)<br>    count := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> count &lt; m * n &#123;<br>        <span class="hljs-keyword">if</span> upperBound &lt;= lowerBound &#123;<br>            <span class="hljs-keyword">for</span> i := leftBound; i &lt;= rightBound; i++ &#123;<br>                result[count] = matrix[upperBound][i]<br>                count++<br>            &#125;<br>            upperBound++<br>        &#125;<br>        <span class="hljs-keyword">if</span> rightBound &gt;= leftBound &#123;<br>            <span class="hljs-keyword">for</span> i := upperBound; i &lt;= lowerBound; i++ &#123;<br>                result[count] = matrix[i][rightBound]<br>                count++<br>            &#125;<br>            rightBound--<br>        &#125;<br>        <span class="hljs-keyword">if</span> lowerBound &gt;= upperBound &#123;<br>            <span class="hljs-keyword">for</span> i := rightBound; i &gt;= leftBound; i-- &#123;<br>                result[count] = matrix[lowerBound][i]<br>                count++<br>            &#125;<br>            lowerBound--<br>        &#125;<br>        <span class="hljs-keyword">if</span> leftBound &lt;= rightBound &#123;<br>            <span class="hljs-keyword">for</span> i := lowerBound; i &gt;= upperBound; i-- &#123;<br>                result[count] = matrix[i][leftBound]<br>                count++<br>            &#125;<br>            leftBound++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="螺旋矩阵-II"><a href="#螺旋矩阵-II" class="headerlink" title="螺旋矩阵 II"></a>螺旋矩阵 II</h2><p>就是刚刚那道题的反过程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateMatrix</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    matrix := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> matrix &#123;<br>        matrix[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    &#125;<br><br>    upperBound, rightBound, lowerBound, leftBound := <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span>, <span class="hljs-number">0</span><br>    count := <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> count &lt;= n * n &#123;<br>        <span class="hljs-keyword">if</span> upperBound &lt;= lowerBound &#123;<br>            <span class="hljs-keyword">for</span> i := leftBound; i &lt;= rightBound; i++ &#123;<br>                matrix[upperBound][i] = count<br>                count++<br>            &#125;<br>            upperBound++<br>        &#125;<br>        <span class="hljs-keyword">if</span> rightBound &gt;= leftBound &#123;<br>            <span class="hljs-keyword">for</span> i := upperBound; i &lt;= lowerBound; i++ &#123;<br>                matrix[i][rightBound] = count<br>                count++<br>            &#125;<br>            rightBound--<br>        &#125;<br>        <span class="hljs-keyword">if</span> lowerBound &gt;= upperBound &#123;<br>            <span class="hljs-keyword">for</span> i := rightBound; i &gt;= leftBound; i-- &#123;<br>                matrix[lowerBound][i] = count<br>                count++<br>            &#125;<br>            lowerBound--<br>        &#125;<br>        <span class="hljs-keyword">if</span> leftBound &lt;= rightBound &#123;<br>            <span class="hljs-keyword">for</span> i := lowerBound; i &gt;= upperBound; i-- &#123;<br>                matrix[i][leftBound] = count<br>                count++<br>            &#125;<br>            leftBound++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> matrix<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小而美的算法技巧：差分数组</title>
    <link href="/leetcode/fucking-algorithm/array-diff/"/>
    <url>/leetcode/fucking-algorithm/array-diff/</url>
    
    <content type="html"><![CDATA[<h1 id="小而美的算法技巧：差分数组"><a href="#小而美的算法技巧：差分数组" class="headerlink" title="小而美的算法技巧：差分数组"></a>小而美的算法技巧：差分数组</h1><p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。</p><p><img src="https://labuladong.gitee.io/algo/images/%e5%b7%ae%e5%88%86%e6%95%b0%e7%bb%84/2.jpeg"></p><p>差分数组每一个元素 <code>df[i]</code> 储存数组元素与上一个元素的差值 <code>nums[i] - nums[i-1]</code>。</p><p>差分数组可以直接还原为原数组，只需遍历一遍差分数组，加上上一个元素即可。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>    df[i] = df[i<span class="hljs-number">-1</span>] + df[i]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="航班预订统计"><a href="#航班预订统计" class="headerlink" title="航班预订统计"></a>航班预订统计</h2><p><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">https://leetcode-cn.com/problems/corporate-flight-bookings/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">corpFlightBookings</span><span class="hljs-params">(bookings [][]<span class="hljs-keyword">int</span>, n <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 差分数组初始化为全 0</span><br>    df := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> _, booking := <span class="hljs-keyword">range</span> bookings &#123;<br>        df[booking[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>] += booking[<span class="hljs-number">2</span>]<br>        <span class="hljs-comment">// 如果区间终点是数组终点，不需要修改</span><br>        <span class="hljs-keyword">if</span> booking[<span class="hljs-number">1</span>] &lt; n &#123;<br>            df[booking[<span class="hljs-number">1</span>]] -= booking[<span class="hljs-number">2</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 还原差分数组</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        df[i] = df[i<span class="hljs-number">-1</span>] + df[i]<br>    &#125;<br>    <span class="hljs-keyword">return</span> df<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="拼车"><a href="#拼车" class="headerlink" title="拼车"></a>拼车</h2><p><a href="https://leetcode-cn.com/problems/car-pooling/">https://leetcode-cn.com/problems/car-pooling/</a></p><p>和上一题基本一样，有几点注意的：</p><ul><li>题目限定了路程长度最多为 1000，所以差分数组也初始化为 1000</li><li>乘客会先下后上，所有到达终点时车的容量就会马上增加，因此在终点区间就可以减去人数</li><li>注意起点 0 时可能上了多个乘客但是没判断到</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">carPooling</span><span class="hljs-params">(trips [][]<span class="hljs-keyword">int</span>, capacity <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-comment">// 差分数组初始化为全 0</span><br>    n := <span class="hljs-number">1000</span><br>    df := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> _, trip := <span class="hljs-keyword">range</span> trips &#123;<br>        df[trip[<span class="hljs-number">1</span>]] += trip[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment">// 如果区间终点是数组终点，不需要修改</span><br>        <span class="hljs-keyword">if</span> trip[<span class="hljs-number">2</span>] &lt; n &#123;<br>            df[trip[<span class="hljs-number">2</span>]] -= trip[<span class="hljs-number">0</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> df[<span class="hljs-number">0</span>] &gt; capacity &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-comment">// 还原差分数组</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        df[i] = df[i<span class="hljs-number">-1</span>] + df[i]<br>        <span class="hljs-keyword">if</span> df[i] &gt; capacity &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小而美的算法技巧：前缀和数组</title>
    <link href="/leetcode/fucking-algorithm/array-prefix-sum/"/>
    <url>/leetcode/fucking-algorithm/array-prefix-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="小而美的算法技巧：前缀和数组"><a href="#小而美的算法技巧：前缀和数组" class="headerlink" title="小而美的算法技巧：前缀和数组"></a>小而美的算法技巧：前缀和数组</h1><p>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。</p><h2 id="一维数组中的前缀和"><a href="#一维数组中的前缀和" class="headerlink" title="一维数组中的前缀和"></a>一维数组中的前缀和</h2><p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">https://leetcode-cn.com/problems/range-sum-query-immutable/</a></p><p>前缀和技巧：提前计算数组从 0 开始的累加和并储存，在需要获取一个区间内的和时，直接在累加和数组中相减即可得到，不需要每次去重新遍历数组。</p><p><img src="https://labuladong.gitee.io/algo/images/%e5%b7%ae%e5%88%86%e6%95%b0%e7%bb%84/1.jpeg"></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumArray <span class="hljs-keyword">struct</span> &#123;<br>    prefixSum []<span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">NumArray</span></span> &#123;<br>    a := <span class="hljs-built_in">new</span>(NumArray)<br>    prefixSum := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums) + <span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 计算前缀和</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        prefixSum[i] = prefixSum[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>]<br>    &#125;<br>    a.prefixSum = prefixSum<br>    <span class="hljs-keyword">return</span> *a<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumArray)</span> <span class="hljs-title">SumRange</span><span class="hljs-params">(left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> this.prefixSum[right + <span class="hljs-number">1</span>] - this.prefixSum[left]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二维矩阵中的前缀和"><a href="#二维矩阵中的前缀和" class="headerlink" title="二维矩阵中的前缀和"></a>二维矩阵中的前缀和</h2><p><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">https://leetcode-cn.com/problems/range-sum-query-2d-immutable/</a></p><p>类似于上一题，不过是二维的。对于二维情况稍微复杂一点，但原理还是一样的：通过几个子矩阵前缀和的加减运算得出任意区域矩阵的和。</p><p><img src="https://labuladong.gitee.io/algo/images/%e5%89%8d%e7%bc%80%e5%92%8c/5.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> NumMatrix <span class="hljs-keyword">struct</span> &#123;<br>    prefixMatrix [][]<span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">NumMatrix</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(matrix), <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>])<br>    prefix := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> prefix &#123;<br>        prefix[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            prefix[i][j] = prefix[i<span class="hljs-number">-1</span>][j] + prefix[i][j<span class="hljs-number">-1</span>] - prefix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + matrix[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NumMatrix&#123;prefix&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *NumMatrix)</span> <span class="hljs-title">SumRegion</span><span class="hljs-params">(row1 <span class="hljs-keyword">int</span>, col1 <span class="hljs-keyword">int</span>, row2 <span class="hljs-keyword">int</span>, col2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> this.prefixMatrix[row2+<span class="hljs-number">1</span>][col2+<span class="hljs-number">1</span>] - this.prefixMatrix[row1][col2+<span class="hljs-number">1</span>] - this.prefixMatrix[row2+<span class="hljs-number">1</span>][col1] + this.prefixMatrix[row1][col1]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="和为-k-的子数组"><a href="#和为-k-的子数组" class="headerlink" title="和为 k 的子数组"></a>和为 k 的子数组</h2><p>类似于两数之和，计算出前缀数组后不用再去遍历一遍，只需要寻找它减去 k 以后的前缀和是否已经在哈希表中。这样的前缀和有几个，就有几个能凑出和为 k 的子数组，直接在结果加上即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>  <span class="hljs-comment">// base case</span><br>    <br>    res, sum:= <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        sum += nums[i]<br>        start := sum - k<br>        <span class="hljs-keyword">if</span> val, ok := m[start]; ok &#123;<br>            res += val<br>        &#125;<br>        m[sum] += <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>完全二叉树的节点个数</title>
    <link href="/leetcode/fucking-algorithm/count-complete-tree-nodes/"/>
    <url>/leetcode/fucking-algorithm/count-complete-tree-nodes/</url>
    
    <content type="html"><![CDATA[<h1 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h1><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">https://leetcode-cn.com/problems/count-complete-tree-nodes/</a></p><p>完全二叉树有个重要的特点：<strong>一棵完全二叉树的两棵子树，至少有一棵是满二叉树</strong></p><p><img src="https://labuladong.gitee.io/algo/images/complete_tree/1.jpg"></p><p>计算满二叉树的节点个数并不需要遍历所有节点，只需要得知它的深度，直接计算即可。</p><p>这段代码先把左右子树都当作满树计算，如果不满足条件再递归到左右子树。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;<br>    l, r := root, root<br>    hl, hr := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> l != <span class="hljs-literal">nil</span> &#123;<br>        l = l.Left<br>        hl += <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> r != <span class="hljs-literal">nil</span> &#123;<br>        r = r.Right<br>        hr += <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> hl == hr &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(math.Pow(<span class="hljs-number">2.0</span>, <span class="hljs-keyword">float64</span>(hr))) - <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + countNodes(root.Left) + countNodes(root.Right)<br>&#125;<br></code></pre></td></tr></table></figure><p>算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。</p><p>如果是普通二叉树，遍历一遍的时间复杂度是 O(N)。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="/leetcode/fucking-algorithm/lowest-common-ancestor-of-a-binary-tree/"/>
    <url>/leetcode/fucking-algorithm/lowest-common-ancestor-of-a-binary-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h1><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><p>p 和 q 的公共祖先满足这样一个条件：它的左右子树分别包含了 p 跟 q；或者它就是 p 或 q（两个节点是父子关系）。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(root, p, q *TreeNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">// base case: 如果当前节点等于其中一个要找的节点，直接返回</span><br>    <span class="hljs-keyword">if</span> root == p || root == q &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br><br>    left := lowestCommonAncestor(root.Left, p, q)<br>    right := lowestCommonAncestor(root.Right, p, q)<br><br>    <span class="hljs-comment">// 左右子树分别包含了 p 和 q</span><br>    <span class="hljs-comment">// 根据 base case 定义，如果返回值不为 nil，要么包含了 p 要么包含了 q</span><br>    <span class="hljs-keyword">if</span> left != <span class="hljs-literal">nil</span> &amp;&amp; right != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <br>    <span class="hljs-comment">// 左右子树都不包含 p 和 q</span><br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 返回包含了其中一个（或两个）节点的那棵树</span><br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> right<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> left<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于是后序遍历，能够保证第一个满足条件的 root 节点是最深的，也就是最近公共子节点。</p><p><strong>注意这个递归函数的功能跟它名字描述并不完全一致</strong>，需要结合代码理解。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索子树的最大键值和</title>
    <link href="/leetcode/fucking-algorithm/maximum-sum-bst-in-binary-tree/"/>
    <url>/leetcode/fucking-algorithm/maximum-sum-bst-in-binary-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索子树的最大键值和"><a href="#二叉搜索子树的最大键值和" class="headerlink" title="二叉搜索子树的最大键值和"></a>二叉搜索子树的最大键值和</h1><p><a href="https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/">https://leetcode-cn.com/problems/maximum-sum-bst-in-binary-tree/</a></p><h2 id="后序遍历返回多个值"><a href="#后序遍历返回多个值" class="headerlink" title="后序遍历返回多个值"></a>后序遍历返回多个值</h2><p>题目需要我们在每一颗子树上判断：是否是 BST，如果是 BST，计算整颗子树的大小。找出最大的 BST。</p><p>递归地说，首先需要一个节点判断自己是不是 BST，则需要：它的左右子树都是 BST，且它的值大于左子树的最大值、小于右子树的最小值。如果它是 BST 了，则需要得知左子树的和、右子树的和，才能计算整棵树的大小。</p><p>这道题的奥妙就在于这些信息都是可以用后序遍历得到的，因此只进行 1 次后序遍历，但是返回多个值来记录这些信息。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> maxSum <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSumBST</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;<br>    maxSum = <span class="hljs-number">0</span><br>    traverse(root)<br>    <span class="hljs-keyword">return</span> maxSum<br>&#125;<br><br><span class="hljs-comment">// [4]int&#123;isBST, min, max, sum&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode)</span> [4]<span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// base case: 空节点是 BST，但它没有最小值，也就是说它的最小值需要取一个有效范围以外的值，使得任意值都比它小。最大值同理</span><br>        <span class="hljs-keyword">return</span> [<span class="hljs-number">4</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, math.MaxInt32, math.MinInt32, <span class="hljs-number">0</span>&#125;<br>    &#125;<br><br>    left, right := traverse(root.Left), traverse(root.Right)<br><br>    res := [<span class="hljs-number">4</span>]<span class="hljs-keyword">int</span>&#123;&#125;<br>    <span class="hljs-comment">// 有效 BST 判定</span><br>    <span class="hljs-keyword">if</span> left[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; right[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; root.Val &gt; left[<span class="hljs-number">2</span>] &amp;&amp; root.Val &lt; right[<span class="hljs-number">1</span>] &#123;<br>        res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>                              <span class="hljs-comment">// 这颗子树是 BST</span><br>        res[<span class="hljs-number">1</span>] = min(left[<span class="hljs-number">1</span>], root.Val)         <span class="hljs-comment">// 这颗子树的最小值</span><br>        res[<span class="hljs-number">2</span>] = max(right[<span class="hljs-number">2</span>], root.Val)        <span class="hljs-comment">// 这颗子树的最大值</span><br>        res[<span class="hljs-number">3</span>] = left[<span class="hljs-number">3</span>] + right[<span class="hljs-number">3</span>] + root.Val  <span class="hljs-comment">// 这颗子树之和</span><br><br>        maxSum = max(maxSum, res[<span class="hljs-number">3</span>])            <span class="hljs-comment">// 更新全局最大值记录</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>  <span class="hljs-comment">// 如果不是 BST，只需要记录这个值就够了，其他的用不上</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树 3</title>
    <link href="/leetcode/fucking-algorithm/binary-search-tree-iii/"/>
    <url>/leetcode/fucking-algorithm/binary-search-tree-iii/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树系列-3"><a href="#二叉搜索树系列-3" class="headerlink" title="二叉搜索树系列 3"></a>二叉搜索树系列 3</h1><h2 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">https://leetcode-cn.com/problems/unique-binary-search-trees/</a></p><p>这题实际上是一题动态规划问题，对于一个区间内的数字，穷举每一个数字作为根节点的情况，它的左右子树由相同的函数在不同的区间递归生成。</p><p>对于一个根节点，如果它的左子树有 m 种可能，右子树有 n 种可能，那它自己就是 m*n 种可能。最后加上备忘录消除重叠子问题。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> memo [][]<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> memo &#123;<br>        memo[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n+<span class="hljs-number">1</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> count(<span class="hljs-number">1</span>, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">count</span><span class="hljs-params">(low, high <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case: 对应空树的情况，也是一种可能</span><br>    <span class="hljs-keyword">if</span> low &gt; high &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> memo[low][high] != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> memo[low][high]<br>    &#125;<br><br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := low; i &lt;= high; i++ &#123;<br>        res += count(low, i<span class="hljs-number">-1</span>) * count(i+<span class="hljs-number">1</span>, high)<br>    &#125;<br>    memo[low][high] = res<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不同的二叉搜索树-II"><a href="#不同的二叉搜索树-II" class="headerlink" title="不同的二叉搜索树 II"></a>不同的二叉搜索树 II</h2><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/</a></p><p>遇上一题一样，不过还要将树组合起来，也是用穷举的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generateTrees</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> []*<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">return</span> generate(<span class="hljs-number">1</span>, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">generate</span><span class="hljs-params">(low, high <span class="hljs-keyword">int</span>)</span> []*<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-comment">// base case: 返回只包含空节点的列表（而不能返回空列表）</span><br>    <span class="hljs-keyword">if</span> low &gt; high &#123;<br>        <span class="hljs-keyword">return</span> []*TreeNode&#123;<span class="hljs-literal">nil</span>&#125;<br>    &#125;<br><br>    res := <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">for</span> i := low; i &lt;= high; i++ &#123;<br>        <span class="hljs-comment">// 生成所有可能的左右子树</span><br>        leftTrees := generate(low, i<span class="hljs-number">-1</span>)<br>        rightTrees := generate(i+<span class="hljs-number">1</span>, high)<br><br>        <span class="hljs-comment">// 穷举组合出所有可能的树</span><br>        <span class="hljs-keyword">for</span> _, left := <span class="hljs-keyword">range</span> leftTrees &#123;<br>            <span class="hljs-keyword">for</span> _, right := <span class="hljs-keyword">range</span> rightTrees &#123;<br>                res = <span class="hljs-built_in">append</span>(res, &amp;TreeNode&#123;i, left, right&#125;)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>BST</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树 1</title>
    <link href="/leetcode/fucking-algorithm/binary-search-tree-i/"/>
    <url>/leetcode/fucking-algorithm/binary-search-tree-i/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树系列-1"><a href="#二叉搜索树系列-1" class="headerlink" title="二叉搜索树系列 1"></a>二叉搜索树系列 1</h1><p>这两题主要利用 BST 的一个重要性质：<strong>中序遍历的结果是升序的</strong>。</p><h2 id="二叉搜索树中第-K-小的元素"><a href="#二叉搜索树中第-K-小的元素" class="headerlink" title="二叉搜索树中第 K 小的元素"></a>二叉搜索树中第 K 小的元素</h2><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/</a></p><p>直接进行中序遍历，然后取第 K 个元素就是答案。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(root *TreeNode, k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">var</span> a []<span class="hljs-keyword">int</span><br>    <span class="hljs-keyword">var</span> traverse <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span><br>    traverse = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(node *TreeNode)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        traverse(node.Left)<br>        a = <span class="hljs-built_in">append</span>(a, node.Val)<br>        traverse(node.Right)<br>    &#125;<br>    traverse(root)<br>    <span class="hljs-keyword">return</span> a[k<span class="hljs-number">-1</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h2><p><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">https://leetcode-cn.com/problems/convert-bst-to-greater-tree/</a></p><p>把每个节点更新为所有大于等于它节点的值，可以由 BST 中序遍历为有序列表的性质出发，按右根左的方式进行中序遍历就可以得到降序列表。外部维护一个累加值，遍历到一个节点用这个值更新节点即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">convertBST</span><span class="hljs-params">(root *TreeNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    sum = <span class="hljs-number">0</span><br>    traverse(root)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    traverse(root.Right)<br><br>    <span class="hljs-comment">// 记录累加值，并作为树的新值</span><br>    sum += root.Val<br>    root.Val = sum<br><br>    traverse(root.Left)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉搜索树 2</title>
    <link href="/leetcode/fucking-algorithm/binary-search-tree-ii/"/>
    <url>/leetcode/fucking-algorithm/binary-search-tree-ii/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树系列-2"><a href="#二叉搜索树系列-2" class="headerlink" title="二叉搜索树系列 2"></a>二叉搜索树系列 2</h1><h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p><p>注意：这题有坑，左右子树都是 BST 的一棵树，它自己不一定是 BST（还需要左右子树的值都小于或大于自己）。因此不能简单的递归交给子树解决，而要将根节点的限制也作为函数参数传入。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> isValid(root, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValid</span><span class="hljs-params">(root, min, max *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> min != <span class="hljs-literal">nil</span> &amp;&amp; root.Val &lt;= min.Val &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> max != <span class="hljs-literal">nil</span> &amp;&amp; root.Val &gt;= max.Val &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> isValid(root.Left, min, root) &amp;&amp; isValid(root.Right, root, max)<br>&#125;<br></code></pre></td></tr></table></figure><p>或者走一遍中序遍历，判断是否有元素比上一个元素小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    inorder := math.MinInt64<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> || root != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">for</span> root != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, root)<br>            root = root.Left<br>        &#125;<br>        root = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        <span class="hljs-keyword">if</span> root.Val &lt;= inorder &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        inorder = root.Val<br>        root = root.Right<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉搜索树中的搜索"><a href="#二叉搜索树中的搜索" class="headerlink" title="二叉搜索树中的搜索"></a>二叉搜索树中的搜索</h2><p><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">https://leetcode-cn.com/problems/search-in-a-binary-search-tree/</a></p><p>递归和迭代两种方法，最坏情况下时间复杂度都是 O(N) （因为不是<code>平衡</code> BST，最坏情况下退化成一个链表）。</p><p>空间复杂度，最坏情况下递归还是栈空间的 O(N)，而迭代是 O(1)，没使用额外空间。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> || root.Val == val &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &lt; root.Val &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.Left, val)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> searchBST(root.Right, val)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">searchBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">for</span> root != <span class="hljs-literal">nil</span> &amp;&amp; root.Val != val &#123;<br>        <span class="hljs-keyword">if</span> val &lt; root.Val &#123;<br>            root = root.Left<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root = root.Right<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉搜索树中的插入"><a href="#二叉搜索树中的插入" class="headerlink" title="二叉搜索树中的插入"></a>二叉搜索树中的插入</h2><p><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/</a></p><p>类似于搜索，只不过需要对返回值赋值。<strong>一旦涉及「改」，函数就要返回 <code>TreeNode</code> 类型，并且对递归调用的返回值进行接收。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(root *TreeNode, val <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> &amp;TreeNode&#123;val, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> val &lt; root.Val &#123;<br>        root.Left = insertIntoBST(root.Left, val)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        root.Right = insertIntoBST(root.Right, val)<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="删除二叉搜索树中的节点"><a href="#删除二叉搜索树中的节点" class="headerlink" title="删除二叉搜索树中的节点"></a>删除二叉搜索树中的节点</h2><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/">https://leetcode-cn.com/problems/delete-node-in-a-bst/</a></p><p>记住接受函数的返回值。删除一个节点，如果它左右子树都不为空，则最好的方法是找一个替代它，使得新的节点还能满足 BST。右子树中的最小节点和左子树中的最大节点都能满足这个要求，只要用它们替换掉待删除的节点即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(root *TreeNode, key <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    <span class="hljs-keyword">if</span> key &lt; root.Val &#123;<br>        root.Left = deleteNode(root.Left, key)<br>        <span class="hljs-keyword">return</span> root<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> key &gt; root.Val &#123;<br>        root.Right = deleteNode(root.Right, key)<br>        <span class="hljs-keyword">return</span> root<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> root.Right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Left<br>        &#125;<br>        <span class="hljs-keyword">if</span> root.Left == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> root.Right<br>        &#125;<br>        minNode := findMin(root.Right)  <span class="hljs-comment">// 用待删除节点的右子树的最小节点来替换</span><br><br>        root.Right = deleteNode(root.Right, minNode.Val)  <span class="hljs-comment">// 先从原来的树中切掉</span><br><br>        minNode.Right = root.Right  <br>        minNode.Left = root.Left<br>        root = minNode  <span class="hljs-comment">// 然后用它替代要删除的节点</span><br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMin</span><span class="hljs-params">(root *TreeNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">for</span> root.Left != <span class="hljs-literal">nil</span> &#123;<br>        root = root.Left<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里我们不改变节点的值，只操作它的指针。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>BST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树 3</title>
    <link href="/leetcode/fucking-algorithm/binary-tree-iii/"/>
    <url>/leetcode/fucking-algorithm/binary-tree-iii/</url>
    
    <content type="html"><![CDATA[<h1 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h1><p><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/">https://leetcode-cn.com/problems/find-duplicate-subtrees/</a></p><h2 id="二叉树序列化-哈希表"><a href="#二叉树序列化-哈希表" class="headerlink" title="二叉树序列化 + 哈希表"></a>二叉树序列化 + 哈希表</h2><p>遍历二叉树，序列化每一个子节点作为根的子树得到一个代表子树的字符串，如果字符串相同，则对应的子树也是相同的。最后用哈希表来记录这样的子树出现了多少次。</p><p>对于这题，子树在序列化时也是需要知道自己子节点的信息，因此还是以后序的框架来写（但是是前序序列化）。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> memo <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> res []*TreeNode<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findDuplicateSubtrees</span><span class="hljs-params">(root *TreeNode)</span> []*<span class="hljs-title">TreeNode</span></span> &#123;<br>    memo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br>    res = <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">0</span>)<br>    serialize(root)<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serialize</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#,&quot;</span><br>    &#125;<br>    s := strconv.Itoa(root.Val) + <span class="hljs-string">&quot;,&quot;</span> + serialize(root.Left) + serialize(root.Right)  <span class="hljs-comment">// 序列化</span><br>    <br>    <span class="hljs-keyword">if</span> memo[s] == <span class="hljs-number">1</span> &#123;<br>        res = <span class="hljs-built_in">append</span>(res, root)<br>    &#125;<br>    memo[s] += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的序列化与反序列化</title>
    <link href="/leetcode/fucking-algorithm/serialize-and-deserialize-binary-tree/"/>
    <url>/leetcode/fucking-algorithm/serialize-and-deserialize-binary-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h1><p><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/">https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/</a></p><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>按任意一种方式遍历然后用相同的方式还原其实都可以，这里选择前序遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><br><br><span class="hljs-keyword">type</span> Codec <span class="hljs-keyword">struct</span> &#123;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Constructor</span><span class="hljs-params">()</span> <span class="hljs-params">(_ Codec)</span></span> &#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// Serializes a tree to a single string.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span> <span class="hljs-title">serialize</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">string</span></span> &#123;<br>    sb := &amp;strings.Builder&#123;&#125;<br>    serialize(root, sb)<br>    <span class="hljs-keyword">return</span> sb.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">serialize</span><span class="hljs-params">(root *TreeNode, sb *strings.Builder)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        sb.WriteString(<span class="hljs-string">&quot;null,&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <br>    sb.WriteString(strconv.Itoa(root.Val))<br>    sb.WriteByte(<span class="hljs-string">&#x27;,&#x27;</span>)<br>    serialize(root.Left, sb)<br>    serialize(root.Right, sb)<br>&#125;<br><br><span class="hljs-comment">// Deserializes your encoded data to tree.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Codec)</span> <span class="hljs-title">deserialize</span><span class="hljs-params">(data <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;    <br>    stringSlice := strings.Split(data, <span class="hljs-string">&quot;,&quot;</span>)<br><br>    <span class="hljs-comment">// 使用了函数闭包的技巧，省去传参的麻烦</span><br>    <span class="hljs-keyword">var</span> deserialize <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> *<span class="hljs-title">TreeNode</span></span><br>    deserialize = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>        <br>        <span class="hljs-keyword">if</span> stringSlice[<span class="hljs-number">0</span>] == <span class="hljs-string">&quot;null&quot;</span> &#123;<br>            stringSlice = stringSlice[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br><br>        val, _ := strconv.Atoi(stringSlice[<span class="hljs-number">0</span>])<br>        stringSlice = stringSlice[<span class="hljs-number">1</span>:]<br><br>        <span class="hljs-keyword">return</span> &amp;TreeNode&#123;val, deserialize(), deserialize()&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> deserialize()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 切片作为函数参数的“陷阱”</title>
    <link href="/programming/go-slice-as-function-argument/"/>
    <url>/programming/go-slice-as-function-argument/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-切片作为函数参数的“陷阱”"><a href="#Golang-切片作为函数参数的“陷阱”" class="headerlink" title="Golang 切片作为函数参数的“陷阱”"></a>Golang 切片作为函数参数的“陷阱”</h1><p>我们知道 Go 中的切片类型是引用类型，直觉来讲在作为函数参数时，如果函数内部修改了切片的值，函数外的也会被修改，但这有个前提：只能修改切片的<strong>内容</strong>，而不能修改切片它<strong>本身</strong>。</p><p>如果用切片重组或者 append 方法修改了切片的长度或容量，得到的切片就不是原来那个了，因此变化不会反映到函数外。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>s := a[:]<br>changeSlice(s)<br>fmt.Println(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changeSlice</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 以下改动不会导致函数外部变化</span><br>s = s[:<span class="hljs-number">2</span>]<br>    s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">98</span>)<br>&#125;<br><br><span class="hljs-comment">// out: [1 2 3 4 5]</span><br></code></pre></td></tr></table></figure><p>而如果修改了切片的内容，例如其中元素的值，切片的长度跟容量都没有变，会导致函数外部的切片也一起改变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>s := a[:]<br>changeSlice(s)<br>fmt.Println(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changeSlice</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 以下改动会导致函数外部变化</span><br>s[<span class="hljs-number">0</span>] = <span class="hljs-number">4396</span><br>&#125;<br><br><span class="hljs-comment">// out: [4396 2 3 4 5]</span><br></code></pre></td></tr></table></figure><h2 id="传递切片的指针"><a href="#传递切片的指针" class="headerlink" title="传递切片的指针"></a>传递切片的指针</h2><p>如果实在想修改切片，可以传递切片的指针，解引用后进行操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>s := a[:]<br>changeSlice(&amp;s)<br>fmt.Println(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changeSlice</span><span class="hljs-params">(s *[]<span class="hljs-keyword">int</span>)</span></span> &#123;<br>    *s = (*s)[:<span class="hljs-number">2</span>]<br>*s = <span class="hljs-built_in">append</span>(*s, <span class="hljs-number">4396</span>)<br>&#125;<br><br><span class="hljs-comment">// out: [1 2 4396]</span><br></code></pre></td></tr></table></figure><h2 id="复制切片"><a href="#复制切片" class="headerlink" title="复制切片"></a>复制切片</h2><p>如果需要保证切片（或它的关联数组）一定不会被修改，可以将原始切片用内置函数 <code>copy()</code> 复制后操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>s := a[:]<br>changeSlice(s)<br>fmt.Println(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changeSlice</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span></span> &#123;<br>sCopied := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(s))<br><span class="hljs-built_in">copy</span>(sCopied, s)<br>sCopied[<span class="hljs-number">0</span>] = <span class="hljs-number">4396</span><br>sCopied = <span class="hljs-built_in">append</span>(sCopied, <span class="hljs-number">7777</span>)<br>&#125;<br><br><span class="hljs-comment">// out: [1 2 3 4 5]</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://coolrc.me/2021/08/03/202108031930/">https://coolrc.me/2021/08/03/202108031930/</a></p></li><li><p><a href="https://studygolang.com/articles/9876">https://studygolang.com/articles/9876</a></p></li><li><p><a href="https://blog.go-zh.org/go-slices-usage-and-internals">https://blog.go-zh.org/go-slices-usage-and-internals</a></p></li><li><p><a href="https://stackoverflow.com/questions/49428716/pass-slice-as-function-argument-and-modify-the-original-slice">https://stackoverflow.com/questions/49428716/pass-slice-as-function-argument-and-modify-the-original-slice</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树 2</title>
    <link href="/leetcode/fucking-algorithm/binary-tree-ii/"/>
    <url>/leetcode/fucking-algorithm/binary-tree-ii/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树系列-2"><a href="#二叉树系列-2" class="headerlink" title="二叉树系列 2"></a>二叉树系列 2</h1><h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">https://leetcode-cn.com/problems/maximum-binary-tree/</a></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">return</span> build(nums, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">build</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>, low <span class="hljs-keyword">int</span>, high <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> low &gt; high &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    index, val := <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span><br>    <span class="hljs-comment">// 寻找列表中最大值作为根节点</span><br>    <span class="hljs-keyword">for</span> i := low; i &lt;= high; i++ &#123;<br>        <span class="hljs-keyword">if</span> nums[i] &gt; val &#123;<br>            val = nums[i]<br>            index = i<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &amp;TreeNode&#123;val, build(nums, low, index<span class="hljs-number">-1</span>), build(nums, index+<span class="hljs-number">1</span>, high)&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p><p>一个节点要做的事就是从两个数组中找到根节点，然后递归地生成左右子树。要正确的生成子树，就要将子树对应的数组正确的传入函数中。</p><p>可以利用中序数组根节点的位置推算出左子树长度，从而在前序数组中确定位置。</p><p><img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%972/4.jpeg" alt="如何在前序数组中找到正确的子数组"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(preorder []<span class="hljs-keyword">int</span>, inorder []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">return</span> build(preorder, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(preorder) - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(inorder) - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">build</span><span class="hljs-params">(preorder []<span class="hljs-keyword">int</span>, preLow, preHigh <span class="hljs-keyword">int</span>, inorder []<span class="hljs-keyword">int</span>, inLow, inHigh <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> preLow &gt; preHigh &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 前序数组第一个位置就是根节点</span><br>    rootVal := preorder[preLow]<br><br>    <span class="hljs-comment">// 找到根节点再中序数组中的位置</span><br>    rootIdx := inLow<br>    <span class="hljs-keyword">for</span> i := inLow; i &lt;= inHigh; i++ &#123;<br>        <span class="hljs-keyword">if</span> inorder[i] == rootVal &#123;<br>            rootIdx = i<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算左子树的大小，以确定如何划分数组递归调用</span><br>    leftSize := rootIdx - inLow<br><br>    node := &amp;TreeNode&#123;rootVal, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    node.Left = build(preorder, preLow+<span class="hljs-number">1</span>, preLow+leftSize, inorder, inLow, rootIdx<span class="hljs-number">-1</span>)<br>    node.Right = build(preorder, preLow+leftSize+<span class="hljs-number">1</span>, preHigh, inorder,  rootIdx+<span class="hljs-number">1</span>, inHigh)<br><br>    <span class="hljs-keyword">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/</a></p><p>和上一题几乎是一样的思想。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(inorder []<span class="hljs-keyword">int</span>, postorder []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">return</span> build(inorder, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(inorder) - <span class="hljs-number">1</span>, postorder, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(postorder) - <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">build</span><span class="hljs-params">(inorder []<span class="hljs-keyword">int</span>, inLow, inHigh <span class="hljs-keyword">int</span>, postorder []<span class="hljs-keyword">int</span>, postLow, postHigh <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> inLow &gt; inHigh &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-comment">// 后序数组最后一个位置就是根节点</span><br>    rootVal := postorder[postHigh]<br><br>    <span class="hljs-comment">// 找到根节点在中序数组中的位置</span><br>    rootIdx := inLow<br>    <span class="hljs-keyword">for</span> i := inLow; i &lt;= inHigh; i++ &#123;<br>        <span class="hljs-keyword">if</span> inorder[i] == rootVal &#123;<br>            rootIdx = i<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算左子树的大小，以确定如何划分数组递归调用</span><br>    leftSize := rootIdx - inLow<br><br>    node := &amp;TreeNode&#123;rootVal, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    node.Left = build(inorder, inLow, rootIdx<span class="hljs-number">-1</span>, postorder, postLow, postLow+leftSize<span class="hljs-number">-1</span>)<br>    node.Right = build(inorder, rootIdx+<span class="hljs-number">1</span>, inHigh, postorder, postLow+leftSize, postHigh<span class="hljs-number">-1</span>)<br><br>    <span class="hljs-keyword">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="根据前序和后序遍历构造二叉树"><a href="#根据前序和后序遍历构造二叉树" class="headerlink" title="根据前序和后序遍历构造二叉树"></a>根据前序和后序遍历构造二叉树</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</a></p><p>如何通过前后序位置确定某一棵子树的大小？前序数组的第 2 个位置就是左子树的根节点。</p><p>在后序数组中寻找这个元素的位置，它的 index 就指示了左子树的大小（在后序数组中，根节点的值位于它所有子树之后）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">constructFromPrePost</span><span class="hljs-params">(preorder []<span class="hljs-keyword">int</span>, postorder []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">return</span> build(preorder, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(preorder)<span class="hljs-number">-1</span>, postorder, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(postorder)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">build</span><span class="hljs-params">(preorder []<span class="hljs-keyword">int</span>, preLow, preHigh <span class="hljs-keyword">int</span>, postorder []<span class="hljs-keyword">int</span>, postLow, postHigh <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> preLow &gt; preHigh &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    <span class="hljs-comment">// 确保能取到左子树根节点</span><br>    <span class="hljs-keyword">if</span> preLow == preHigh &#123;<br>        <span class="hljs-keyword">return</span> &amp;TreeNode&#123;preorder[preLow], <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    &#125;<br>    rootVal := preorder[preLow]<br><br>    leftRootVal := preorder[preLow + <span class="hljs-number">1</span>]<br>    <span class="hljs-comment">// 找到左子树根节点在后序数组中的位置</span><br>    index := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := postLow; i &lt;= postHigh; i++ &#123;<br>        <span class="hljs-keyword">if</span> postorder[i] == leftRootVal &#123;<br>            index = i<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算左子树的大小，以确定如何划分数组递归调用</span><br>    leftSize := index - postLow + <span class="hljs-number">1</span><br><br>    node := &amp;TreeNode&#123;rootVal, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>&#125;<br>    node.Left = build(preorder, preLow+<span class="hljs-number">1</span>, preLow+leftSize, postorder, postLow, index)<br>    node.Right = build(preorder, preLow+leftSize+<span class="hljs-number">1</span>, preHigh, postorder, index+<span class="hljs-number">1</span>, postHigh<span class="hljs-number">-1</span>)<br><br>    <span class="hljs-keyword">return</span> node<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么还原的二叉树可能不唯一？因为在这一句中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">leftRootVal := preorder[preLow + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>我们假设了前序数组中根节点的后一个值就是左子树根节点，然而左子树如果为空，这个值实际上是右子树根节点，所以不能确定到底是哪一个。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树 1</title>
    <link href="/leetcode/fucking-algorithm/binary-tree-i/"/>
    <url>/leetcode/fucking-algorithm/binary-tree-i/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树系列-1"><a href="#二叉树系列-1" class="headerlink" title="二叉树系列 1"></a>二叉树系列 1</h1><p>递归代码，需要把题目的要求细化成<strong>每个节点需要做的事情</strong>。如果一个节点的信息不够完成任务，参数就多加一个需要的节点。</p><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p>此题每个节点要完成的事就是交换它的两个子节点。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invertTree</span><span class="hljs-params">(root *TreeNode)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    traverse(root)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    root.Left, root.Right = root.Right, root.Left<br>    traverse(root.Left)<br>    traverse(root.Right)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h2><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/</a></p><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>层次遍历维护一个队列，每取空一次队列为一层</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(root *Node)</span> *<span class="hljs-title">Node</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>queue := []*Node&#123;root&#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        tmp := queue<br>        queue = <span class="hljs-literal">nil</span><br>        <span class="hljs-comment">// 取空队列为同一层</span><br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(tmp); i++ &#123;<br>            <span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(tmp) - <span class="hljs-number">1</span> &#123; <br>                tmp[i].Next = tmp[i+<span class="hljs-number">1</span>]<br>            &#125;<br>            <span class="hljs-keyword">if</span> tmp[i].Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, tmp[i].Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> tmp[i].Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, tmp[i].Right)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>由于需要连接两个父节点不同的相邻节点，需要额外的信息来完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connect</span><span class="hljs-params">(root *Node)</span> *<span class="hljs-title">Node</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> root<br>    &#125;<br>    connectNodes(root.Left, root.Right)<br>    <span class="hljs-keyword">return</span> root<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">connectNodes</span><span class="hljs-params">(left, right *Node)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    left.Next = right<br>    <span class="hljs-comment">// 连接相同父节点的两个子节点</span><br>    connectNodes(left.Left, left.Right)<br>    connectNodes(right.Left, right.Right)<br><br>    <span class="hljs-comment">// 连接跨越父节点的两个子节点</span><br>    connectNodes(left.Right, right.Left)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><p><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/</a></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>显然链表结果是前序遍历结果，先遍历，然后连成链表即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> nodes []*TreeNode<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>    nodes = <span class="hljs-built_in">make</span>([]*TreeNode, <span class="hljs-number">0</span>)<br>    traverse(root)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(nodes) - <span class="hljs-number">1</span>; i++ &#123;<br>        nodes[i].Left = <span class="hljs-literal">nil</span><br>        nodes[i].Right = nodes[i+<span class="hljs-number">1</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">traverse</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    nodes = <span class="hljs-built_in">append</span>(nodes, root)<br>    traverse(root.Left)<br>    traverse(root.Right)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><p>拉成链表可以视为以下 3 步：</p><ol><li>将 <code>root</code> 的左子树和右子树拉平。</li><li>将 <code>root</code> 的右子树接到左子树下方</li><li>然后将整个左子树作为右子树。</li></ol><p><img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e7%b3%bb%e5%88%97/2.jpeg"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">flatten</span><span class="hljs-params">(root *TreeNode)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 拉平左右子树</span><br>    flatten(root.Left)<br>    flatten(root.Right)<br><br>    left, right := root.Left, root.Right<br>    root.Left, root.Right = <span class="hljs-literal">nil</span>, left  <span class="hljs-comment">// 将左子树作为右子树</span><br>    <br>    <span class="hljs-comment">// 原先的右子树接到当前右子树的末端</span><br>    p := root<br>    <span class="hljs-keyword">for</span> p.Right != <span class="hljs-literal">nil</span> &#123;<br>        p = p.Right<br>    &#125;<br>    p.Right = right<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树 0</title>
    <link href="/leetcode/fucking-algorithm/binary-tree-o/"/>
    <url>/leetcode/fucking-algorithm/binary-tree-o/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树系列-0"><a href="#二叉树系列-0" class="headerlink" title="二叉树系列 0"></a>二叉树系列 0</h1><ul><li><p>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点</p></li><li><p>对节点的访问顺序其实是一样的，但是输出顺序不一样</p></li><li><p>如果能遍历一遍得到结果的，就可以用遍历法。而如果涉及子树结果的（可分解为子问题），就可以用递归的方法。</p></li><li><p>后序位置才能<strong>通过返回值获取子树的信息</strong>。一旦发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在<strong>后序位置</strong>写代码了。</p></li></ul><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(maxDepth(root.Left), maxDepth(root.Right))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a <br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 记录最大深度</span><br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 记录遍历到的节点的深度</span><br><span class="hljs-keyword">int</span> depth = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><span class="hljs-built_in">traverse</span>(root);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 二叉树遍历框架</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (root == null) &#123;<br><span class="hljs-comment">// 到达叶子节点，更新最大深度</span><br>res = Math.<span class="hljs-built_in">max</span>(res, depth);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 前序位置</span><br>depth++;<br><span class="hljs-built_in">traverse</span>(root.left);<br><span class="hljs-built_in">traverse</span>(root.right);<br><span class="hljs-comment">// 后序位置</span><br>depth--;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> maxDiameter <span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;<br>    maxDiameter = <span class="hljs-number">0</span><br>    maxDepth(root)<br>    <span class="hljs-keyword">return</span> maxDiameter<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    maxLeft, maxRight := maxDepth(root.Left), maxDepth(root.Right)<br>    myDiameter := maxLeft + maxRight<br>    maxDiameter = max(maxDiameter, myDiameter)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(maxLeft, maxRight)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K 个一组翻转链表</title>
    <link href="/leetcode/fucking-algorithm/reverse-nodes-in-k-group/"/>
    <url>/leetcode/fucking-algorithm/reverse-nodes-in-k-group/</url>
    
    <content type="html"><![CDATA[<h1 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a>K 个一组翻转链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">https://leetcode-cn.com/problems/reverse-nodes-in-k-group/</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>先反转前面 k 个，然后反转接着的 k 个，容易看出完全独立的子问题关系。先反转完前 K 个后，调用一样的函数反转后续的链表。base case 是链表元素不足 K 个，不进行反转。</p><p><img src="https://labuladong.gitee.io/algo/images/kgroup/6.jpg" alt="反转前两个后，如何将链表正确地拼在一起"></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(head *ListNode, k <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    a , b := head, head<br>    <span class="hljs-comment">// 数链表元素个数是否足够反转</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; k; i++ &#123;<br>        <span class="hljs-keyword">if</span> b == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> a<br>        &#125;<br>        b = b.Next<br>    &#125;<br>    reversed := reverseInterval(a, b)<br>    a.Next = reverseKGroup(b, k)  <span class="hljs-comment">// 将 a 接到反转后的链表头上</span><br>    <span class="hljs-keyword">return</span> reversed<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseInterval</span><span class="hljs-params">(a, b *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">var</span> prev *ListNode<br>    curr := a<br><br>    <span class="hljs-keyword">for</span> curr != b &#123;<br>        next := curr.Next<br>        curr.Next = prev<br>        prev = curr<br>        curr = next<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表</title>
    <link href="/leetcode/fucking-algorithm/reverse-linked-lists/"/>
    <url>/leetcode/fucking-algorithm/reverse-linked-lists/</url>
    
    <content type="html"><![CDATA[<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">https://leetcode-cn.com/problems/reverse-linked-list-ii/</a></p><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>迭代方法：记住当前处理节点的上一个节点和下一个节点，完成反转操作</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">var</span> prev *ListNode<br>    curr := head<br><br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        next := curr.Next<br><br>        <span class="hljs-comment">// 反转当前链表的指针</span><br>        curr.Next = prev<br><br>        <span class="hljs-comment">// 前进指针，进行下一次处理</span><br>        prev = curr<br>        curr = next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br></code></pre></td></tr></table></figure><p>递归方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br><br>    reversed := reverseList(head.Next)<br><br>    head.Next.Next = head  <span class="hljs-comment">// 反转链表的尾巴设为 head</span><br>    head.Next = <span class="hljs-literal">nil</span>        <span class="hljs-comment">// head 变成了尾巴，它的 next 应该是 nil</span><br><br>    <span class="hljs-keyword">return</span> reversed        <span class="hljs-comment">// 反转后链表的头部</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反转链表的前-N-个元素"><a href="#反转链表的前-N-个元素" class="headerlink" title="反转链表的前 N 个元素"></a>反转链表的前 N 个元素</h2><p><img src="https://labuladong.gitee.io/algo/images/%e5%8f%8d%e8%bd%ac%e9%93%be%e8%a1%a8/6.jpg"></p><p>需要注意的是，反转前 N 个元素后，要将反转后的链表尾巴接到未反转的部分上（如果是全反转，设为 nil 即可），因此需要记录下未反转的部分是哪里。</p><p>显然，N &#x3D; 1 时，它的下一个节点就是未反转的部分，因此在此 base case 上记录下未反转的头部，然后反转后将反转后的尾巴接上去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> successor *ListNode<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseN</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        successor = head.Next  <span class="hljs-comment">// 记录未反转的部分</span><br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    <br>    reversed := reverseN(head.Next, n - <span class="hljs-number">1</span>)<br><br>    head.Next.Next = head<br>    head.Next = successor   <span class="hljs-comment">// 反转后的尾巴接上未反转的部分</span><br>    <span class="hljs-keyword">return</span> reversed<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="反转链表的中间的几个元素"><a href="#反转链表的中间的几个元素" class="headerlink" title="反转链表的中间的几个元素"></a>反转链表的中间的几个元素</h2><p>反转从 left 到 right 的中间几个元素，相当于从 left 开始，反转前 N 个元素。因此只要加一个判断，如果当前没到 left，就递归到下一个节点，直到当前从 left 开始，然后执行反转前 N 个元素的操作即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> successor *ListNode<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseBetween</span><span class="hljs-params">(head *ListNode, left <span class="hljs-keyword">int</span>, right <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> reverseN(head, right)<br>    &#125;<br>    head.Next = reverseBetween(head.Next, left<span class="hljs-number">-1</span>, right<span class="hljs-number">-1</span>)<br>    <span class="hljs-keyword">return</span> head<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseN</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        successor = head.Next<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    <br>    reversed := reverseN(head.Next, n - <span class="hljs-number">1</span>)<br><br>    head.Next.Next = head<br>    head.Next = successor<br>    <span class="hljs-keyword">return</span> reversed<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相交链表</title>
    <link href="/leetcode/fucking-algorithm/intersection-of-two-linked-lists/"/>
    <url>/leetcode/fucking-algorithm/intersection-of-two-linked-lists/</url>
    
    <content type="html"><![CDATA[<h1 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h1><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><h2 id="让指针分别遍历两个链表"><a href="#让指针分别遍历两个链表" class="headerlink" title="让指针分别遍历两个链表"></a>让指针分别遍历两个链表</h2><p>指针 <code>p1</code> 遍历完 <code>l1</code> 后开始遍历 <code>l2</code>，<code>p2</code> 同理，每次两个指针只会走一步。这样它们最终会在相交处相遇。</p><p><img src="https://labuladong.gitee.io/algo/images/%e9%93%be%e8%a1%a8%e6%8a%80%e5%b7%a7/6.jpeg"></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs go">p1, p2 := headA, headB<br><span class="hljs-keyword">for</span> p1 != p2 &#123;<br>    <span class="hljs-keyword">if</span> p1 == <span class="hljs-literal">nil</span> &#123;<br>        p1 = headB<br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        p1 = p1.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> p2 == <span class="hljs-literal">nil</span> &#123;<br>        p2 = headA<br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        p2 = p2.Next<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> p1<br></code></pre></td></tr></table></figure><h2 id="转换成环形链表问题"><a href="#转换成环形链表问题" class="headerlink" title="转换成环形链表问题"></a>转换成环形链表问题</h2><p>让链表首尾相连，变成寻找环形链表起点问题。（但是会修改链表结构）</p><h2 id="计算链表长度"><a href="#计算链表长度" class="headerlink" title="计算链表长度"></a>计算链表长度</h2><p>计算两个链表的长度，作差，使其中一个指针先前进这个差值，使得它们到终点的距离相同，然后一起前进，判断是否相等。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环形链表</title>
    <link href="/leetcode/fucking-algorithm/linked-list-cycle/"/>
    <url>/leetcode/fucking-algorithm/linked-list-cycle/</url>
    
    <content type="html"><![CDATA[<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><h2 id="检测是否存在环形链表"><a href="#检测是否存在环形链表" class="headerlink" title="检测是否存在环形链表"></a>检测是否存在环形链表</h2><p>快慢指针</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    fast, slow := head, head<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;<br>        fast = fast.Next.Next<br>        slow = slow.Next<br>        <span class="hljs-keyword">if</span> fast == slow &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="环形链表的起点"><a href="#环形链表的起点" class="headerlink" title="环形链表的起点"></a>环形链表的起点</h2><p>快慢指针相遇后，将其中一个指回开头，以同样的速度前进，再次相遇的地方就是环的起点</p><p><img src="https://labuladong.gitee.io/algo/images/%e5%8f%8c%e6%8c%87%e9%92%88/2.jpeg"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">detectCycle</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    fast, slow := head, head<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;<br>        fast = fast.Next.Next<br>        slow = slow.Next<br>        <span class="hljs-keyword">if</span> fast == slow &#123;<br>            <span class="hljs-comment">// 开始寻找环起点</span><br>            fast = head <br>            <span class="hljs-keyword">for</span> fast != slow &#123;<br>                fast = fast.Next<br>                slow = slow.Next<br>            &#125;<br>            <span class="hljs-keyword">return</span> fast<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并K个升序链表</title>
    <link href="/leetcode/fucking-algorithm/merge-k-sorted-lists/"/>
    <url>/leetcode/fucking-algorithm/merge-k-sorted-lists/</url>
    
    <content type="html"><![CDATA[<h1 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h1><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a></p><h2 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h2><p>把所有链表的头节点放入最小堆，每次从中取出最小的那个。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * type ListNode struct &#123;</span><br><span class="hljs-comment"> *     Val int</span><br><span class="hljs-comment"> *     Next *ListNode</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeKLists</span><span class="hljs-params">(lists []*ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    h := <span class="hljs-built_in">new</span>(minHeap)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(lists); i++ &#123;<br>        <span class="hljs-keyword">if</span> lists[i] != <span class="hljs-literal">nil</span> &#123;<br>            heap.Push(h, lists[i])<br>        &#125;<br>    &#125;<br><br>    head := <span class="hljs-built_in">new</span>(ListNode)<br>    curr := head<br><br>    <span class="hljs-keyword">for</span> h.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        temp := heap.Pop(h).(*ListNode)<br>        <span class="hljs-keyword">if</span> temp.Next != <span class="hljs-literal">nil</span> &#123;<br>            heap.Push(h, temp.Next)<br>        &#125;<br>        curr.Next = temp<br>        curr = curr.Next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head.Next<br>&#125;<br><br><span class="hljs-comment">// 最小堆实现</span><br><span class="hljs-keyword">type</span> minHeap []*ListNode<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h minHeap)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(h) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h minHeap)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123; <span class="hljs-keyword">return</span> h[i].Val &lt; h[j].Val &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h minHeap)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *minHeap)</span> <span class="hljs-title">Push</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    *h = <span class="hljs-built_in">append</span>(*h, x.(*ListNode))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *minHeap)</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br>old := *h<br>n := <span class="hljs-built_in">len</span>(old)<br>x := old[n<span class="hljs-number">-1</span>]<br>*h = old[<span class="hljs-number">0</span> : n<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>最小堆的实现参考：</p><ul><li><a href="https://pkg.go.dev/container/heap">https://pkg.go.dev/container/heap</a></li><li><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.3.html">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.3.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>优先级队列</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 类型断言</title>
    <link href="/programming/go-type-assertion/"/>
    <url>/programming/go-type-assertion/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-类型断言"><a href="#Golang-类型断言" class="headerlink" title="Golang 类型断言"></a>Golang 类型断言</h1><p>类型断言： type assertion</p><p>类型断言是一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs go">value, ok := x.(T)<br></code></pre></td></tr></table></figure><p>其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。</p><p>如果不接收第二个参数也就是上面代码中的 ok，断言失败时会直接造成一个 panic。如果 x 为 nil 同样也会 panic。</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是 ok），可根据该布尔值判断 x 是否为 T 类型：</p><ul><li><p>如果 T 是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型 T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。</p></li><li><p>如果 T 是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x 的动态值不会被提取，返回值是一个类型为 T 的接口值。</p></li><li><p>无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间列表的交集</title>
    <link href="/leetcode/fucking-algorithm/interval-list-intersections/"/>
    <url>/leetcode/fucking-algorithm/interval-list-intersections/</url>
    
    <content type="html"><![CDATA[<h1 id="区间列表的交集"><a href="#区间列表的交集" class="headerlink" title="区间列表的交集"></a>区间列表的交集</h1><p><a href="https://leetcode-cn.com/problems/interval-list-intersections/">https://leetcode-cn.com/problems/interval-list-intersections/</a></p><h2 id="观察规律"><a href="#观察规律" class="headerlink" title="观察规律"></a>观察规律</h2><p>两个区间要么有交集，要么无交集。如果无交集，则条件很明显是 <code>secondEnd &lt; firstStart || firstEnd &lt; secondStart </code>。</p><p>取反就是有交集的条件 <code>secondEnd &gt;= firstStart &amp;&amp; firstEnd &gt;= secondStart</code>，在这种条件下观察得出重叠区间的起点是两个起点的较大者，终点是两个终点的较小者。</p><p>得出交集后，谁更靠前，就移动谁的指针，很好理解。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intervalIntersection</span><span class="hljs-params">(firstList [][]<span class="hljs-keyword">int</span>, secondList [][]<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    result := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    m, n := <span class="hljs-built_in">len</span>(firstList), <span class="hljs-built_in">len</span>(secondList)<br>    i, j := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> i &lt; m &amp;&amp; j &lt; n &#123;<br>        firstStart, firstEnd := firstList[i][<span class="hljs-number">0</span>], firstList[i][<span class="hljs-number">1</span>]<br>        secondStart, secondEnd := secondList[j][<span class="hljs-number">0</span>], secondList[j][<span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment">// 两个区间存在交集</span><br>        <span class="hljs-keyword">if</span> secondEnd &gt;= firstStart &amp;&amp; firstEnd &gt;= secondStart &#123;<br>            result = <span class="hljs-built_in">append</span>(result, []<span class="hljs-keyword">int</span>&#123;max(firstStart, secondStart), min(firstEnd, secondEnd)&#125;)<br>        &#125;<br>        <span class="hljs-keyword">if</span> secondEnd &lt; firstEnd  &#123;<br>            j++<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            i++<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>区间调度问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并区间</title>
    <link href="/leetcode/fucking-algorithm/merge-intervals/"/>
    <url>/leetcode/fucking-algorithm/merge-intervals/</url>
    
    <content type="html"><![CDATA[<h1 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h1><p><a href="https://leetcode-cn.com/problems/merge-intervals/">https://leetcode-cn.com/problems/merge-intervals/</a></p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>跟上一题几乎一样，依照惯例，按区间<strong>起点升序</strong>对区间排序，如果起点相同则按<strong>终点降序</strong>排序。</p><p><img src="https://labuladong.gitee.io/algo/images/mergeInterval/1.jpg"></p><p>排序后，香菱区间的相对关系只需要考虑 2 种情况：</p><ol><li>区间相交，可以视作合并为一个更大的区间</li><li>区间不相交</li></ol><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(intervals [][]<span class="hljs-keyword">int</span>)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] == intervals[j][<span class="hljs-number">0</span>] &#123;<br>            <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">1</span>] &gt; intervals[j][<span class="hljs-number">1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]<br>        &#125;<br>    &#125;)<br><br>    result := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<br>    <br>    left, right := intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(intervals); i++ &#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &lt;= right &amp;&amp; intervals[i][<span class="hljs-number">1</span>] &gt; right &#123;<br>            <span class="hljs-comment">// 区间相交，更新合并</span><br>            right = intervals[i][<span class="hljs-number">1</span>]<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &gt; right &#123;<br>            <span class="hljs-comment">// 区间完全不相交，记录上一个大区间，更新下一个区间的开始结束</span><br>            result = <span class="hljs-built_in">append</span>(result, []<span class="hljs-keyword">int</span>&#123;left, right&#125;)<br><br>            left = intervals[i][<span class="hljs-number">0</span>]<br>            right = intervals[i][<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 记录最后一个区间</span><br>    result = <span class="hljs-built_in">append</span>(result, []<span class="hljs-keyword">int</span>&#123;left, right&#125;)<br><br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>区间调度问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除被覆盖区间</title>
    <link href="/leetcode/fucking-algorithm/remove-covered-intervals/"/>
    <url>/leetcode/fucking-algorithm/remove-covered-intervals/</url>
    
    <content type="html"><![CDATA[<h1 id="删除被覆盖区间"><a href="#删除被覆盖区间" class="headerlink" title="删除被覆盖区间"></a>删除被覆盖区间</h1><p><a href="https://leetcode-cn.com/problems/remove-covered-intervals/">https://leetcode-cn.com/problems/remove-covered-intervals/</a></p><h2 id="排序并观察"><a href="#排序并观察" class="headerlink" title="排序并观察"></a>排序并观察</h2><p>依照惯例，按区间<strong>起点升序</strong>对区间排序，如果起点相同则按<strong>终点降序</strong>排序。</p><p><img src="https://labuladong.gitee.io/algo/images/mergeInterval/1.jpg"></p><p>排序后，香菱区间的相对关系只有 3 个可能：</p><p><img src="https://labuladong.gitee.io/algo/images/%e5%8c%ba%e9%97%b4%e5%90%88%e9%9b%86/1.jpeg"></p><ol><li>找到了覆盖的区间</li><li>区间相交，可以视作合并为一个更大的区间</li><li>区间不相交</li></ol><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeCoveredIntervals</span><span class="hljs-params">(intervals [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] == intervals[j][<span class="hljs-number">0</span>] &#123;<br>            <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">1</span>] &gt; intervals[j][<span class="hljs-number">1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">0</span>] &lt; intervals[j][<span class="hljs-number">0</span>]<br>        &#125;<br>    &#125;)<br><br>    left, right := intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    count := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(intervals); i++ &#123;<br>        <span class="hljs-comment">// 找到覆盖区间</span><br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &gt;= left &amp;&amp; intervals[i][<span class="hljs-number">1</span>] &lt;= right &#123;<br>            count++<br>        &#125;<br><br>        <span class="hljs-comment">// 区间相交</span><br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &gt;= left &amp;&amp; intervals[i][<span class="hljs-number">1</span>] &gt; right &#123;<br>            right = intervals[i][<span class="hljs-number">1</span>]<br>        &#125;<br><br>        <span class="hljs-comment">// 区间不相交，更新起点终点</span><br>        <span class="hljs-keyword">if</span> intervals[i][<span class="hljs-number">0</span>] &gt; right &#123;<br>            left = intervals[i][<span class="hljs-number">0</span>]<br>            right = intervals[i][<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(intervals) - count<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>区间调度问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>视频拼接</title>
    <link href="/leetcode/fucking-algorithm/video-stitching/"/>
    <url>/leetcode/fucking-algorithm/video-stitching/</url>
    
    <content type="html"><![CDATA[<h1 id="视频拼接"><a href="#视频拼接" class="headerlink" title="视频拼接"></a>视频拼接</h1><p><a href="https://leetcode-cn.com/problems/video-stitching/">https://leetcode-cn.com/problems/video-stitching/</a></p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>这道题其实是求最少用多少个区间能覆盖完整个区间。</p><p>按视频区间<strong>起点升序</strong>对区间排序，如果起点相同则按<strong>终点降序</strong>排序。使用贪心策略，在第一个区间的终点，寻找下一个终点最长的区间，依此类推。</p><p><img src="https://labuladong.gitee.io/algo/images/%e5%89%aa%e8%a7%86%e9%a2%91/4.jpeg"></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">videoStitching</span><span class="hljs-params">(clips [][]<span class="hljs-keyword">int</span>, time <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    sort.Slice(clips, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>        <span class="hljs-keyword">if</span> clips[i][<span class="hljs-number">0</span>] == clips[j][<span class="hljs-number">0</span>] &#123;<br>            <span class="hljs-keyword">return</span> clips[i][<span class="hljs-number">1</span>] &gt; clips[j][<span class="hljs-number">1</span>]<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> clips[i][<span class="hljs-number">0</span>] &lt; clips[j][<span class="hljs-number">0</span>]<br>        &#125;<br>    &#125;)<br><br>    n := <span class="hljs-built_in">len</span>(clips)<br>    count := <span class="hljs-number">0</span><br>    currEnd, nextEnd := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n &amp;&amp; clips[i][<span class="hljs-number">0</span>] &lt;= currEnd; &#123;<br>        <span class="hljs-keyword">for</span> i &lt; n &amp;&amp; clips[i][<span class="hljs-number">0</span>] &lt;= currEnd &#123;<br>            <span class="hljs-comment">// 寻找区间起点在 currEnd 前、区间终点最大的区间作为下一个区间</span><br>            nextEnd = max(nextEnd, clips[i][<span class="hljs-number">1</span>])<br>            i++<br>        &#125;<br><br>        <span class="hljs-comment">// 选择这个区间，更新 currEnd 为这个区间的终点</span><br>        count++<br>        currEnd = nextEnd<br><br>        <span class="hljs-comment">// 如果终点已经到达视频终点了，则可以拼凑出完整视频</span><br>        <span class="hljs-keyword">if</span> currEnd &gt;= time &#123;<br>            <span class="hljs-keyword">return</span> count<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &gt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加油站</title>
    <link href="/leetcode/fucking-algorithm/gas-station/"/>
    <url>/leetcode/fucking-algorithm/gas-station/</url>
    
    <content type="html"><![CDATA[<h1 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h1><p><a href="https://leetcode-cn.com/problems/gas-station/">https://leetcode-cn.com/problems/gas-station/</a></p><h2 id="画图法"><a href="#画图法" class="headerlink" title="画图法"></a>画图法</h2><p>我们需要判断这个环形数组中是否能够找到一个起点 start，使得从这个起点开始，<code>gas</code> 和 <code>cost</code> 的累加和一直大于等于 0。</p><p><img src="https://labuladong.gitee.io/algo/images/%e8%80%81%e5%8f%b8%e6%9c%ba/3.jpeg" alt="假设把 0 作为起点"></p><p>可以看出其中有一段路 <code>sum</code> 小于 0 了，是不行的。如果把图像的最低点作为起点，就能让图像整体平移上去，保证了一直 大于等于 0。</p><p><img src="https://labuladong.gitee.io/algo/images/%e8%80%81%e5%8f%b8%e6%9c%ba/4.jpeg"></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(gas []<span class="hljs-keyword">int</span>, cost []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(gas)<br>    sum := <span class="hljs-number">0</span><br>    minSum := <span class="hljs-number">0</span><br>    start := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        sum += gas[i] - cost[i]<br>        <span class="hljs-keyword">if</span> sum &lt; minSum &#123;<br>            start = i + <span class="hljs-number">1</span><br>            minSum = sum<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> start == n &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> start<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h2><p>基于以下结论：<strong>如果选择站点 i 作为起点「恰好」无法走到站点 j，那么 i 和 j 中间的任意站点 k 都不可能作为起点。</strong></p><p>证明：因为如果恰好无法走到站点 j，则对于途中任意 <code>i &lt; k &lt; j</code>，油箱量 <code>tank[k]</code> 都要 &gt; 0，而如果将 <code>k</code> 作为起点，则 <code>tank[k] == 0</code>，无法满足条件。</p><p>根据这个条件，我们可以一次遍历起点，从 0 开始，如果发现哪里走不动了，说明这个点以前的都不可能是起点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canCompleteCircuit</span><span class="hljs-params">(gas []<span class="hljs-keyword">int</span>, cost []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(gas)<br>    sum, tank, start:= <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        sum += gas[i] - cost[i]<br>        tank += gas[i] - cost[i]<br>        <span class="hljs-keyword">if</span> tank &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-comment">// 重设下一个点为起点</span><br>            tank = <span class="hljs-number">0</span><br>            start = i + <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> sum &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> start == n &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> start<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跃游戏 II</title>
    <link href="/leetcode/fucking-algorithm/jump-game-ii/"/>
    <url>/leetcode/fucking-algorithm/jump-game-ii/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跃游戏-II"><a href="#跳跃游戏-II" class="headerlink" title="跳跃游戏 II"></a>跳跃游戏 II</h1><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">https://leetcode-cn.com/problems/jump-game-ii/</a></p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>一开始能挑到的最远范围设为 <code>end</code>。在能跳到的范围内，选择那个下一步能跳最远的点，更新 <code>end</code> 为最远距离，跳跃数加一，且在这个新的范围内寻找下一步能跳最远的。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">jump</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    end, farthest := <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    count := <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++ &#123;<br>        farthest = max(farthest, i + nums[i])<br>        <span class="hljs-comment">// 尝试过区间 end 为止所有的跳法后，选择最远的跳，更新能跳到的最远终点，跳跃数 + 1</span><br>        <span class="hljs-keyword">if</span> i == end &#123;<br>            count++<br>            end = farthest<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &gt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳跃游戏</title>
    <link href="/leetcode/fucking-algorithm/jump-game/"/>
    <url>/leetcode/fucking-algorithm/jump-game/</url>
    
    <content type="html"><![CDATA[<h1 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h1><p><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>在每一个位置都尝试跳到最远，最终结果一直取全局最远。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canJump</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br>    farthest := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++ &#123;<br>        <span class="hljs-comment">// 判断在每一个位置上能跳到的最远距离</span><br>        farthest = max(farthest, i + nums[i])<br><br>        <span class="hljs-comment">// 跳跃后，最远距离等于当前位置，说明这个位置上遇到了 0，跳不动了</span><br>        <span class="hljs-comment">// 且这个位置不是最终的位置 (i != n - 1)</span><br>        <span class="hljs-keyword">if</span> farthest &lt;= i &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 最远能否到最后一个位置</span><br>    <span class="hljs-keyword">return</span> farthest &gt;= n - <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &gt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用最少数量的箭引爆气球</title>
    <link href="/leetcode/fucking-algorithm/minimum-number-of-arrows-to-burst-balloons/"/>
    <url>/leetcode/fucking-algorithm/minimum-number-of-arrows-to-burst-balloons/</url>
    
    <content type="html"><![CDATA[<h1 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h1><p><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/</a></p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>此题等价于找出最多有多少个不重叠区间，每一个不重叠区间都需要一支箭来射爆。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findMinArrowShots</span><span class="hljs-params">(points [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    sort.Slice(points, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>        <span class="hljs-keyword">return</span> points[i][<span class="hljs-number">1</span>] &lt; points[j][<span class="hljs-number">1</span>]<br>    &#125;)<br><br>    count := <span class="hljs-number">1</span><br>    end := points[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> _, point := <span class="hljs-keyword">range</span> points &#123;<br>        <span class="hljs-keyword">if</span> point[<span class="hljs-number">0</span>] &gt; end &#123;<br>            count++<br>            end = point[<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心算法</tag>
      
      <tag>区间调度问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无重叠区间</title>
    <link href="/leetcode/fucking-algorithm/non-overlapping-intervals/"/>
    <url>/leetcode/fucking-algorithm/non-overlapping-intervals/</url>
    
    <content type="html"><![CDATA[<h1 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h1><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">https://leetcode-cn.com/problems/non-overlapping-intervals/</a></p><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>按照区间终点从小到大排序，从最小终点的区间开始依次选择不重叠区间。最终得到最多有多少个不重叠的区间，用总区间数目减去最多不重叠的数量，就是要求的删除区间的个数。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">eraseOverlapIntervals</span><span class="hljs-params">(intervals [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    sort.Slice(intervals, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>        <span class="hljs-keyword">return</span> intervals[i][<span class="hljs-number">1</span>] &lt; intervals[j][<span class="hljs-number">1</span>]<br>    &#125;)<br><br>    count := <span class="hljs-number">1</span><br>    x_end := intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> _, interval := <span class="hljs-keyword">range</span> intervals &#123;<br>        <span class="hljs-keyword">if</span> interval[<span class="hljs-number">0</span>] &gt;= x_end &#123;<br>            count++<br>            x_end = interval[<span class="hljs-number">1</span>]<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(intervals) - count<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>贪心算法</tag>
      
      <tag>区间调度问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>让字符串成为回文串的最少插入次数</title>
    <link href="/leetcode/fucking-algorithm/minimum-insertion-steps-to-make-a-string-palindrome/"/>
    <url>/leetcode/fucking-algorithm/minimum-insertion-steps-to-make-a-string-palindrome/</url>
    
    <content type="html"><![CDATA[<h1 id="让字符串成为回文串的最少插入次数"><a href="#让字符串成为回文串的最少插入次数" class="headerlink" title="让字符串成为回文串的最少插入次数"></a>让字符串成为回文串的最少插入次数</h1><p><a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/">https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>解决回文问题其实都差不多，用二维 DP 表表示状态，然后从两端看字符匹配与否。</p><p>这里 <code>dp[i][j]</code> 表示让字符串 <code>s[i..j]</code> 成为回文串所需要的最少插入次数。</p><p>base case 很简单，当 <code>i == j</code> 时或空串时，字符串自己就是回文了，无需任何操作，为 0。</p><p>现在知道了 <code>dp[i+1][j-1]</code>，要想知道 <code>dp[i][j]</code>，只需要看 <code>s[i]</code> 和 <code>s[j]</code>两个字符（因为中间的已经可以视作是回文了。如果它们已经相等了，则无需任何操作；如果不相等，往其中一边插入一个字符（不一定需要两边都插）。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minInsertions</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                <span class="hljs-comment">// 相等，无需操作</span><br>                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 不相等，往其中一侧插入，取操作数最少的那一侧</span><br>                dp[i][j] = <span class="hljs-number">1</span> + min(dp[i][j<span class="hljs-number">-1</span>], dp[i+<span class="hljs-number">1</span>][j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &lt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>石子游戏</title>
    <link href="/leetcode/fucking-algorithm/stone-game/"/>
    <url>/leetcode/fucking-algorithm/stone-game/</url>
    
    <content type="html"><![CDATA[<h1 id="石子游戏"><a href="#石子游戏" class="headerlink" title="石子游戏"></a>石子游戏</h1><p><a href="https://leetcode-cn.com/problems/stone-game/">https://leetcode-cn.com/problems/stone-game/</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>DP 表定义：面对 <code>[i, j]</code> 之间的石头，先、后手的人分别能获得的最大石头数量。<code>dp[i][j][0]</code> 表示先手所得的最大石头，<code>dp[i][j][1]</code> 表示后手所得的最大石头。</p><p>由于石头只能从两端拿，如果先手拿了左边的，则石头变为 <code>[i+1, j]</code>，且自己转换为后手，即自己的下一步能获得的最大石头 <code>dp[i+1][j][1]</code>。同理，后手者等待先手拿完后，面对 <code>[i+1, j]</code> 这一堆石头，自己变成了先手，能获得的最大石头为 <code>dp[i+1][j][0]</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stoneGame</span><span class="hljs-params">(piles []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(piles)<br>    dp := <span class="hljs-built_in">make</span>([][][]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> dp[i] &#123;<br>            dp[i][j] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// base case: 当只剩下 1 堆石头时，先手者获得这些石头</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        dp[i][i][<span class="hljs-number">0</span>] = piles[i]<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历顺序：由 DP 表图示决定</span><br>    <span class="hljs-keyword">for</span> i := n<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i+<span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br><br>            left := piles[i] + dp[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>]   <span class="hljs-comment">// 拿了左边的，石堆从左边减少，自己变后手</span><br>            right := piles[j] + dp[i][j<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]  <span class="hljs-comment">// 拿了右边的，石堆从右边减少，自己边后手</span><br><br>            <span class="hljs-comment">// 先手的人选择最终结果最大的</span><br>            <span class="hljs-keyword">if</span> left &gt; right &#123;<br>                dp[i][j][<span class="hljs-number">0</span>] = left<br>                dp[i][j][<span class="hljs-number">1</span>] = dp[i+<span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]  <span class="hljs-comment">// 后手成为下一个石堆状态的先手</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j][<span class="hljs-number">0</span>] = right<br>                dp[i][j][<span class="hljs-number">1</span>] = dp[i][j<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] <span class="hljs-comment">// 后手成为下一个石堆状态的先手</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] &gt; dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]  <span class="hljs-comment">// 判断游戏的先手者是否胜利</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>戳气球</title>
    <link href="/leetcode/fucking-algorithm/burst-balloons/"/>
    <url>/leetcode/fucking-algorithm/burst-balloons/</url>
    
    <content type="html"><![CDATA[<h1 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h1><p><a href="https://leetcode-cn.com/problems/burst-balloons/">https://leetcode-cn.com/problems/burst-balloons/</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>DP 表定义：戳破 <code>(i, j)</code> 之间的气球（不包括 <code>i</code> 和 <code>j</code>）能获得的最大分数为 <code>dp[i][j]</code>。按这个定义，要求的是 <code>dp[0][n + 1]</code> （已经在两端加入了分数为 1 的虚拟气球）。</p><p>反向思考，假设最后一个戳破的气球为 <code>k</code>，则最后一个戳破 <code>k</code>，则先要把 <code>i</code> 到 <code>k</code> 之间和 <code>k</code> 到 <code>j</code> 之间的气球戳破，破了以后香菱的气球就是正好是 <code>i</code> 跟 <code>j</code>。而这两个区间的气球戳破后的最大分数就是 <code>dp[i][k]</code> 和 <code>dp[k][j]</code>。</p><p>最后画出 DP 表，由于计算 <code>dp[i][j]</code> 时要算出所有的 <code>dp[i][k]</code> 和 <code>dp[k][j]</code> (<code>i &lt; k &lt; j</code>)，需要按图示两种顺序遍历，这里选择后面的横向遍历。</p><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/5.jpg" alt="DP 表的遍历顺序"></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxCoins</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(nums)<br><br>    <span class="hljs-comment">// 加入两个虚拟气球</span><br>    points := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">2</span>)<br>    points[<span class="hljs-number">0</span>], points[n + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        points[i] = nums[i<span class="hljs-number">-1</span>]<br>    &#125;<br><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">2</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// i 和 j 的遍历顺序根据 DP 表图示</span><br>    <span class="hljs-keyword">for</span> i := n; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt;= n + <span class="hljs-number">1</span>; j++ &#123;<br>            <span class="hljs-comment">// 最后戳破哪个气球，都尝试一遍</span><br>            <span class="hljs-keyword">for</span> k := i + <span class="hljs-number">1</span>; k &lt; j; k++ &#123;<br>                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + points[i]*points[k]*points[j])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n+<span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &gt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式匹配</title>
    <link href="/leetcode/fucking-algorithm/regular-expression-matching/"/>
    <url>/leetcode/fucking-algorithm/regular-expression-matching/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h1><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>DP 函数定义：若 <code>dp(s, i, p, j) = true</code>，则表示 <code>s[i..]</code> 可以匹配 <code>p[j..]</code>；若 <code>dp(s, i, p, j) = false</code>，则表示 <code>s[i..]</code> 无法匹配 <code>p[j..]</code>。</p><p>由于 <code>*</code> 通配符可以匹配 0 个或任意个字符，因此每一次匹配 <code>s[i]</code> 和 <code>p[j]</code> 时，都要考虑 <code>p[j]</code> 下一个会不会是 <code>*</code>，然后做特殊处理。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> memo <span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, p <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    memo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">bool</span>)<br>    <span class="hljs-keyword">return</span> dp(s, <span class="hljs-number">0</span>, p, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>, p <span class="hljs-keyword">string</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-comment">// base case: 模式匹配完，如果字符串也匹配完，则成功</span><br>    <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(p) &#123;<br>        <span class="hljs-keyword">return</span> i == <span class="hljs-built_in">len</span>(s)<br>    &#125;<br>    <span class="hljs-comment">// base case: 字符串匹配完，模式要么匹配完，要么是 a*b*c* 的形式（因此剩下长度必须是偶数）</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(s) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(p) - j) % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> ; j + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(p); j += <span class="hljs-number">2</span> &#123;<br>            <span class="hljs-keyword">if</span> p[j+<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;]; ok &#123;<br>        <span class="hljs-keyword">return</span> v<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> s[i] == p[j] || p[j] == <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>        <span class="hljs-comment">// 匹配</span><br>        <span class="hljs-keyword">if</span> j + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(p) &amp;&amp; p[j+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>            <span class="hljs-comment">// 下一个模式是 * 通配符</span><br>            res := dp(s, i, p, j+<span class="hljs-number">2</span>) || dp(s, i+<span class="hljs-number">1</span>, p, j) <span class="hljs-comment">// 匹配 0 次或多次</span><br>            memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;] = res<br>            <span class="hljs-keyword">return</span> res<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res := dp(s, i+<span class="hljs-number">1</span>, p, j+<span class="hljs-number">1</span>)<br>            memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;] = res<br>            <span class="hljs-keyword">return</span> res<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 不匹配</span><br>        <span class="hljs-keyword">if</span> j + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(p) &amp;&amp; p[j+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span> &#123;<br>            <span class="hljs-comment">// 下一个模式是 * 通配符</span><br>            res := dp(s, i, p, j+<span class="hljs-number">2</span>) <span class="hljs-comment">// 匹配当前字符 0 次</span><br>            memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;] = res<br>            <span class="hljs-keyword">return</span> res<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            res := <span class="hljs-literal">false</span><br>            memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;] = res<br>            <span class="hljs-keyword">return</span> res<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K 站中转内最便宜的航班</title>
    <link href="/leetcode/fucking-algorithm/cheapest-flights-within-k-stops/"/>
    <url>/leetcode/fucking-algorithm/cheapest-flights-within-k-stops/</url>
    
    <content type="html"><![CDATA[<h1 id="K-站中转内最便宜的航班"><a href="#K-站中转内最便宜的航班" class="headerlink" title="K 站中转内最便宜的航班"></a>K 站中转内最便宜的航班</h1><p><a href="https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/">https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>DP 函数定义：从起点 <code>src</code> 出发，<code>k</code> 步之内（一步就是一条边）到达节点 <code>s</code> 的最小路径权重为 <code>dp(s, k)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> SRC, DST <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> memo [][]<span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> indegree <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][][]<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findCheapestPrice</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>, flights [][]<span class="hljs-keyword">int</span>, src <span class="hljs-keyword">int</span>, dst <span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    SRC, DST = src, dst<br><br>    memo = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> memo &#123;<br>        memo[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, k+<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> memo[i] &#123;<br>            memo[i][j] = <span class="hljs-number">-100</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 记录每个节点的入节点以及价格</span><br>    indegree = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][][]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">for</span> _, flight := <span class="hljs-keyword">range</span> flights &#123;<br>        indegree[flight[<span class="hljs-number">1</span>]] = <span class="hljs-built_in">append</span>(indegree[flight[<span class="hljs-number">1</span>]], []<span class="hljs-keyword">int</span>&#123;flight[<span class="hljs-number">0</span>], flight[<span class="hljs-number">2</span>]&#125;)<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> dp(dst, k+<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(s <span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case：到达起点</span><br>    <span class="hljs-keyword">if</span> s == SRC &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-comment">// base case：达到次数限制</span><br>    <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> memo[s][k] != <span class="hljs-number">-100</span> &#123;<br>        <span class="hljs-keyword">return</span> memo[s][k]<br>    &#125;<br><br>    res := math.MaxInt16<br><br>    <span class="hljs-keyword">if</span> inNodes, ok := indegree[s]; ok &#123;<br>        <span class="hljs-keyword">for</span> _, node := <span class="hljs-keyword">range</span> inNodes &#123;<br>            from, price := node[<span class="hljs-number">0</span>], node[<span class="hljs-number">1</span>]<br>            subProblem := dp(from, k - <span class="hljs-number">1</span>) <span class="hljs-comment">// 追寻到达前一个节点的最低代价，次数限制减少</span><br>            <span class="hljs-keyword">if</span> subProblem != <span class="hljs-number">-1</span> &#123;<br>                res = min(res, subProblem + price)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> res == math.MaxInt16 &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    memo[s][k] = res<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &lt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自由之路</title>
    <link href="/leetcode/fucking-algorithm/freedom-trail/"/>
    <url>/leetcode/fucking-algorithm/freedom-trail/</url>
    
    <content type="html"><![CDATA[<h1 id="自由之路"><a href="#自由之路" class="headerlink" title="自由之路"></a>自由之路</h1><p><a href="https://leetcode-cn.com/problems/freedom-trail/">https://leetcode-cn.com/problems/freedom-trail/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>DP 函数定义：当圆盘指针指向 <code>ring[i]</code> 时，输入字符串 <code>key[j..]</code> 至少需要 <code>dp(ring, i, key, j)</code> 次操作。按照这个定义就是求 <code>dp(ring, 0, key, 0)</code>。</p><p>一个字符可能出现在圆盘上多次，拨动到哪一个上面，答案是都试一次。顺时针还是逆时针拨，判断哪个操作数更少。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> memo [][]<span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> charToIndex <span class="hljs-keyword">map</span>[<span class="hljs-keyword">rune</span>][]<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRotateSteps</span><span class="hljs-params">(ring <span class="hljs-keyword">string</span>, key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(ring), <span class="hljs-built_in">len</span>(key)<br>    memo = <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> memo &#123;<br>        memo[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    &#125;<br>    charToIndex = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">rune</span>][]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-comment">// 记录盘上每一个字符的位置</span><br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> ring &#123;<br>        charToIndex[v] = <span class="hljs-built_in">append</span>(charToIndex[v], i)<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp(ring, <span class="hljs-number">0</span>, key, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(ring <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>, key <span class="hljs-keyword">string</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case: 已经完成输入</span><br>    <span class="hljs-keyword">if</span> j == <span class="hljs-built_in">len</span>(key) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> memo[i][j] != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> memo[i][j]<br>    &#125;<br>    <br>    m := <span class="hljs-built_in">len</span>(ring)<br>    res := math.MaxInt16<br><br>    <span class="hljs-comment">// 尝试拨动指针到当前字母 key[j] 在转盘上的每一个位置 k</span><br>    <span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> charToIndex[<span class="hljs-keyword">rune</span>(key[j])] &#123;<br>        delta := abs(k - i)  <span class="hljs-comment">// 计算拨动指针的次数</span><br>        delta = min(delta, m - delta)  <span class="hljs-comment">// 顺时针和逆时针哪个近</span><br><br>        subProblem := dp(ring, k, key, j + <span class="hljs-number">1</span>)  <span class="hljs-comment">// 拨动后当前位置是 k，继续输入</span><br>        res = min(res, <span class="hljs-number">1</span> + delta + subProblem)<br>    &#125;<br><br>    memo[i][j] = res<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">abs</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt;= <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> -a<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &lt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地下城游戏</title>
    <link href="/leetcode/fucking-algorithm/dungeon-game/"/>
    <url>/leetcode/fucking-algorithm/dungeon-game/</url>
    
    <content type="html"><![CDATA[<h1 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a>地下城游戏</h1><p><a href="https://leetcode-cn.com/problems/dungeon-game/">https://leetcode-cn.com/problems/dungeon-game/</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>跟 <a href="https://leetcode-cn.com/problems/minimum-path-sum/">最小路径和</a> 有点像，但是不同。由于会扣血，且骑士<strong>任意时刻的生命值不能低于 1</strong>，在选择下一个格子怎么走时，必须知道当前的血量。如果把 DP 表定义为走到 <code>grid[i][j]</code> 时所需的最少生命值，就无法得知当前的生命值了，就不能保证生命值一直大于 1 了。</p><p>重新定义 DP 表为：从 <code>grid[i][j]</code> 到达终点（右下角）所需的最少生命值是 <code>dp[i][j]</code>。因此如果知道了 <code>dp[i+1][j]</code> 和 <code>dp[i][j+1]</code>，就能根据当前格子状态 <code>grid[i][j]</code> 推断出 <code>dp[i][j]</code> 了。最终求的是 <code>dp[0][0]</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateMinimumHP</span><span class="hljs-params">(dungeon [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(dungeon), <span class="hljs-built_in">len</span>(dungeon[<span class="hljs-number">0</span>])<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    &#125;<br><br>    <span class="hljs-comment">// base case: 最后一格需要的血量</span><br>    <span class="hljs-keyword">if</span> dungeon[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> &#123;<br>        dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span> - dungeon[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>    &#125;<br><br>    <span class="hljs-comment">// base case: 沿着最下面和最右边走的路线</span><br>    <span class="hljs-keyword">for</span> i := m - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        dp[i][n<span class="hljs-number">-1</span>] = dp[i+<span class="hljs-number">1</span>][n<span class="hljs-number">-1</span>] - dungeon[i][n<span class="hljs-number">-1</span>]<br>        <span class="hljs-keyword">if</span> dp[i][n<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">1</span> &#123;  <span class="hljs-comment">// 保证血量不低于 1</span><br>            dp[i][n<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := n - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>        dp[m<span class="hljs-number">-1</span>][j] = dp[m<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>] - dungeon[m<span class="hljs-number">-1</span>][j]<br>        <span class="hljs-keyword">if</span> dp[m<span class="hljs-number">-1</span>][j] &lt; <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 保证血量不低于 1</span><br>            dp[m<span class="hljs-number">-1</span>][j] = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := m<span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := n<span class="hljs-number">-2</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            dp[i][j] = min(dp[i+<span class="hljs-number">1</span>][j], dp[i][j+<span class="hljs-number">1</span>]) - dungeon[i][j]<br>            <span class="hljs-keyword">if</span> dp[i][j] &lt; <span class="hljs-number">1</span> &#123; <span class="hljs-comment">// 保证血量不低于 1</span><br>                dp[i][j] = <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &lt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="空间压缩"><a href="#空间压缩" class="headerlink" title="空间压缩"></a>空间压缩</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculateMinimumHP</span><span class="hljs-params">(dungeon [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(dungeon), <span class="hljs-built_in">len</span>(dungeon[<span class="hljs-number">0</span>])<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, m)<br><br>    <span class="hljs-keyword">if</span> dungeon[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>] &gt; <span class="hljs-number">0</span> &#123;<br>        dp[m<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        dp[m<span class="hljs-number">-1</span>]= <span class="hljs-number">1</span> - dungeon[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := m - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        dp[i] = dp[i+<span class="hljs-number">1</span>] - dungeon[i][n<span class="hljs-number">-1</span>]<br>        <span class="hljs-keyword">if</span> dp[i] &lt; <span class="hljs-number">1</span> &#123;<br>            dp[i] = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> j := n<span class="hljs-number">-2</span>; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>        dp[m<span class="hljs-number">-1</span>] = dp[m<span class="hljs-number">-1</span>] - dungeon[m<span class="hljs-number">-1</span>][j]<br>        <span class="hljs-keyword">if</span> dp[m<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">1</span> &#123;<br>            dp[m<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> i := m<span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>            dp[i] = min(dp[i+<span class="hljs-number">1</span>], dp[i]) - dungeon[i][j]<br>            <span class="hljs-keyword">if</span> dp[i] &lt; <span class="hljs-number">1</span> &#123;<br>                dp[i] = <span class="hljs-number">1</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &lt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小路径和</title>
    <link href="/leetcode/fucking-algorithm/minimum-path-sum/"/>
    <url>/leetcode/fucking-algorithm/minimum-path-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h1><p><a href="https://leetcode-cn.com/problems/minimum-path-sum/">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    &#125;<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + grid[i][<span class="hljs-number">0</span>]<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + grid[<span class="hljs-number">0</span>][j]<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>]) + grid[i][j]<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &lt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="空间压缩"><a href="#空间压缩" class="headerlink" title="空间压缩"></a>空间压缩</h2><p><img src="https://labuladong.gitee.io/algo/images/%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e5%92%8c/1.jpeg"></p><p>很容易看出来，得到初始值后可以逐行更新，每一行的结果只依赖于上一行以及自己的前一个结果，可以按从上到下、从左到右的顺序遍历，只需要 1 维的 DP 数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(grid [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m, n := <span class="hljs-built_in">len</span>(grid), <span class="hljs-built_in">len</span>(grid[<span class="hljs-number">0</span>])<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, m)<br>    <br>    dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] + grid[i][<span class="hljs-number">0</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][j] + dp[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; m; i++ &#123;<br>            dp[i] = min(dp[i<span class="hljs-number">-1</span>], dp[i]) + grid[i][j]<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dp[m<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &lt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鸡蛋掉落</title>
    <link href="/leetcode/fucking-algorithm/super-egg-drop/"/>
    <url>/leetcode/fucking-algorithm/super-egg-drop/</url>
    
    <content type="html"><![CDATA[<h1 id="鸡蛋掉落"><a href="#鸡蛋掉落" class="headerlink" title="鸡蛋掉落"></a>鸡蛋掉落</h1><p><a href="https://leetcode-cn.com/problems/super-egg-drop/">https://leetcode-cn.com/problems/super-egg-drop/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p><strong>状态</strong>：剩余鸡蛋数量 <code>eggs</code>，剩余未测楼层数 <code>floors</code>。随着鸡蛋数量的减少，剩下的楼层数就会减少。</p><p><strong>状态转移</strong>：假设当前剩余 <code>eggs</code> 个鸡蛋和 <code>floors</code> 层楼，去第 <code>i</code> 层扔一个鸡蛋，会有 2 种情况：</p><ul><li>如果鸡蛋没碎，可以排除这层楼及以下的楼层，剩余楼层数为 <code>floors - i</code>；</li><li>如果鸡蛋碎了，则排除这层楼及以上的楼层，剩余楼层数为 <code>i - 1</code>，且鸡蛋少了一个。</li></ul><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/%E6%89%94%E9%B8%A1%E8%9B%8B/1.jpg" alt="状态转移"></p><p>注意，只需要关注剩下几层楼没测，而不需要关注这层楼具体是多高，因为对于每层楼我们最终都会假设它碎或不碎两种情况，相当于是把所有可能性都尝试了一次。</p><p><code>i</code> 怎么取？也就是说去哪层开始扔？答案是都试一次，扔完一个后楼层减少，继续用一样的方法尝试。关注<strong>最坏情况</strong>下<em>最少的操作数</em>，最坏情况就是扔了一次鸡蛋后剩余的楼层数最多，最少的操作数就是从每个不同的楼层 <code>i</code> 开始扔，哪个用的次数最少。即:</p><figure class="highlight python"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-number">1</span> &lt;= i &lt;= floors:<br>    res = <span class="hljs-built_in">min</span>(res, <span class="hljs-number">1</span> + <span class="hljs-built_in">max</span>(<br>        dp(eggs, floors-i),  <span class="hljs-comment"># 鸡蛋没碎，剩余上面的楼层</span><br>        dp(eggs-<span class="hljs-number">1</span>, i-<span class="hljs-number">1</span>),     <span class="hljs-comment"># 鸡蛋碎了，剩余下面的楼层，鸡蛋减一</span><br>    ))<br></code></pre></td></tr></table></figure><p>最终用备忘录减少重复计算，代码写出来就是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">superEggDrop</span><span class="hljs-params">(k <span class="hljs-keyword">int</span>, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">return</span> dp(memo, k, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo <span class="hljs-keyword">map</span>[[2]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, eggs <span class="hljs-keyword">int</span>, floors <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case:</span><br>    <span class="hljs-keyword">if</span> floors == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> eggs == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> floors<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;eggs, floors&#125;]; ok &#123;<br>        <span class="hljs-keyword">return</span> v<br>    &#125;<br><br>    times := math.MaxInt16<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= floors; i++ &#123;<br>        times = min(times, max(dp(memo, eggs<span class="hljs-number">-1</span>, i<span class="hljs-number">-1</span>), dp(memo, eggs, floors-i)) + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;eggs, floors&#125;] = times<br>    <span class="hljs-keyword">return</span> times<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &lt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &gt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>但是 leetcode 会超时。</p><h2 id="用二分搜索优化"><a href="#用二分搜索优化" class="headerlink" title="用二分搜索优化"></a>用二分搜索优化</h2><p>上面的方法有个致命的缺点，就是每次搜索都是线性搜索，且都是从 1 开始到 N，这效率并不够高，leetcode 题直接超时了。需要改进上面的线性搜索，也就是这一部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= floors; i++ &#123;<br>    times = min(times, max(dp(memo, eggs<span class="hljs-number">-1</span>, i<span class="hljs-number">-1</span>), dp(memo, eggs, floors-i)) + <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们根据 <code>dp(K, N)</code> 数组的定义（有 K 个鸡蛋面对 N 层楼，最少需要扔几次），很容易知道 <code>K</code> 固定时，这个函数一定是单调递增的，无论你策略多聪明，随着总楼层增加，测试次数一定要增加。</p><p>那么注意 <code>dp(K - 1, i - 1)</code> 和 <code>dp(K, N - i)</code> 这两个函数，其中 i 是从 1 到 N 单增的，如果我们固定 <code>K</code> 和 <code>N</code>，把这两个函数看做关于 <code>i</code> 的函数，前者随着 <code>i</code> 的增加应该也是单调递增的，而后者随着 <code>i</code> 的增加应该是单调递减的：</p><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/%E6%89%94%E9%B8%A1%E8%9B%8B/2.jpg" alt="函数图像示意"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">superEggDrop</span><span class="hljs-params">(k <span class="hljs-keyword">int</span>, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">return</span> dp(memo, k, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo <span class="hljs-keyword">map</span>[[2]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, eggs <span class="hljs-keyword">int</span>, floors <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case:</span><br>    <span class="hljs-keyword">if</span> floors == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> eggs == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> floors<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> v, ok := memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;eggs, floors&#125;]; ok &#123;<br>        <span class="hljs-keyword">return</span> v<br>    &#125;<br><br>    times := math.MaxInt16<br><br>    <span class="hljs-comment">// 改进后的二分搜索</span><br>    low, high := <span class="hljs-number">1</span>, floors<br>    <span class="hljs-keyword">for</span> low &lt;= high &#123;<br>        mid := (low + high) / <span class="hljs-number">2</span><br><br>        brokenTimes := dp(memo, eggs<span class="hljs-number">-1</span>, mid<span class="hljs-number">-1</span>)      <span class="hljs-comment">// 蛋碎了</span><br>        noBrokenTimes := dp(memo, eggs, floors-mid) <span class="hljs-comment">// 蛋没碎</span><br><br>        <span class="hljs-keyword">if</span> brokenTimes &gt; noBrokenTimes &#123;<br>            high = mid - <span class="hljs-number">1</span><br>            times = min(times, brokenTimes + <span class="hljs-number">1</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = mid + <span class="hljs-number">1</span><br>            times = min(times, noBrokenTimes + <span class="hljs-number">1</span>)<br>        &#125;<br>    &#125;<br><br>    memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;eggs, floors&#125;] = times<br>    <span class="hljs-keyword">return</span> times<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> v &lt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>此时 leetcode 终于不超时了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零钱兑换 II</title>
    <link href="/leetcode/fucking-algorithm/coin-change-2/"/>
    <url>/leetcode/fucking-algorithm/coin-change-2/</url>
    
    <content type="html"><![CDATA[<h1 id="零钱兑换-II"><a href="#零钱兑换-II" class="headerlink" title="零钱兑换 II"></a>零钱兑换 II</h1><p><a href="https://leetcode-cn.com/problems/coin-change-2/">https://leetcode-cn.com/problems/coin-change-2/</a></p><p>此题是完全背包问题，即物品数量是无限的。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>对于背包问题，DP 表 <code>dp[i][j]</code> 表示：若只使用 <code>coins</code> 中的前 <code>i</code> 个硬币的面值，若想凑出金额 <code>j</code>，有 <code>dp[i][j]</code> 种凑法。</p><ul><li>如果你不把这第 <code>i</code> 个物品装入背包，也就是说你不使用 <code>coins[i]</code> 这个面值的硬币，那么凑出面额 j 的方法数 <code>dp[i][j]</code> 应该等于 <code>dp[i-1][j]</code>，继承之前的结果。</li><li>如果你把这第 <code>i</code> 个物品装入了背包，也就是说你使用 <code>coins[i]</code> 这个面值的硬币，那么 <code>dp[i][j]</code> 应该等于 <code>dp[i][j-coins[i-1]]</code>。（注意这里是 dp[<strong>i</strong>][j-coins[i-1]] ，已经包括了再次重复使用这个硬币的情况）</li></ul><p>综上就是两种选择，而我们想求的 <code>dp[i][j]</code> 是「共有多少种凑法」，所以 <code>dp[i][j]</code> 的值应该是以上两种选择的结果之和：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>, coins []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(coins)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, amount + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// base case: 如果 amount 为 0，只有 1 种办法凑出（不放硬币）</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= amount; j++ &#123;<br>            <span class="hljs-keyword">if</span> j - coins[i<span class="hljs-number">-1</span>] &gt;= <span class="hljs-number">0</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] + dp[i][j - coins[i<span class="hljs-number">-1</span>]]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n][amount]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="压缩-DP-表"><a href="#压缩-DP-表" class="headerlink" title="压缩 DP 表"></a>压缩 DP 表</h2><p>可以看出 <code>dp[i][..]</code> 的状态总是且仅依赖于 <code>dp[i-1][..]</code> 的状态，因此可以只使用 1D 数组来完成， 每次在数组上迭代就相当于 <code>i</code> 的递增。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">change</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>, coins []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(coins)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, amount + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-comment">// base case: 如果 amount 为 0，只有 1 种办法凑出（不放硬币）</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= amount; j++ &#123;<br>            <span class="hljs-keyword">if</span> j - coins[i<span class="hljs-number">-1</span>] &gt;= <span class="hljs-number">0</span> &#123;<br>                dp[j] = dp[j] + dp[j - coins[i<span class="hljs-number">-1</span>]]<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br></code></pre></td></tr></table></figure><p>与 <a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/">分割等和子集</a> 不同，这里压缩 DP 表不需要从后遍历 <code>j</code>，因为观察压缩前的状态转移公式，<code>dp[i-1][j]</code> 只会用于更新 <code>dp[i][j]</code>，可以直接覆盖掉而不影响其它结果。</p><p>（在上一题中，<code>dp[i-1][j]</code> 可能会用于更新 <code>dp[i][j + nums[i]]</code> 的值，如果从头开始遍历，更新到 <code>dp[i-1][j + nums[i]]</code> 时，<code>dp[i-1][j]</code> 已经先于它更新了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分割等和子集</title>
    <link href="/leetcode/fucking-algorithm/partition-equal-subset-sum/"/>
    <url>/leetcode/fucking-algorithm/partition-equal-subset-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h1><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p><p>此问题可以转换为背包问题。首先对数组求和然后除以2，得出单个子集的总和 <code>sum/2</code>，显然问题就是要从数组中选出几个数使得总和为 <code>sum/2</code>。就类似于背包问题，在这里只需要把“背包”填满即可。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>对于背包问题，DP 表 <code>dp[i][w]</code> 表示：对于前 <code>i</code> 个物品，当前背包的容量为 <code>w</code> 时，这种情况下可以装下的最大价值是 <code>dp[i][w]</code>。</p><p>在遍历到 <code>i</code> 时，如果当前容量为 <code>w</code>，我们要么把物品 <code>i</code> 装入背包，要么不装。</p><ul><li>如果不装，则没有变化，<code>dp[i][w]</code> 继承 <code>dp[i-1][w]</code> 的值。</li><li>如果装入背包，则加上装入物品的价值，并且寻找背包容量 <code>w</code> 减少后能装入（之前的物品）的最大价值，即 <code>dp[i-1][w - weight[i]]</code>。这两项加起来就是装入这个物品后的最大价值，即<code>dp[i][j] = value[i] + dp[i-1][w - weight[i]]</code>。</li></ul><p>最后要寻求这两种情况下最大值，就是 <code>dp[i][w] = max(dp[i-1][w], dp[i-1][w - wt[i-1]] + val[i-1])</code>。</p><p>对于此题，不需要计算物品的价值，只需要知道能不能正好装满，DP 表中储存 <code>true</code> 和 <code>false</code> 即可。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += v<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 转换为背包问题</span><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    vol := <span class="hljs-keyword">int</span>(sum / <span class="hljs-number">2</span>)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">bool</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, vol + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// base cases</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= vol; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= vol; j++ &#123;<br>            <span class="hljs-keyword">if</span> j - nums[i<span class="hljs-number">-1</span>] &lt; <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-comment">// 背包容量 j 不足以装下重量为 nums[i-1] 的物品</span><br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 装或不装，选择能装的那个（有一个选择为 true 则为 true）</span><br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j] || dp[i<span class="hljs-number">-1</span>][j-nums[i<span class="hljs-number">-1</span>]]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n][vol]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="压缩-DP-表"><a href="#压缩-DP-表" class="headerlink" title="压缩 DP 表"></a>压缩 DP 表</h2><p>可以看出 <code>dp[i][..]</code> 的状态总是且仅依赖于 <code>dp[i-1][..]</code> 的状态，因此可以只使用 1D 数组来完成， 每次在数组上迭代就相当于 <code>i</code> 的递增。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    sum := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums &#123;<br>        sum += v<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 转换为背包问题</span><br>    n := <span class="hljs-built_in">len</span>(nums)<br>    vol := <span class="hljs-keyword">int</span>(sum / <span class="hljs-number">2</span>)<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">bool</span>, vol + <span class="hljs-number">1</span>)<br><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := vol; j &gt;= <span class="hljs-number">0</span>; j-- &#123;<br>            <span class="hljs-keyword">if</span> j - nums[i<span class="hljs-number">-1</span>] &gt;= <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-comment">// 装或不装，选择能装的那个（有一个选择为 true 则为 true）</span><br>                dp[j] = dp[j] || dp[j - nums[i<span class="hljs-number">-1</span>]]<br>            &#125;<br>            <span class="hljs-comment">// else: 如果不装，则什么也不用做</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[vol]<br>&#125;<br></code></pre></td></tr></table></figure><p>唯一需要注意的是 <code>j</code> 应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果。如果我们从小到大更新 <code>dp</code> 值，那么在计算 <code>dp[j]</code> 值的时候，<code>dp[j − nums[i]]</code> 已经是被更新过的状态，不再是上一行的 <code>dp</code> 值。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长回文子序列</title>
    <link href="/leetcode/fucking-algorithm/longest-palindromic-subsequence/"/>
    <url>/leetcode/fucking-algorithm/longest-palindromic-subsequence/</url>
    
    <content type="html"><![CDATA[<h1 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/">https://leetcode-cn.com/problems/longest-palindromic-subsequence/</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>对于这种一个字符串，但是需要用到双向信息的题，需要一个二维的 DP 表来储存结果。</p><p>在子数组 <code>s[i..j]</code> 中，我们要求的子序列（最长回文子序列）的长度为 <code>dp[i][j]</code></p><p>先不去想怎么求出这个长度，用数学归纳法的思想，假设已经知道了它掐头去尾的子串 <code>s[i+1, ..., j-1]</code> 中最长回文子串的长度，如何求出 <code>dp[i][j]</code> 呢？</p><p>答案是看这两个新进来的字符 <code>s[i]</code> 和 <code>s[j]</code>，如果它们相等，那一定能拼出一个更长的回文串，则 <code>dp[i][j] = dp[i+1][j-1] + 2</code>。如果它们不相等，再去看它们只加进去 1 个字符后产生的回文串长度，即 <code>dp[i][j] = dp[i][j] = max(dp[i+1][j], dp[i][j-1])</code>。</p><p>考虑完递归条件，考虑 base case。显然 base case 就是只有一个字符串时回文长度就是 1，以及空字符串为 0。最后画出 DP 表，由于我们需要求整个序列的长度 <code>dp[0][n-1]</code>，从表中可以看出 base case 和最终状态的关系，按照合适的顺序遍历表计算结果即可。</p><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/4.jpg" alt="DP 表"></p><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/5.jpg" alt="DP 表的遍历顺序"></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(s)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    &#125;<br><br>    <span class="hljs-comment">// base case: single char</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123; <br>        dp[i][i] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>        <span class="hljs-keyword">for</span> j := i + <span class="hljs-number">1</span>; j &lt; n; j++ &#123;<br>            <span class="hljs-keyword">if</span> s[i] == s[j] &#123;<br>                dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">2</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i+<span class="hljs-number">1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n<span class="hljs-number">-1</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(values ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := values[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>        <span class="hljs-keyword">if</span> res &lt; v &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 可变参数（...）</title>
    <link href="/programming/go-variadic-parameter/"/>
    <url>/programming/go-variadic-parameter/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-可变参数（点点点）"><a href="#Golang-可变参数（点点点）" class="headerlink" title="Golang 可变参数（点点点）"></a>Golang 可变参数（点点点）</h1><p>可变参数： variadic parameter</p><h2 id="在函数签名中使用"><a href="#在函数签名中使用" class="headerlink" title="在函数签名中使用"></a>在函数签名中使用</h2><p>只能用在最后一个参数的类型前，表示这个类型的参数可以有任意个。实际传入函数中的是一个切片:</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(vals ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    total := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>        total += val<br>    &#125;<br>    <span class="hljs-keyword">return</span> total<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="传入函数参数时使用"><a href="#传入函数参数时使用" class="headerlink" title="传入函数参数时使用"></a>传入函数参数时使用</h2><p>如果需要传入这个函数的原始参数已经是切片了，则传入函数时在它的后面加上 <code>...</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">values := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>fmt.Println(sum(values...)) <span class="hljs-comment">// &quot;10&quot;</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://docs.hundan.org/gopl-zh/ch5/ch5-07.html">https://docs.hundan.org/gopl-zh/ch5/ch5-07.html</a></p></li><li><p><a href="https://stackoverflow.com/questions/23669720/meaning-of-interface-dot-dot-dot-interface/23669857">https://stackoverflow.com/questions/23669720/meaning-of-interface-dot-dot-dot-interface/23669857</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>俄罗斯套娃信封问题</title>
    <link href="/leetcode/fucking-algorithm/russian-doll-envelopes/"/>
    <url>/leetcode/fucking-algorithm/russian-doll-envelopes/</url>
    
    <content type="html"><![CDATA[<h1 id="俄罗斯套娃信封问题"><a href="#俄罗斯套娃信封问题" class="headerlink" title="俄罗斯套娃信封问题"></a>俄罗斯套娃信封问题</h1><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">https://leetcode-cn.com/problems/russian-doll-envelopes/</a></p><p>此题用 Golang DP 会超出时间限制（官方代码也是）。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>利用 sort 标准库，给二维切片一个类型别名，然后在此类型上定义 <code>sort.Sort()</code> 函数所需要的 3 个方法，在 <code>Less()</code> 方法种完成比较的逻辑。排序后套用 <a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a> 的解题方法。</p><p>参考：<a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html</a></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(envelopes [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; <br>    sort.Sort(Envelopes(envelopes))<br>    <br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(envelopes))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> envelopes[j][<span class="hljs-number">1</span>] &lt; envelopes[i][<span class="hljs-number">1</span>] &#123;<br>                dp[i] = max(dp[i], dp[j] + <span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    res := math.MinInt16<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        res = max(res, dp[i])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-keyword">type</span> Envelopes [][]<span class="hljs-keyword">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(envelopes Envelopes)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(envelopes)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(envelopes Envelopes)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> envelopes[i][<span class="hljs-number">0</span>] &lt; envelopes[j][<span class="hljs-number">0</span>] &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> envelopes[i][<span class="hljs-number">0</span>] == envelopes[j][<span class="hljs-number">0</span>] &amp;&amp; envelopes[i][<span class="hljs-number">1</span>] &gt; envelopes[j][<span class="hljs-number">1</span>] &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(envelopes Envelopes)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>    envelopes[i], envelopes[j] = envelopes[j], envelopes[i]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划（官方）"><a href="#动态规划（官方）" class="headerlink" title="动态规划（官方）"></a>动态规划（官方）</h2><p>使用了 <code>sort.Slice()</code> 来对任何数据结构（空接口）的切片进行排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(envelopes [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(envelopes)<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    sort.Slice(envelopes, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>        a, b := envelopes[i], envelopes[j]<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &lt; b[<span class="hljs-number">0</span>] || a[<span class="hljs-number">0</span>] == b[<span class="hljs-number">0</span>] &amp;&amp; a[<span class="hljs-number">1</span>] &gt; b[<span class="hljs-number">1</span>]<br>    &#125;)<br><br>    f := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> f &#123;<br>        f[i] = <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> envelopes[j][<span class="hljs-number">1</span>] &lt; envelopes[i][<span class="hljs-number">1</span>] &#123;<br>                f[i] = max(f[i], f[j]+<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max(f...)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    res := a[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a[<span class="hljs-number">1</span>:] &#123;<br>        <span class="hljs-keyword">if</span> v &gt; res &#123;<br>            res = v<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个字符串的最小ASCII删除和</title>
    <link href="/leetcode/fucking-algorithm/minimum-ascii-delete-sum-for-two-strings/"/>
    <url>/leetcode/fucking-algorithm/minimum-ascii-delete-sum-for-two-strings/</url>
    
    <content type="html"><![CDATA[<h1 id="两个字符串的最小ASCII删除和"><a href="#两个字符串的最小ASCII删除和" class="headerlink" title="两个字符串的最小ASCII删除和"></a>两个字符串的最小ASCII删除和</h1><p><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">https://leetcode-cn.com/problems/delete-operation-for-two-strings/</a></p><p>跟编辑距离几乎是一样的，只是把操作数换成 ASCII 码罢了。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minimumDeleteSum</span><span class="hljs-params">(s1 <span class="hljs-keyword">string</span>, s2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">len</span>(s1)<br>    n := <span class="hljs-built_in">len</span>(s2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>] + <span class="hljs-keyword">int</span>(s1[i<span class="hljs-number">-1</span>])<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = dp[<span class="hljs-number">0</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-keyword">int</span>(s2[j<span class="hljs-number">-1</span>])<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> s1[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-keyword">int</span>(s1[i<span class="hljs-number">-1</span>]), dp[i][j<span class="hljs-number">-1</span>]+<span class="hljs-keyword">int</span>(s2[j<span class="hljs-number">-1</span>]))<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个字符串的删除操作</title>
    <link href="/leetcode/fucking-algorithm/delete-operation-for-two-strings/"/>
    <url>/leetcode/fucking-algorithm/delete-operation-for-two-strings/</url>
    
    <content type="html"><![CDATA[<h1 id="两个字符串的删除操作"><a href="#两个字符串的删除操作" class="headerlink" title="两个字符串的删除操作"></a>两个字符串的删除操作</h1><p><a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings/">https://leetcode-cn.com/problems/delete-operation-for-two-strings/</a></p><p>跟编辑距离几乎是一样的，不过是只有删除操作。</p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>核心思想：如果字符串不匹配，2 种删除操作都试一遍（删除 s1 当前字符或 s2 当前字符），找出操作数最少的。</p><p>DP 函数定义：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">len</span>(word1)<br>    n := <span class="hljs-built_in">len</span>(word2)<br>    memo := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> memo &#123;<br>        memo[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> memo[i] &#123;<br>            memo[i][j] = <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp(memo, word1, word2, m<span class="hljs-number">-1</span>, n<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo [][]<span class="hljs-keyword">int</span>, word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> j + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> j == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 查备忘录</span><br>    <span class="hljs-keyword">if</span> memo[i][j] != <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> memo[i][j]<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> word1[i] == word2[j] &#123;<br>        memo[i][j] = dp(memo, word1, word2, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> memo[i][j]<br>    &#125;<br><br>    memo[i][j] = min(dp(memo, word1, word2, i<span class="hljs-number">-1</span>, j)+<span class="hljs-number">1</span>, dp(memo, word1, word2,i,j<span class="hljs-number">-1</span>)+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> memo[i][j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>和编辑距离是一样的思路</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">len</span>(word1)<br>    n := <span class="hljs-built_in">len</span>(word2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// base cases</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    &#125;<br><br>    <span class="hljs-comment">// dp</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>, dp[i][j<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长公共子序列</title>
    <link href="/leetcode/fucking-algorithm/longest-common-subsequence/"/>
    <url>/leetcode/fucking-algorithm/longest-common-subsequence/</url>
    
    <content type="html"><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p><blockquote><p>子序列类型的问题，穷举出所有可能的结果都不容易，而动态规划算法做的就是穷举 + 剪枝，它俩天生一对儿。所以可以说只要涉及子序列问题，十有八九都需要动态规划来解决，往这方面考虑就对了。</p></blockquote><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>核心思想：如果两个字符串出现了一样的字符，那它必在 LCS 中。</p><p>用两个指针 <code>i</code> 和 <code>j</code> 从后往前遍历 s1 和 s2，如果 <code>s1[i]==s2[j]</code>，那么这个字符一定在 LCS 中；否则的话，<code>s1[i]</code> 和 <code>s2[j]</code> 这两个字符至少有一个不在 LCS 中，需要丢弃一个，即其中一个指针往前移。至于是哪个，答案是都试一次，然后取最大的。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-keyword">string</span>, text2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">len</span>(text1)<br>    n := <span class="hljs-built_in">len</span>(text2)<br>    memo := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> memo &#123;<br>        memo[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> memo[i] &#123;<br>            memo[i][j] = <span class="hljs-number">-1</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp(memo, text1, text2, <span class="hljs-built_in">len</span>(text1)<span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(text2)<span class="hljs-number">-1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo [][]<span class="hljs-keyword">int</span>, text1 <span class="hljs-keyword">string</span>, text2 <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> || j == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// 查备忘录</span><br>    <span class="hljs-keyword">if</span> memo[i][j] != <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> memo[i][j]<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> text1[i] == text2[j] &#123;<br>        memo[i][j] = <span class="hljs-number">1</span> + dp(memo, text1, text2, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>) <span class="hljs-comment">// LCS 长度加1</span><br>        <span class="hljs-keyword">return</span> memo[i][j]<br>    &#125; <br>    memo[i][j] = max(dp(memo, text1, text2, i, j<span class="hljs-number">-1</span>), dp(memo, text1, text2, i<span class="hljs-number">-1</span>, j))<br>    <span class="hljs-keyword">return</span> memo[i][j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>字符串的 DP 表一般都是比字符串本身多出一位以表示处理完（空字符串）的情况，如图：</p><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/LCS/dp.png" alt="DP 表"></p><p><code>dp[i][j]</code> 的含义是：对于 <code>s1[1..i]</code> 和 <code>s2[1..j]</code>，它们的 LCS 长度是 <code>dp[i][j]</code>。当 i 或 j 为 0 时，空串和任何字符串的 LCS 显然都是 0。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(text1 <span class="hljs-keyword">string</span>, text2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    m := <span class="hljs-built_in">len</span>(text1)<br>    n := <span class="hljs-built_in">len</span>(text2)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, m + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= m; i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= n; j++ &#123;<br>            <span class="hljs-keyword">if</span> text1[i<span class="hljs-number">-1</span>] == text2[j<span class="hljs-number">-1</span>] &#123;<br>                dp[i][j] = <span class="hljs-number">1</span> + dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = max(dp[i<span class="hljs-number">-1</span>][j], dp[i][j<span class="hljs-number">-1</span>])<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最大子数组和</title>
    <link href="/leetcode/fucking-algorithm/maximum-subarray/"/>
    <url>/leetcode/fucking-algorithm/maximum-subarray/</url>
    
    <content type="html"><![CDATA[<h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>构建 DP 数组：<code>dp[i]</code> 存储以 <code>nums[i]</code> 为结尾的最大子数组和，不用关心这个数组是从哪里开始的。如果 <code>nums[i-1]</code> 已被计算出，则对于 <code>nums[i]</code> 只有 2 种情况：要么连接上前面的子数组，要么自己成为一个子数组。取最大的即可。最后遍历 DP 数组，得到最大子序列长。</p><p>base case: 第一个元素前面没数组了，以它结尾的最大和就是它自己。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums))<br><br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment">// dp</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(nums); i++ &#123;<br>        dp[i] = max(dp[i<span class="hljs-number">-1</span>] + nums[i], nums[i])<br>    &#125;<br><br>    res := math.MinInt16<br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> dp &#123;<br>        res = max(res, v)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>下降路径最小和</title>
    <link href="/leetcode/fucking-algorithm/minimum-falling-path-sum/"/>
    <url>/leetcode/fucking-algorithm/minimum-falling-path-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a>下降路径最小和</h1><p><a href="https://leetcode-cn.com/problems/minimum-falling-path-sum/">https://leetcode-cn.com/problems/minimum-falling-path-sum/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>核心思想：下落到 <code>matrix[i][j]</code> 的最小路径，一定是 <code>matrix[i][j]</code> 自己的值，加上从它上面落下来的最小路径，即 <code>matrix[i-1][j-1]</code> <code>matrix[i-1][j]</code> <code>matrix[i-1][j+1]</code> 中最小的一个。</p><p>DP 函数定义：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>, i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 返回下落到 matrix[i][j] 的最小路径</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minFallingPathSum</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(matrix))<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> memo &#123;<br>        memo[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]))<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> memo[i] &#123;<br>            memo[i][j] = <span class="hljs-number">66666</span><br>        &#125;<br>    &#125;<br>    res := math.MaxInt32<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]); j++ &#123;<br>        res = min(res, dp(memo, matrix, <span class="hljs-built_in">len</span>(matrix)<span class="hljs-number">-1</span>, j))<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo [][]<span class="hljs-keyword">int</span>, matrix [][]<span class="hljs-keyword">int</span>, i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// invalid matrix index</span><br>    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> || j &gt;= <span class="hljs-built_in">len</span>(matrix[<span class="hljs-number">0</span>]) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">99999</span><br>    &#125;<br><br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> matrix[<span class="hljs-number">0</span>][j]<br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查备忘录</span><br>    <span class="hljs-keyword">if</span> memo[i][j] != <span class="hljs-number">66666</span> &#123;<br>        <span class="hljs-keyword">return</span> memo[i][j]<br>    &#125;<br>    v1 := dp(memo, matrix, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>)<br>    v2 := dp(memo, matrix, i<span class="hljs-number">-1</span>, j)<br>    v3 := dp(memo, matrix, i<span class="hljs-number">-1</span>, j+<span class="hljs-number">1</span>)<br><br>    v := min(v1, min(v2, v3))<br>    memo[i][j] = v + matrix[i][j]<br>    <span class="hljs-keyword">return</span> memo[i][j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><p>备忘录初始化：需要是一个不合法的值，题目给定了 <code>matrix</code> 最多是 100 x 100 的，元素在 [-100, 100] 之间，因此合法值范围为 [-10000, 10000]，备忘录初始化以及越界返回值都应该在此值之外。由于用了 <code>min()</code> 来找最小值，越界的话给一个很大的值即可。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>构建 DP 表：<code>dp[i][j]</code> 存储 下落到 <code>matrix[i][j]</code> 的最小路径和。特殊处理一下 j&#x3D;0 和 j&#x3D;n-1 的特殊情况即可，从第一行开始逐步往后加。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minFallingPathSum</span><span class="hljs-params">(matrix [][]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    n := <span class="hljs-built_in">len</span>(matrix)<br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, n)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n)<br>    &#125;<br><br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = matrix[<span class="hljs-number">0</span>][j]<br>    &#125;<br><br>    <span class="hljs-comment">// dp</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; n; i++ &#123;<br>        <span class="hljs-comment">// j == 0 </span><br>        dp[i][<span class="hljs-number">0</span>] = matrix[i][<span class="hljs-number">0</span>] + min(dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>], dp[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>])<br><br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; j++ &#123;<br>            dp[i][j] = matrix[i][j] + min(dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>], min(dp[i<span class="hljs-number">-1</span>][j], dp[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>]))<br>        &#125;<br>        <br>        <span class="hljs-comment">// j == n-1</span><br>        dp[i][n<span class="hljs-number">-1</span>] = matrix[i][n<span class="hljs-number">-1</span>] + min(dp[i<span class="hljs-number">-1</span>][n<span class="hljs-number">-1</span>], dp[i<span class="hljs-number">-1</span>][n<span class="hljs-number">-2</span>])<br>    &#125;<br><br>    res := math.MaxInt32<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; n; j++ &#123;<br>        res = min(res, dp[n<span class="hljs-number">-1</span>][j])<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编辑距离</title>
    <link href="/leetcode/fucking-algorithm/edit-distance/"/>
    <url>/leetcode/fucking-algorithm/edit-distance/</url>
    
    <content type="html"><![CDATA[<h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p><a href="https://leetcode-cn.com/problems/edit-distance/">https://leetcode-cn.com/problems/edit-distance/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><p>核心思想：如果字符串不匹配，3 种编辑操作都试一遍，然后找出最小距离的</p><p>DP 函数定义：</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>) <span class="hljs-comment">// 建立备忘录，以 array 为 key</span><br>    <span class="hljs-keyword">return</span> dp(memo, word1, word2, <span class="hljs-built_in">len</span>(word1)<span class="hljs-number">-1</span>, <span class="hljs-built_in">len</span>(word2)<span class="hljs-number">-1</span>)<br>&#125;  <br><br><span class="hljs-comment">// DP 函数定义：两个字符串在 i 和 j 之前的编辑距离</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo <span class="hljs-keyword">map</span>[[2]<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>, i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case: 已经处理完了其中一个字符，剩余编辑距离就是另一个字符未处理的长度</span><br>    <span class="hljs-keyword">if</span> i == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> j + <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> j == <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-comment">// 查备忘录</span><br>    <span class="hljs-keyword">if</span> val, ok := memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;]; ok &#123;<br>        <span class="hljs-keyword">return</span> val<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> word1[i] == word2[j] &#123; <br>        <span class="hljs-comment">// 字符相等，两个指针都往前走，编辑距离不变</span><br>        v := dp(memo, word1, word2, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>)<br>        memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;] = v<br><br>        <span class="hljs-keyword">return</span> v<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 字符不相等，则进行一次操作使得它们相等，编辑距离+1</span><br><br>        v1 := dp(memo, word1, word2, i, j<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>   <span class="hljs-comment">// 在 i 后插入字符，前移 j </span><br>        v2 := dp(memo, word1, word2, i<span class="hljs-number">-1</span>, j) + <span class="hljs-number">1</span>   <span class="hljs-comment">// 删除 i 处字符，并前移 i</span><br>        v3 := dp(memo, word1, word2, i<span class="hljs-number">-1</span>, j<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span> <span class="hljs-comment">// 替换 i 处字符，前移两个指针</span><br><br>        v := min(v1, min(v2, v3))<br>        memo[[<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;i, j&#125;] = v<br>        <br>        <span class="hljs-keyword">return</span> v<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>构建 DP 表：<code>dp[i-1][j-1]</code> 存储 <code>s1[0..i]</code> 和 <code>s2[0..j]</code> 的最小编辑距离</p><p>dp 函数的 base case 是 i,j 等于 -1，而数组索引至少是 0，所以 dp 数组的 index 会偏移一位，即 <code>dp[0][0]</code> 表示 s1 和 s2 都已经处理完的情况（i &#x3D; -1, j &#x3D; -1)，即剩余最小编辑距离为 0。</p><p><img src="https://github.com/labuladong/fucking-algorithm/raw/master/pictures/editDistance/dp.jpg" alt="DP 表"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(word1 <span class="hljs-keyword">string</span>, word2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// 初始化 DP 表为 2D 切片</span><br>    dp := <span class="hljs-built_in">make</span>([][]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(word1) + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(word2) + <span class="hljs-number">1</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(word1); i++ &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i<br>    &#125;<br>    <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">len</span>(word2); j++ &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j<br>    &#125;<br><br>    <span class="hljs-comment">// 构建 DP 表</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">len</span>(word1); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= <span class="hljs-built_in">len</span>(word2); j++ &#123;<br>            <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>] == word2[j<span class="hljs-number">-1</span>] &#123;  <span class="hljs-comment">// 注意这里对字符串的索引要减1</span><br>                dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = min(dp[i<span class="hljs-number">-1</span>][j] + <span class="hljs-number">1</span>, min(dp[i][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>, dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>))<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-built_in">len</span>(word1)][<span class="hljs-built_in">len</span>(word2)]<br>&#125;  <br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长递增子序列</title>
    <link href="/leetcode/fucking-algorithm/longest-increasing-subsequence/"/>
    <url>/leetcode/fucking-algorithm/longest-increasing-subsequence/</url>
    
    <content type="html"><![CDATA[<h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>直接构建 DP 数组：<br><code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最长递增子序列长度。问题的答案就是找到这个数组中最大的元素。</p><p>知道了 <code>nums[5] = 3</code>，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// init</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(nums))<br><br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = <span class="hljs-number">1</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dp); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; i; j++ &#123;<br>            <span class="hljs-keyword">if</span> nums[j] &lt; nums[i] &#123;<br>                dp[i] = max(dp[i], <span class="hljs-number">1</span> + dp[j]) <br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// find biggest element</span><br>    res := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> dp &#123;<br>        res = max(res, v)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span> <span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125;<br>    <span class="hljs-keyword">return</span> b<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>零钱兑换</title>
    <link href="/leetcode/fucking-algorithm/coin-change/"/>
    <url>/leetcode/fucking-algorithm/coin-change/</url>
    
    <content type="html"><![CDATA[<h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><p><a href="https://leetcode-cn.com/problems/coin-change/">https://leetcode-cn.com/problems/coin-change/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-keyword">int</span>, amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    dict := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)<br>    <span class="hljs-keyword">return</span> dp(dict, coins, amount)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dp</span><span class="hljs-params">(memo <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, coins[]<span class="hljs-keyword">int</span>, amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> amount &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> amount == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br><br>    <span class="hljs-comment">// check memory if exists</span><br>    <span class="hljs-keyword">if</span> val, ok := memo[amount]; ok &#123;<br>        <span class="hljs-keyword">return</span> val<br>    &#125;<br><br>    res := math.MaxInt16<br><br>    <span class="hljs-keyword">for</span> _, coin := <span class="hljs-keyword">range</span> coins &#123;<br>        subproblem := dp(memo, coins, amount - coin)<br>        <span class="hljs-keyword">if</span> subproblem == <span class="hljs-number">-1</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        res = min(res, <span class="hljs-number">1</span> + subproblem)<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> res == math.MaxInt16 &#123;<br>        res = <span class="hljs-number">-1</span><br>    &#125;<br><br>    memo[amount] = res<br>    <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>直接构建 DP 数组：<br><code>dp[i]</code> 表示数额为 i 时要的最少硬币个数。数组的索引就是变量，储存的值是需要计算的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(coins []<span class="hljs-keyword">int</span>, amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// init</span><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, amount + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        dp[i] = math.MaxInt16<br>    &#125;<br><br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> dp &#123;<br>        <span class="hljs-keyword">for</span> _, coin := <span class="hljs-keyword">range</span> coins &#123;<br>            <span class="hljs-comment">// no solution</span><br>            <span class="hljs-keyword">if</span> i - coin &lt; <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br>            dp[i] = min(dp[i], <span class="hljs-number">1</span> + dp[i - coin])<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> dp[amount] == math.MaxInt16 &#123;<br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[amount]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &lt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>斐波那契数列</title>
    <link href="/leetcode/fucking-algorithm/fibonacci-number/"/>
    <url>/leetcode/fucking-algorithm/fibonacci-number/</url>
    
    <content type="html"><![CDATA[<h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">https://leetcode-cn.com/problems/fibonacci-number/</a></p><h2 id="带备忘录的递归"><a href="#带备忘录的递归" class="headerlink" title="带备忘录的递归"></a>带备忘录的递归</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    memo := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> helper(memo, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(memo []<span class="hljs-keyword">int</span>, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br>    <span class="hljs-keyword">if</span> memo[n] != <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> memo[n]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        memo[n] = helper(memo, n - <span class="hljs-number">1</span>) + helper(memo, n - <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> memo[n]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>直接构建 DP 数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> n<br>    &#125;<br><br>    dp := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, n + <span class="hljs-number">1</span>)<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; <span class="hljs-built_in">len</span>(dp); i++ &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>]<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[n]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>Fucking</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并两个有序数组</title>
    <link href="/leetcode/top-interview-questions-easy/merge-sorted-array/"/>
    <url>/leetcode/top-interview-questions-easy/merge-sorted-array/</url>
    
    <content type="html"><![CDATA[<h1 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h1><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>由于数组 <code>nums1</code> 的后面留够了足够的空位（<code>nums2</code> 元素的个数），如果从 <code>nums1</code> 的后面开始放入元素，可以保证 <code>nums1</code> 的元素在取出前不会被覆盖。</p><p>因此使用双指针，从后面开始填充  <code>nums1</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">merge</span><span class="hljs-params">(nums1 []<span class="hljs-keyword">int</span>, m <span class="hljs-keyword">int</span>, nums2 []<span class="hljs-keyword">int</span>, n <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>    pm := m - <span class="hljs-number">1</span><br>    pn := n - <span class="hljs-number">1</span><br>    curr := <span class="hljs-built_in">len</span>(nums1) - <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> pm != <span class="hljs-number">-1</span> &amp;&amp; pn != <span class="hljs-number">-1</span> &#123;<br>        <span class="hljs-keyword">if</span> nums1[pm] &gt; nums2[pn] &#123;<br>            nums1[curr] = nums1[pm]<br>            pm--<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums1[curr] = nums2[pn]<br>            pn--<br>        &#125;<br>        curr--<br>    &#125;<br>    <br>    <span class="hljs-comment">// 其中一个指针到达尽头后，将未到达尽头的那个数组填充完</span><br>    <span class="hljs-keyword">for</span> pm != <span class="hljs-number">-1</span> &#123;<br>        nums1[curr] = nums1[pm]<br>        curr--<br>        pm--<br>    &#125;<br>    <span class="hljs-keyword">for</span> pn != <span class="hljs-number">-1</span> &#123;<br>        nums1[curr] = nums2[pn]<br>        curr--<br>        pn--<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>排序和搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有序数组转换为平衡二叉树</title>
    <link href="/leetcode/top-interview-questions-easy/convert-sorted-array-to-binary-search-tree/"/>
    <url>/leetcode/top-interview-questions-easy/convert-sorted-array-to-binary-search-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="有序数组转换为平衡二叉树"><a href="#有序数组转换为平衡二叉树" class="headerlink" title="有序数组转换为平衡二叉树"></a>有序数组转换为平衡二叉树</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xninbt/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xninbt/</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>平衡的二叉树，对于「每个节点的左右两个子树的高度差的绝对值不超过 1 」，只要保证所有的内部节点的左右子树高度差在此范围内，就可以保证整棵树的平衡。</p><p>对于 BST 而言，每次取数组中间的值作为根节点，左右两边的值为左右子树的节点，然后递归地进行。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(nums []<span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">TreeNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br>    mid := <span class="hljs-keyword">int</span>(<span class="hljs-built_in">len</span>(nums) / <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> &amp;TreeNode&#123;nums[mid], sortedArrayToBST(nums[:mid]), sortedArrayToBST(nums[mid+<span class="hljs-number">1</span>:])&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的层次遍历</title>
    <link href="/leetcode/top-interview-questions-easy/binary-tree-level-order-traversal/"/>
    <url>/leetcode/top-interview-questions-easy/binary-tree-level-order-traversal/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnldjj/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnldjj/</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/</a></p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>显然应该用广度优先搜索。由于返回的节点需要按层次分组，因此需要知道当前是在哪一层。</p><p><strong>解决方法</strong>：队列中存放一层的结点，每一次直接取一层的出来，并把下一层的放进去。这样实际上每一次都是把队列取空了，然后再填上。取之前先记录队列的元素个数，然后一个循环取出来就完事了。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(root *TreeNode)</span> [][]<span class="hljs-title">int</span></span> &#123;<br>    queue := []*TreeNode&#123;root&#125;<br>    result := [][]<span class="hljs-keyword">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) != <span class="hljs-number">0</span> || root != <span class="hljs-literal">nil</span> &#123;<br>        level := <span class="hljs-built_in">len</span>(queue)<br>        values := []<span class="hljs-keyword">int</span>&#123;&#125;<br>        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; level; i++ &#123;<br>            root = queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> root != <span class="hljs-literal">nil</span> &#123;<br>                values = <span class="hljs-built_in">append</span>(values, root.Val)<br>                queue = <span class="hljs-built_in">append</span>(queue, root.Left)<br>                queue = <span class="hljs-built_in">append</span>(queue, root.Right)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(values) != <span class="hljs-number">0</span> &#123;<br>            result = <span class="hljs-built_in">append</span>(result, values)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对称二叉树</title>
    <link href="/leetcode/top-interview-questions-easy/symmetric-tree/"/>
    <url>/leetcode/top-interview-questions-easy/symmetric-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn7ihv/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn7ihv/</a></p><p><a href="https://leetcode-cn.com/problems/symmetric-tree/solution/">https://leetcode-cn.com/problems/symmetric-tree/solution/</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>判断二叉树是否对称，就是判断根节点的左右子节点是否相同，且它们的后续子节点也是对称的。<br>即：<code>left.Left == right.Right &amp;&amp; left.Right == right.Left</code></p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(root.Left, root.Right)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(left *TreeNode, right *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> left.Val != right.Val &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(left.Left, right.Right) &amp;&amp; helper(left.Right, right.Left)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>一样的思路，两个结点为一组进栈出栈</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <br>    stack := []*TreeNode&#123;&#125;<br><br>    stack = <span class="hljs-built_in">append</span>(stack, root.Left)<br>    stack = <span class="hljs-built_in">append</span>(stack, root.Right)<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) != <span class="hljs-number">0</span> &#123;<br>        right := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        left := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-2</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-2</span>]<br><br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> &amp;&amp; right == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> left == <span class="hljs-literal">nil</span> || right == <span class="hljs-literal">nil</span> || left.Val != right.Val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        <br>        stack = <span class="hljs-built_in">append</span>(stack, left.Left)<br>        stack = <span class="hljs-built_in">append</span>(stack, right.Right)<br><br>        stack = <span class="hljs-built_in">append</span>(stack, right.Left)<br>        stack = <span class="hljs-built_in">append</span>(stack, left.Right)<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="/leetcode/top-interview-questions-easy/validate-binary-search-tree/"/>
    <url>/leetcode/top-interview-questions-easy/validate-binary-search-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn08xg/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn08xg/</a></p><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/">https://leetcode-cn.com/problems/validate-binary-search-tree/solution/</a></p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>注意，验证 BST 不能够只比较左右子节点与自己的值，而必须保证所有左侧的节点都要小于自己（右侧同理）。解决办法就是传入额外的上下界参数。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">return</span> helper(root, math.MinInt64, math.MaxInt64)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">helper</span><span class="hljs-params">(root *TreeNode, lower, upper <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> root.Val &lt;= lower || root.Val &gt;= upper &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> helper(root.Left, lower, root.Val) &amp;&amp; helper(root.Right, root.Val, upper)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="遍历后判断"><a href="#遍历后判断" class="headerlink" title="遍历后判断"></a>遍历后判断</h2><p>BST 中序遍历的结果是升序列表。</p><p>前序遍历、中序遍历、后续遍历都是<strong>深度优先遍历</strong>，可以使用栈来实现（广度优先是队列）。</p><p>中序遍历时，先不停地把左子节点压入栈，然后执行访问操作，操作完后出栈。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    stack := []*TreeNode&#123;&#125;<br>    inorder := math.MinInt64<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> || root != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">for</span> root != <span class="hljs-literal">nil</span> &#123;<br>            stack = <span class="hljs-built_in">append</span>(stack, root)<br>            root = root.Left<br>        &#125;<br>        root = stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>        <span class="hljs-keyword">if</span> root.Val &lt;= inorder &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        inorder = root.Val<br>        root = root.Right<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的最大深度</title>
    <link href="/leetcode/top-interview-questions-easy/maximum-depth-of-binary-tree/"/>
    <url>/leetcode/top-interview-questions-easy/maximum-depth-of-binary-tree/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnd69e/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnd69e/</a></p><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/</a></p><h2 id="深度优先（递归）"><a href="#深度优先（递归）" class="headerlink" title="深度优先（递归）"></a>深度优先（递归）</h2><p>树的深度优先搜索算法一般用递归实现。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + max(maxDepth(root.Left), maxDepth(root.Right))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> a &gt; b &#123;<br>        <span class="hljs-keyword">return</span> a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> b<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h2><p>一般用队列（数组）实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(root *TreeNode)</span> <span class="hljs-title">int</span></span> &#123;<br>    <span class="hljs-keyword">if</span> root == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br>    queue := []*TreeNode&#123;&#125;<br>    queue = <span class="hljs-built_in">append</span>(queue, root)<br>    ans := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(queue) &gt; <span class="hljs-number">0</span> &#123;<br>        sz := <span class="hljs-built_in">len</span>(queue)<br>        <span class="hljs-keyword">for</span> sz &gt; <span class="hljs-number">0</span> &#123;<br>            node := queue[<span class="hljs-number">0</span>]<br>            queue = queue[<span class="hljs-number">1</span>:]<br>            <span class="hljs-keyword">if</span> node.Left != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Left)<br>            &#125;<br>            <span class="hljs-keyword">if</span> node.Right != <span class="hljs-literal">nil</span> &#123;<br>                queue = <span class="hljs-built_in">append</span>(queue, node.Right)<br>            &#125;<br>            sz--<br>        &#125;<br>        ans++<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环形链表</title>
    <link href="/leetcode/top-interview-questions-easy/linked-list-cycle/"/>
    <url>/leetcode/top-interview-questions-easy/linked-list-cycle/</url>
    
    <content type="html"><![CDATA[<h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希数据类型来记录节点是否存在过，key 可以是节点的地址。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*ListNode]<span class="hljs-keyword">bool</span>)<br><br>    curr := head<br><br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> m[curr] == <span class="hljs-literal">true</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>        &#125;<br>        m[curr] = <span class="hljs-literal">true</span><br>        curr = curr.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>map</code> 类型要用 make 来初始化，如果不初始化它的值就是 <code>nil</code></li><li>函数参数中，<code>a &amp;int</code> 是按引用传递，<code>a *int</code> 是传递了一个指针，这个 <code>a</code> 的类型就是 <code>*int</code> （int 指针），指针类型可以用作 <code>map</code> 的 key。</li><li>因此在这个代码中，key 是 <code>*ListNode</code> 类型的，直接用变量 <code>curr</code> 就可以索引这个 map。</li></ul><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>如果链表有环，快慢指针最终会相遇。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    fast, slow := head, head<br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;<br>        fast = fast.Next.Next<br>        slow = slow.Next<br>        <span class="hljs-keyword">if</span> fast == slow &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回文链表</title>
    <link href="/leetcode/top-interview-questions-easy/palindrome-linked-list/"/>
    <url>/leetcode/top-interview-questions-easy/palindrome-linked-list/</url>
    
    <content type="html"><![CDATA[<h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnv1oc/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnv1oc/</a></p><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/solution/">https://leetcode-cn.com/problems/palindrome-linked-list/solution/</a></p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>把所有值存到栈（数组）中，然后前后指针来检查是否为回文。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    values := []<span class="hljs-keyword">int</span>&#123;&#125;<br><br>    <span class="hljs-keyword">for</span> head != <span class="hljs-literal">nil</span> &#123;<br>        values = <span class="hljs-built_in">append</span>(values, head.Val)<br>        head = head.Next<br>    &#125;<br><br>    n := <span class="hljs-built_in">len</span>(values)<br>    <span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> values[:n/<span class="hljs-number">2</span>] &#123;<br>        <span class="hljs-keyword">if</span> v != values[n<span class="hljs-number">-1</span>-i] &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><p>使用快慢指针，慢指针走 1 步时快指针走 2 步，这样在快指针到达末尾时，慢指针恰好在链表的中间。</p><p>反转后半部分链表，然后检查是否是回文，这样时间复杂度还是 O(n)，空间复杂度只有 O(1)了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    fast, slow := head, head<br><br>    <span class="hljs-keyword">for</span> fast != <span class="hljs-literal">nil</span> &amp;&amp; fast.Next != <span class="hljs-literal">nil</span> &#123;<br>        slow = slow.Next<br>        fast = fast.Next.Next<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> fast != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 奇数个节点</span><br>        slow = slow.Next <span class="hljs-comment">// 跳过节点中点，只逆转后半截</span><br>    &#125;<br><br>    revHead := reverse(slow)<br><br>    <span class="hljs-keyword">for</span> revHead != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> head.Val != revHead.Val &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        &#125;<br>        head = head.Next<br>        revHead = revHead.Next<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">var</span> prev *ListNode<br>    curr := head<br><br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        next := curr.Next<br>        curr.Next = prev<br>        prev = curr<br>        curr = next<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>类似于二叉树的后序遍历，单链表也能从后往前遍历，只要在<strong>调用递归函数之后</strong>进行访问操作就可以了，例如：（JAVA）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printListNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    printListNode(head.next);<br>    System.out.println(head.val);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此也可以在递归中从后往前走的时候，用一个<strong>全局变量</strong>来储存从前往后走的指针，递归每走一步，这个指针也往前走一步，这样就能实现两头的访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> temp *ListNode<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(head *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    temp = head<br>    <span class="hljs-keyword">return</span> check(head)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(node *ListNode)</span> <span class="hljs-title">bool</span></span> &#123;<br>    <span class="hljs-keyword">if</span> node == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    res := check(node.Next) &amp;&amp; node.Val == temp.Val<br>    temp = temp.Next<br>    <br>    <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>可以把递归视作函数调用栈，因此空间复杂度依然是 O(n)。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>合并两个有序链表</title>
    <link href="/leetcode/top-interview-questions-easy/merge-two-sorted-lists/"/>
    <url>/leetcode/top-interview-questions-easy/merge-two-sorted-lists/</url>
    
    <content type="html"><![CDATA[<h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnnbp2/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnnbp2/</a></p><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/">https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/</a></p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>哪个表的表头更小，就连上那个节点，并把对应的表头向后移动，直到有一方变成空的位置，连上另一个非空的表，完事。</p><p>dummy head 在这里很好用，这种需要返回链表头的，记得保存 head 变量用于返回。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    head := &amp;ListNode&#123;<span class="hljs-number">-999</span>, <span class="hljs-literal">nil</span>&#125;<br>    curr := head<br>    <br>    <span class="hljs-keyword">for</span> list1 != <span class="hljs-literal">nil</span> &amp;&amp; list2 != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>            curr.Next = list1<br>            list1 = list1.Next<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            curr.Next = list2<br>            list2 = list2.Next<br>        &#125;<br>        curr = curr.Next<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1 == <span class="hljs-literal">nil</span> &#123;<br>        curr.Next = list2<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        curr.Next = list1<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> head.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>关键难点是如何递归，返回什么，如何使用返回值。</p><ul><li>如何递归：小的那个节点，它的下一个节点是已经整理好的序列的头</li><li>返回什么：因为要返回整理好序列的头，这个小的节点就是，返回即可</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(list1 *ListNode, list2 *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> list1 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list2<br>    &#125;<br>    <span class="hljs-keyword">if</span> list2 == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> list1<br>    &#125;<br>    <span class="hljs-keyword">if</span> list1.Val &lt; list2.Val &#123;<br>        list1.Next = mergeTwoLists(list1.Next, list2)<br>        <span class="hljs-keyword">return</span> list1<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        list2.Next = mergeTwoLists(list1, list2.Next)<br>        <span class="hljs-keyword">return</span> list2<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转链表</title>
    <link href="/leetcode/top-interview-questions-easy/reverse-linked-list/"/>
    <url>/leetcode/top-interview-questions-easy/reverse-linked-list/</url>
    
    <content type="html"><![CDATA[<h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnnhm6/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnnhm6/</a></p><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/">https://leetcode-cn.com/problems/reverse-linked-list/solution/</a></p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>迭代进行中需要储存好前一个节点、当前节点、下一节点的指针，以便操作。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">var</span> prev *ListNode<br>    curr := head<br><br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        next := curr.Next<br>        curr.Next = prev<br>        prev = curr<br>        curr = next<br><br>        <span class="hljs-comment">// 或者利用平行赋值简写为一行</span><br>        <span class="hljs-comment">// curr.Next, prev, curr = prev, curr, curr.Next</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> prev<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>主要在于如何返回反转后的头节点，答案就是记住它（变量 <code>p</code>），然后层层直接返回。</p><p>其中递归所需的空间复杂度是 O(n)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseList</span><span class="hljs-params">(head *ListNode)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-keyword">if</span> head == <span class="hljs-literal">nil</span> || head.Next == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> head<br>    &#125;<br>    p := reverseList(head.Next)<br><br>    head.Next.Next = head<br>    head.Next = <span class="hljs-literal">nil</span><br><br>    <span class="hljs-keyword">return</span> p<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <link href="/leetcode/top-interview-questions-easy/remove-nth-node-from-end-of-list/"/>
    <url>/leetcode/top-interview-questions-easy/remove-nth-node-from-end-of-list/</url>
    
    <content type="html"><![CDATA[<h1 id="删除链表的倒数第N个节点"><a href="#删除链表的倒数第N个节点" class="headerlink" title="删除链表的倒数第N个节点"></a>删除链表的倒数第N个节点</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn2925/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn2925/</a></p><p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/solution/</a></p><h2 id="获取链表长度"><a href="#获取链表长度" class="headerlink" title="获取链表长度"></a>获取链表长度</h2><p>第一次遍历走到链表结尾，算出链表长度。第二次遍历到删除的节点。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    <span class="hljs-comment">// 计算链表长度</span><br>    counter := <span class="hljs-number">0</span><br>    curr := head<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        counter ++<br>        curr = curr.Next<br>    &#125;<br><br>    <span class="hljs-comment">// 移除链表头的情况</span><br>    <span class="hljs-keyword">if</span> counter == n &#123;<br>        <span class="hljs-keyword">return</span> head.Next<br>    &#125;<br><br>    curr = head<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; counter - n - <span class="hljs-number">1</span>; i++ &#123;<br>        curr = curr.Next<br>    &#125;<br>    curr.Next = curr.Next.Next<br><br>    <span class="hljs-keyword">return</span> head<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上给链表加一个假的头可以避免处理删除节点为头节点的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    dummyHead := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125; <span class="hljs-comment">// 加入假的头</span><br><br>    <span class="hljs-comment">// 计算链表长度</span><br>    counter := <span class="hljs-number">0</span><br>    curr := dummyHead<br>    <span class="hljs-keyword">for</span> curr != <span class="hljs-literal">nil</span> &#123;<br>        counter ++<br>        curr = curr.Next<br>    &#125;<br><br>    curr = dummyHead<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; counter - n - <span class="hljs-number">1</span>; i++ &#123;<br>        curr = curr.Next<br>    &#125;<br>    curr.Next = curr.Next.Next<br><br>    <span class="hljs-keyword">return</span> dummyHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>由于我们需要找到倒数第 n 个节点，因此我们可以使用两个指针 first 和 second 同时对链表进行遍历，并且 first 比 second 超前 n 个节点。当 first 遍历到链表的末尾时，second 就恰好处于倒数第 n 个节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    dummyHead := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br><br>    first := dummyHead<br>    <span class="hljs-comment">// 移动 first 指针，使得它超前 second 指针 n 个节点</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        first = first.Next<br>    &#125;<br>    second := dummyHead<br><br>    <span class="hljs-comment">// 同时移动两个指针，直至 first 指针到最后一个节点，此时 second 指针就是要删除节点的前驱节点</span><br>    <span class="hljs-keyword">for</span> first.Next != <span class="hljs-literal">nil</span> &#123;<br>        first = first.Next<br>        second = second.Next<br>    &#125;<br><br>    second.Next = second.Next.Next <span class="hljs-comment">// 执行删除</span><br><br>    <span class="hljs-keyword">return</span> dummyHead.Next<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>所有节点依次入栈，然后弹出第 n 个节点就是要删除的节点，且此时栈顶正好是它前一个节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(head *ListNode, n <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">ListNode</span></span> &#123;<br>    dummy := &amp;ListNode&#123;<span class="hljs-number">0</span>, head&#125;<br>    first, second := head, dummy<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>        first = first.Next<br>    &#125;<br>    <span class="hljs-keyword">for</span> ; first != <span class="hljs-literal">nil</span>; first = first.Next &#123;<br>        second = second.Next<br>    &#125;<br>    second.Next = second.Next.Next<br>    <span class="hljs-keyword">return</span> dummy.Next<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个实现中，本质上是用的数组作为栈来储存遍历过的节点，第二次就无需再从头遍历。属于是用空间换时间。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>删除链表中的节点</title>
    <link href="/leetcode/top-interview-questions-easy/delete-node-in-a-linked-list/"/>
    <url>/leetcode/top-interview-questions-easy/delete-node-in-a-linked-list/</url>
    
    <content type="html"><![CDATA[<h1 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnarn7/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnarn7/</a></p><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/">https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/</a></p><h2 id="狸猫换太子"><a href="#狸猫换太子" class="headerlink" title="狸猫换太子"></a>狸猫换太子</h2><p>无法获取链表的前一个节点，直接将自己复制成下一个节点，然后删除下一个节点，就相当于删除了自己</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(node *ListNode)</span></span> &#123;<br>    node.Val = node.Next.Val<br>    node.Next = node.Next.Next<br>&#125;<br></code></pre></td></tr></table></figure><p>目标：杀掉A</p><blockquote><p>正常杀手需要找到 A 的把柄才可以杀掉 A <br><br>可现在找到 A 本人后竟然没有可以获取 A 把柄的途径 <br><br>A 得知我们要杀他，心生一计，可助你完成任务 <br><br>A 说我有 B 的把柄，你杀了 B，我改头换面，以 B 的身份活着 <br><br>GC 也会自动清理掉 B 的尸体，没人会知道的</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长公共前缀</title>
    <link href="/leetcode/top-interview-questions-easy/longest-common-prefix/"/>
    <url>/leetcode/top-interview-questions-easy/longest-common-prefix/</url>
    
    <content type="html"><![CDATA[<h1 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnmav1/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnmav1/</a></p><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/">https://leetcode-cn.com/problems/longest-common-prefix/solution/</a></p><h2 id="横向扫描"><a href="#横向扫描" class="headerlink" title="横向扫描"></a>横向扫描</h2><p>遍历所有字符串，计算并更新公共前缀。</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(strs []<span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span></span> &#123;<br>    prefix = strs[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">for</span> _, str := <span class="hljs-keyword">range</span> strs &#123;<br>        prefix = LCP(prefix, str)<br>        <span class="hljs-keyword">if</span> prefix == <span class="hljs-string">&quot;&quot;</span> &#123;<br>            <span class="hljs-keyword">return</span> <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LCP</span><span class="hljs-params">(str1 <span class="hljs-keyword">string</span>, str2 <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    index := <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">for</span> index &lt; <span class="hljs-built_in">len</span>(str1) &amp;&amp; index &lt; <span class="hljs-built_in">len</span>(str2) &amp;&amp; str1[index] == str2[index] &#123;<br>        index++<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> str1[:index]<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>用字符切片来保存返回结果</li></ul><h2 id="纵向扫描"><a href="#纵向扫描" class="headerlink" title="纵向扫描"></a>纵向扫描</h2><p>遍历字符串相同位置的字母，例如对于 flow flower florance，取第一个 flow 作为基准，先检查 f，然后检查fl，然后检查 flo。<br>以此类推，直到某个单词读完了或者有不通过检查的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(strs []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sb strings.Builder<br>    flag := <span class="hljs-literal">true</span><br><br>    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> strs[<span class="hljs-number">0</span>] &#123;<br>        <span class="hljs-keyword">for</span> _, rs := <span class="hljs-keyword">range</span> strs &#123;<br>            <span class="hljs-keyword">if</span> i &gt;= <span class="hljs-built_in">len</span>(rs) || r != <span class="hljs-keyword">rune</span>(rs[i]) &#123;<br>                flag = <span class="hljs-literal">false</span><br>                <span class="hljs-keyword">break</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> flag &#123;<br>           sb.WriteRune(r)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sb.String()<br>&#125;<br></code></pre></td></tr></table></figure><p>我的解法：用 <code>strings.Builder</code> 来拼接字符串，其实没有必要，对于这种不需要重新组装字符串的情况，直接用切片就行了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">longestCommonPrefix</span><span class="hljs-params">(strs []<span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(strs[<span class="hljs-number">0</span>]); i++ &#123;<br>        <span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt; <span class="hljs-built_in">len</span>(strs); j++ &#123;<br>            <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(strs[j]) || strs[j][i] != strs[<span class="hljs-number">0</span>][i] &#123;<br>                <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>][:i]<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>外观数列</title>
    <link href="/leetcode/top-interview-questions-easy/count-and-say/"/>
    <url>/leetcode/top-interview-questions-easy/count-and-say/</url>
    
    <content type="html"><![CDATA[<h1 id="外观数列"><a href="#外观数列" class="headerlink" title="外观数列"></a>外观数列</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnpvdm/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnpvdm/</a></p><p><a href="https://leetcode-cn.com/problems/count-and-say/">https://leetcode-cn.com/problems/count-and-say/</a></p><p>顺带一提，从今天开始用 Golang 刷题，以便掌握算法的同时熟悉语言特性。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countAndSay</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span><br>    &#125;<br><br>    str := countAndSay(n - <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">var</span> sb strings.Builder<br>    <br>    <span class="hljs-keyword">for</span> start, end := <span class="hljs-number">0</span>, <span class="hljs-number">0</span>; start &lt; <span class="hljs-built_in">len</span>(str); start = end &#123;<br>        <span class="hljs-keyword">for</span> end &lt; <span class="hljs-built_in">len</span>(str) &amp;&amp; str[end] == str[start] &#123;<br>            end++<br>        &#125;<br>        sb.WriteString(strconv.Itoa(end - start))<br>        sb.WriteByte(str[start])<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sb.String()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Note-of-Golang"><a href="#Note-of-Golang" class="headerlink" title="Note of Golang"></a>Note of Golang</h2><ul><li>用 <code>strings.Builder</code> 来拼接字符串，因为如果使用 <code>+=</code> 运算符的话会在不停分配新的内存导致效率变低。</li><li>Golang 中变量可以平行赋值，先计算等式右边的值，然后从左到右依次赋值。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 部署 pytorch 应用</title>
    <link href="/essay/docker-deployment/"/>
    <url>/essay/docker-deployment/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-部署-pytorch-应用-GPU"><a href="#Docker-部署-pytorch-应用-GPU" class="headerlink" title="Docker 部署 pytorch 应用 (GPU)"></a>Docker 部署 pytorch 应用 (GPU)</h1><h2 id="拉取-python-3-8-镜像"><a href="#拉取-python-3-8-镜像" class="headerlink" title="拉取 python 3.8 镜像"></a>拉取 python 3.8 镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">docker pull python:3.8.12<br></code></pre></td></tr></table></figure><p>buster, bullseye 等的区别：<a href="https://stackoverflow.com/questions/52083380/in-docker-image-names-what-is-the-difference-between-alpine-jessie-stretch-an">In Docker image names what is the difference between Alpine, Jessie, Stretch, and Buster?</a></p><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><h3 id="编写-Dockerfile"><a href="#编写-Dockerfile" class="headerlink" title="编写  Dockerfile"></a>编写  Dockerfile</h3><p>RUN 命令可以根据情况随意更改，这里是安装 GPU 版的 pytorch 以及其他 python 依赖。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:<span class="hljs-number">3.8</span>.<span class="hljs-number">12</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /app</span><br><br><span class="hljs-keyword">ADD</span><span class="bash"> . /app</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> git reset HEAD --hard</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="hljs-keyword">RUN</span><span class="bash"> pip install torch==1.10.1+cu113 torchvision==0.11.2+cu113 torchaudio===0.10.1+cu113 -f https://download.pytorch.org/whl/cu113/torch_stable.html</span><br><span class="hljs-keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span><br><br><span class="hljs-keyword">CMD</span><span class="bash"> python serve_pytorch.py <span class="hljs-comment"># optional</span></span><br></code></pre></td></tr></table></figure><h3 id="从-Dockerfile-构建镜像"><a href="#从-Dockerfile-构建镜像" class="headerlink" title="从 Dockerfile 构建镜像"></a>从 Dockerfile 构建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker build -t target_name .<br></code></pre></td></tr></table></figure><h2 id="允许容器访问-GPU"><a href="#允许容器访问-GPU" class="headerlink" title="允许容器访问 GPU"></a>允许容器访问 GPU</h2><p>参考：<a href="https://github.com/NVIDIA/nvidia-container-runtime">https://github.com/NVIDIA/nvidia-container-runtime</a></p><ol><li><p>安装 nvidia-container-runtime <a href="https://nvidia.github.io/nvidia-container-runtime/">https://nvidia.github.io/nvidia-container-runtime/</a></p></li><li><p>修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;runtimes&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;nvidia&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;/usr/bin/nvidia-container-runtime&quot;</span>,<br>            <span class="hljs-attr">&quot;runtimeArgs&quot;</span>: []<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>新建并运行容器</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -it --gpus all image_name bash<br></code></pre></td></tr></table></figure></li></ol><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="列出本地镜像"><a href="#列出本地镜像" class="headerlink" title="列出本地镜像"></a>列出本地镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker image ls<br></code></pre></td></tr></table></figure><h3 id="从镜像启动新的容器"><a href="#从镜像启动新的容器" class="headerlink" title="从镜像启动新的容器"></a>从镜像启动新的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run image_name<br></code></pre></td></tr></table></figure><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it container_name bash<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yeasy.gitbook.io/docker_practice/">Docker 从入门到实践</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将 transformers 模型转换为 ONNX 格式并用 TensorRT 加速</title>
    <link href="/nlp/convert-transformers-to-onnx/"/>
    <url>/nlp/convert-transformers-to-onnx/</url>
    
    <content type="html"><![CDATA[<h1 id="将-transformers-模型转换为-ONNX-格式并用-TensorRT-加速"><a href="#将-transformers-模型转换为-ONNX-格式并用-TensorRT-加速" class="headerlink" title="将 transformers 模型转换为 ONNX 格式并用 TensorRT 加速"></a>将 transformers 模型转换为 ONNX 格式并用 TensorRT 加速</h1><p>然后就可以优化模型，加速推理了。这里以 BERT 为例。</p><h2 id="转换-ONNX-文件"><a href="#转换-ONNX-文件" class="headerlink" title="转换 ONNX 文件"></a>转换 ONNX 文件</h2><p>运行 transformers 官方提供的脚本 <a href="https://github.com/huggingface/transformers/blob/master/src/transformers/convert_graph_to_onnx.py">convert_graph_to_onnx.py</a> ，直接得到转换好格式的 ONNX 模型。（或者直接 import 进来，调用里面的 convert() 方法。）</p><p>注意 pipeline 要跟自己的模型任务对应上，否则无法正常工作。例如这里我用的是 <code>BertForSequenceClassification</code> ，pipeline 就选 <code>sentiment-analysis</code> （等价于 <code>TextClassificationPipeline</code>）</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">python -m transformers.convert_graph_to_onnx --pipeline sentiment-analysis --framework pt --model &quot;./models/chinese-bert-wwm-ext_2021-12-06_11-33-24&quot; --check-loading --quantize &quot;./models/onnx/chinese-bert-wwm-ext/model.onnx&quot;<br></code></pre></td></tr></table></figure><p>注意模型转换时控制台的打印信息，确定模型的输入输出跟原来的 forward() 函数一致。<code>--model</code> 参数就是用 save_pretrained() 方法保存的模型。指定 <code>--quantize</code> 参数会生成 optimize 和 quantize 后的模型。脚本运行完后，我的目录结构如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs 1c">models<br><span class="hljs-string">| chinese-bert-wwm-ext_2021-12-06_11-33-24</span><br><span class="hljs-string">| added_tokens.json</span><br><span class="hljs-string">| config.json</span><br><span class="hljs-string">| pytorch_model.bin</span><br><span class="hljs-string">| tokenizer.json</span><br><span class="hljs-string">| tokenizer_config.json</span><br><span class="hljs-string">| special_tokens_map.json</span><br><span class="hljs-string">| vocab.txt</span><br><span class="hljs-string">| onnx</span><br><span class="hljs-string">| chinese-bert-wwm-ext</span><br><span class="hljs-string">| model.onnx</span><br><span class="hljs-string">| model-optimized.onnx</span><br><span class="hljs-string">| model-optimized-quantized.onnx</span><br></code></pre></td></tr></table></figure><h2 id="在-CPU-上进行推理"><a href="#在-CPU-上进行推理" class="headerlink" title="在 CPU 上进行推理"></a>在 CPU 上进行推理</h2><p>至此已经可以用 ONNX 进行推理了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> onnxruntime <span class="hljs-keyword">as</span> ort<br><span class="hljs-keyword">from</span> transformers.models.bert <span class="hljs-keyword">import</span> BertTokenizerFast<br><br>model_path = <span class="hljs-string">&quot;./models/chinese-bert-wwm-ext_2021-12-06_11-33-24&quot;</span><br>onnx_path = <span class="hljs-string">&quot;./models/onnx/chinese-bert-wwm-ext/model.onnx&quot;</span><br>tokenizer = BertTokenizerFast.from_pretrained(model_path)<br><br>ort_session = ort.InferenceSession(onnx_path)<br><br>inputs = tokenizer([<span class="hljs-string">&quot;hello&quot;</span>], [<span class="hljs-string">&quot;motherfucker&quot;</span>])<br>outputs = ort_session.run(<span class="hljs-literal">None</span>, <span class="hljs-built_in">dict</span>(inputs))<br><br><span class="hljs-comment"># outputs: [array([[ 3.5934877, -3.5006552]], dtype=float32)]</span><br></code></pre></td></tr></table></figure><p>run() 方法中需要传入对应名字的参数。</p><h2 id="下载并安装-TensorRT"><a href="#下载并安装-TensorRT" class="headerlink" title="下载并安装 TensorRT"></a>下载并安装 TensorRT</h2><p>ONNX 本身也会加速推理，但是可以利用 TensorRT 进一步加速 GPU 上的推理速度。CPU 上也有类似的加速框架 openvino。这些是特定硬件平台（nvidia 和 intel）自家的加速引擎。</p><p>去英伟达官网 <a href="https://developer.nvidia.com/zh-cn/tensorrt">NVIDIA TensorRT</a> 下载 TensorRT。</p><p><strong>重要</strong>：TensorRT 版本要和 CUDA、cuBLAS、cuDNN、onnx runtime 的版本都对应上，见 <a href="https://onnxruntime.ai/docs/execution-providers/TensorRT-ExecutionProvider.html#requirements">Requirements</a> 。一个版本号会有两种版本，EA (early access) 和 GA (general availability)，选 GA 就好。</p><blockquote><p>Ensure that you have the following dependencies installed.</p><ul><li><a href="https://docs.nvidia.com/cuda/archive/10.2/index.html">CUDA 10.2</a>, <a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html#cuda-whats-new-11Upd1">11.0 update 1</a>, <a href="https://developer.nvidia.com/cuda-toolkit-archive">11.1 update 1</a>, <a href="https://developer.nvidia.com/cuda-toolkit-archive">11.2 update 2</a>, <a href="https://developer.nvidia.com/cuda-toolkit-archive">11.3 update 1</a>, or <a href="https://developer.nvidia.com/cuda-toolkit-archive">11.4 update 2</a></li><li><a href="https://docs.nvidia.com/deeplearning/cudnn/release-notes/rel_8.html#rel-821">cuDNN 8.2.1</a></li></ul></blockquote><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>这里我的版本是 8.2 GA。Windows 平台下载下来的是一个 zip 文件，安装说明见 <a href="https://docs.nvidia.com/deeplearning/tensorrt/install-guide/index.html#installing-zip">4.7. Zip File Installation</a> 。实际就是把 lib 目录下的一堆 dll 文件扔进 CUDA 的 bin 目录下，然后 pip install 几个本地的包。安装完成后尝试 import tensorrt 验证一下是否安装成功。（官方说是用 visual studio 编译几个示例项目）</p><h2 id="在-GPU-上进行推理"><a href="#在-GPU-上进行推理" class="headerlink" title="在 GPU 上进行推理"></a>在 GPU 上进行推理</h2><p>代码跟之前几乎没区别，就是添加了个 providers 参数。也可以不用 TensorRT 只用 CUDA，把 <code>TensorrtExecutionProvider</code> 去掉即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> onnxruntime <span class="hljs-keyword">as</span> ort<br><span class="hljs-keyword">from</span> transformers.models.bert <span class="hljs-keyword">import</span> BertTokenizerFast<br><br>model_path = <span class="hljs-string">&quot;./models/chinese-bert-wwm-ext_2021-12-06_11-33-24&quot;</span><br>onnx_path = <span class="hljs-string">&quot;./models/onnx/chinese-bert-wwm-ext/model.onnx&quot;</span><br>tokenizer = BertTokenizerFast.from_pretrained(model_path)<br><br>ort_session = ort.InferenceSession(onnx_path, providers=[<span class="hljs-string">&#x27;TensorrtExecutionProvider&#x27;</span>, <span class="hljs-string">&#x27;CUDAExecutionProvider&#x27;</span>])<br><span class="hljs-comment"># ort_session = ort.InferenceSession(onnx_path, providers=[&#x27;CUDAExecutionProvider&#x27;])  # CUDA only</span><br><span class="hljs-comment"># ort_session = ort.InferenceSession(onnx_path, providers=[&#x27;CPUExecutionProvider&#x27;])  # CPU</span><br><br>inputs = tokenizer([<span class="hljs-string">&quot;hello&quot;</span>], [<span class="hljs-string">&quot;motherfucker&quot;</span>])<br>outputs = ort_session.run(<span class="hljs-literal">None</span>, <span class="hljs-built_in">dict</span>(inputs))<br><br><span class="hljs-comment"># outputs: [array([[ 3.5934877, -3.5006552]], dtype=float32)]</span><br></code></pre></td></tr></table></figure><h3 id="报警告"><a href="#报警告" class="headerlink" title="报警告"></a>报警告</h3><p>实际使用中，不报错误就算成功，但是可能会报如下警告：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">15</span>:<span class="hljs-number">13</span>:<span class="hljs-number">31.6350799</span> [W:onnxruntime:<span class="hljs-keyword">Default</span>, tensorrt_execution_provider.h:<span class="hljs-number">53</span> onnxruntime::TensorrtLogger::<span class="hljs-keyword">log</span>] [<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">07</span>:<span class="hljs-number">13</span>:<span class="hljs-number">31</span> <span class="hljs-built_in">WARNING</span>] D:\a\_work\<span class="hljs-number">1</span>\s\cmake\<span class="hljs-keyword">external</span>\onnx-tensorrt\onnx2trt_utils.cpp:<span class="hljs-number">364</span>: Your ONNX model has been <span class="hljs-keyword">generated</span> <span class="hljs-keyword">with</span> INT64 weights, <span class="hljs-keyword">while</span> TensorRT does <span class="hljs-keyword">not</span> natively support INT64. Attempting <span class="hljs-keyword">to</span> <span class="hljs-keyword">cast</span> down <span class="hljs-keyword">to</span> INT32.<br><br><span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">15</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50.2068278</span> [W:onnxruntime:<span class="hljs-keyword">Default</span>, tensorrt_execution_provider.h:<span class="hljs-number">53</span> onnxruntime::TensorrtLogger::<span class="hljs-keyword">log</span>] [<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">07</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> <span class="hljs-built_in">WARNING</span>] TensorRT was linked against cuBLAS/cuBLAS LT <span class="hljs-number">11.6</span><span class="hljs-number">.3</span> but loaded cuBLAS/cuBLAS LT <span class="hljs-number">11.3</span><span class="hljs-number">.0</span><br><span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">15</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50.2080023</span> [W:onnxruntime:<span class="hljs-keyword">Default</span>, tensorrt_execution_provider.h:<span class="hljs-number">53</span> onnxruntime::TensorrtLogger::<span class="hljs-keyword">log</span>] [<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-10</span> <span class="hljs-number">07</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span> <span class="hljs-built_in">WARNING</span>] TensorRT was linked against cuDNN <span class="hljs-number">8.2</span><span class="hljs-number">.1</span> but loaded cuDNN <span class="hljs-number">8.0</span><span class="hljs-number">.5</span><br></code></pre></td></tr></table></figure><p>只要不报错误，无视即可，实际上不影响性能（大概）。</p><p>报了 3 个错误：</p><ol><li>ONNX 模型由 INT64 生成</li><li>cuBLAS 版本不对</li><li>cuDNN 版本不对</li></ol><p>第 2，3 点原因应该是是跟 pytorch 共用了一个 conda 环境，而 pytorch 本身硬编码了 cudnn 的链接，所以导致 cuda 和 cudnn 版本不符合。建议创建一个推理专用环境，跟 torch 的环境分开。可以在 <a href="https://docs.nvidia.com/cuda/archive">archieve</a> 的 release note 中查看不同 cuda 版本的子组件版本，例如：<a href="https://docs.nvidia.com/cuda/archive/11.3.1/cuda-toolkit-release-notes/index.html#cuda-major-component-versions">1.1. CUDA Toolkit Major Component Versions</a> 中的 cuBLAS 版本就是 11.5.1.109，可以根据这个选择合适的 TensorRT 版本。</p><h3 id="TensorRT-加载、推理速度比-CPU-还慢"><a href="#TensorRT-加载、推理速度比-CPU-还慢" class="headerlink" title="TensorRT 加载、推理速度比 CPU 还慢"></a>TensorRT 加载、推理速度比 CPU 还慢</h3><p>正常现象，跟 TensorRT 本身的机制有关，加载模型、第一次推理速度会特别慢，但是后面的就会很快了。参见：<a href="https://github.com/microsoft/onnxruntime/issues/7230#issuecomment-814619248">https://github.com/microsoft/onnxruntime/issues/7230#issuecomment-814619248</a></p><p>参考时间差异（batch_size &#x3D; 1）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">Load time:  <span class="hljs-number">14.695685863494873</span><br>Run time:  <span class="hljs-number">6.2073938846588135</span><br>Second run time:  <span class="hljs-number">0.23337483406066895</span><br></code></pre></td></tr></table></figure><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>torch &#x3D;&#x3D; 1.8.0</p><p>transformers &#x3D;&#x3D; 4.12.5</p><p>onnx &#x3D;&#x3D; 1.10.2</p><p>onnxruntime-gpu &#x3D;&#x3D; 1.10.0</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>CUDA：11.1.1_456.81_win10</p><p>cudnn：11.3-windows-x64-v8.2.1.32</p><p>TensorRT：8.2.1.8</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>pipeline 有哪些：<a href="https://huggingface.co/docs/transformers/master/en/main_classes/pipelines#pipelines">Pipelines</a> </p><p>哪些 pipeline 可以直接用官方脚本转换（直接看 help 信息）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">SUPPORTED_PIPELINES = [<br>    <span class="hljs-string">&quot;feature-extraction&quot;</span>,<br>    <span class="hljs-string">&quot;ner&quot;</span>,<br>    <span class="hljs-string">&quot;sentiment-analysis&quot;</span>,<br>    <span class="hljs-string">&quot;fill-mask&quot;</span>,<br>    <span class="hljs-string">&quot;question-answering&quot;</span>,<br>    <span class="hljs-string">&quot;text-generation&quot;</span>,<br>    <span class="hljs-string">&quot;translation_en_to_fr&quot;</span>,<br>    <span class="hljs-string">&quot;translation_en_to_de&quot;</span>,<br>    <span class="hljs-string">&quot;translation_en_to_ro&quot;</span>,<br>]<br></code></pre></td></tr></table></figure><p>transformers 官方文档：<a href="https://huggingface.co/docs/transformers/master/en/serialization#exporting-transformers-models">Exporting transformers models</a></p><p>官方博客：<a href="https://medium.com/microsoftazure/accelerate-your-nlp-pipelines-using-hugging-face-transformers-and-onnx-runtime-2443578f4333">Accelerate your NLP pipelines using Hugging Face Transformers and ONNX Runtime</a></p><p>PyTorch <a href="https://pytorch.org/docs/stable/onnx.html#">torch.onnx</a></p><p>一个也许有用的 GitHub issue：<a href="https://github.com/huggingface/transformers/issues/4825">Onnx converted model has its output shape modified when compared to original (finetuned) model</a></p><p>TensorRT 安装指南 <a href="https://docs.nvidia.com/deeplearning/tensorrt/install-guide/index.html">Install Guide</a></p><p>ONNX runtime 对 TensorRT 的支持：<a href="https://onnxruntime.ai/docs/execution-providers/TensorRT-ExecutionProvider.html">TensorRT Execution Provider</a>  其中，对于 CUDA 版本要求为 11.4 的，11.x都可以兼容。</p>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
      <category>transformers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
      <tag>transformers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对 HuggingFace Transformers 模型进行后训练</title>
    <link href="/nlp/postrain_transformers/"/>
    <url>/nlp/postrain_transformers/</url>
    
    <content type="html"><![CDATA[<h1 id="对-HuggingFace-Transformers-模型进行预训练-post-train-x2F-further-pretrain"><a href="#对-HuggingFace-Transformers-模型进行预训练-post-train-x2F-further-pretrain" class="headerlink" title="对 HuggingFace Transformers 模型进行预训练 (post-train &#x2F; further pretrain)"></a>对 HuggingFace Transformers 模型进行预训练 (post-train &#x2F; further pretrain)</h1><p>这几天需要对 BERT 进行进一步的预训练，而且是 MLM 和 NSP 两个任务一起。但是 transformers 官方只提供了 MLM 任务的训练例子。（可能是因为 RoBERTa 原论文中认为 NSP 任务没用）</p><p>后来终于在 stackoverflow 上找到了<a href="https://stackoverflow.com/questions/65646925/how-to-train-bert-from-scratch-on-a-new-domain-for-both-mlm-and-nsp">解决方法</a>。在自己的数据集上试验有效后记录于此。</p><h2 id="产生任务对应的标注数据"><a href="#产生任务对应的标注数据" class="headerlink" title="产生任务对应的标注数据"></a>产生任务对应的标注数据</h2><h3 id="使用-TextDatasetForNextSentencePrediction-构造-NSP-任务-Dataset"><a href="#使用-TextDatasetForNextSentencePrediction-构造-NSP-任务-Dataset" class="headerlink" title="使用 TextDatasetForNextSentencePrediction 构造 NSP 任务 Dataset"></a>使用 <code>TextDatasetForNextSentencePrediction</code> 构造 NSP 任务 Dataset</h3><p>文档：官方文档没写，需要阅读<a href="https://github.com/huggingface/transformers/blob/9f72e8f4e1e767c5f608dd135199e592255b8a69/src/transformers/data/datasets/language_modeling.py">源代码</a>。</p><p>数据格式：一行一句话，不同的文档之间空一行。</p><blockquote><ol><li>One sentence per line. These should ideally be actual sentences, not entire paragraphs or arbitrary spans of text. (Because we use the sentence boundaries for the “next sentence prediction” task).</li><li>Blank lines between documents. Document boundaries are needed so that the “next sentence prediction” task doesn’t span between documents.</li></ol></blockquote><p>输入例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs tex">I am very happy.<br>Here is the second sentence.<br><br>A new document.<br></code></pre></td></tr></table></figure><h3 id="使用-DataCollatorForLanguageModeling-对数据进行-MLM-标注"><a href="#使用-DataCollatorForLanguageModeling-对数据进行-MLM-标注" class="headerlink" title="使用 DataCollatorForLanguageModeling 对数据进行 MLM 标注"></a>使用 <code>DataCollatorForLanguageModeling</code> 对数据进行 MLM 标注</h3><p>文档：<a href="https://huggingface.co/docs/transformers/main_classes/data_collator#transformers.DataCollatorForLanguageModeling">DataCollatorForLanguageModeling</a></p><p>注：无法使用 WWM （<a href="https://huggingface.co/docs/transformers/main_classes/data_collator#transformers.DataCollatorForWholeWordMask">DataCollatorForWholeWordMask</a>），因为它的实现中会丢弃掉 NSP Dataset 返回的一些值，只保留了 <code>input_ids</code> 和 <code>labels</code> 。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>模型（使用专门的 <a href="https://huggingface.co/docs/transformers/master/en/model_doc/bert#transformers.BertForPreTraining">BertForPreTraining</a> 预训练类）、分词器定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers.models.bert <span class="hljs-keyword">import</span> BertTokenizerFast, BertForPreTraining<br><br>tokenizer = BertTokenizerFast.from_pretrained(model_name)<br>model = BertForPreTraining.from_pretrained(model_name)<br></code></pre></td></tr></table></figure><p>给分词器加入新的 token 并 resize 词表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenizer.add_tokens([<span class="hljs-string">&quot;[name]&quot;</span>, <span class="hljs-string">&quot;[gender]&quot;</span>])<br>tokenizer.add_special_tokens(&#123;<span class="hljs-string">&quot;eos_token&quot;</span>: <span class="hljs-string">&quot;[EOT]&quot;</span>&#125;)<br>model.resize_token_embeddings(<span class="hljs-built_in">len</span>(tokenizer))<br></code></pre></td></tr></table></figure><p>定义 dataset 和 collator。dataset 返回的样本会以字典形式传入到模型的 <code>__call__()</code> 方法（forward）中，因此需要检查是否构建了正确的数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers.data <span class="hljs-keyword">import</span> DataCollatorForLanguageModeling<br><span class="hljs-keyword">from</span> transformers.data.datasets <span class="hljs-keyword">import</span> TextDatasetForNextSentencePrediction<br><br>dataset = TextDatasetForNextSentencePrediction(tokenizer, <span class="hljs-string">&quot;./dataset_v2/pretrain.txt&quot;</span>, block_size=<span class="hljs-number">256</span>)<br>collator = DataCollatorForLanguageModeling(tokenizer, mlm=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>定义 <a href="https://huggingface.co/docs/transformers/master/en/main_classes/trainer#transformers.TrainingArguments">TrainingArgument</a> 以及 <a href="https://huggingface.co/docs/transformers/master/en/main_classes/trainer#transformers.Trainer">Trainer</a> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers.trainer <span class="hljs-keyword">import</span> TrainingArguments, Trainer<br><br>training_args = TrainingArguments(<br>    output_dir=out_dir,<br>    overwrite_output_dir=<span class="hljs-literal">True</span>,<br>    num_train_epochs=num_epochs,<br>    per_device_train_batch_size=<span class="hljs-number">64</span>,<br>    save_strategy=<span class="hljs-string">&quot;epoch&quot;</span><br>)<br><br>trainer = Trainer(<br>    model=model,<br>    args=training_args,<br>    data_collator=collator,<br>    train_dataset=dataset<br>)<br>trainer.train()<br></code></pre></td></tr></table></figure><p>最后保存模型以及分词器就完成了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">tokenizer.save_pretrained(out_dir)<br>trainer.save_model()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NLP</category>
      
      <category>transformers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
      <tag>transformers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日阅读论文记录</title>
    <link href="/essay/paper-reading-record/"/>
    <url>/essay/paper-reading-record/</url>
    
    <content type="html"><![CDATA[<h1 id="每日阅读论文记录"><a href="#每日阅读论文记录" class="headerlink" title="每日阅读论文记录"></a>每日阅读论文记录</h1><h2 id="9-月"><a href="#9-月" class="headerlink" title="9 月"></a>9 月</h2><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>09&#x2F;15</td><td>A Short Review: Deep Retrieval-Based Dialogue Systems</td><td></td></tr><tr><td>09&#x2F;16</td><td>Improved Deep Learning Baselines for Ubuntu Corpus Dialogs</td><td>UDC</td></tr><tr><td>09&#x2F;16</td><td>Sequential Attention-based Network for Noetic End-to-End Response Selection</td><td>ESIM</td></tr><tr><td>09&#x2F;23</td><td>Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks</td><td>SBERT</td></tr><tr><td>09&#x2F;24</td><td>Augmented SBERT: Data Augmentation Method for Improving Bi-Encoders for Pairwise Sentence Scoring Tasks</td><td></td></tr><tr><td>09&#x2F;25</td><td>Supervised Learning of Universal Sentence Representations from Natural Language Inference Data</td><td>InferSent</td></tr><tr><td>09&#x2F;26</td><td>Learning Semantic Textual Similarity from Conversations</td><td>USE</td></tr><tr><td>09&#x2F;27</td><td>A SIMPLE BUT TOUGH-TO-BEAT BASELINE FOR SENTENCE EMBEDDINGS (undone)</td><td></td></tr><tr><td>09&#x2F;27</td><td>An Effective Domain Adaptive Post-Training Method for BERT in Response Selection</td><td>BERT-VFT</td></tr><tr><td>09&#x2F;28</td><td>Sequential Matching Network: A New Architecture for Multi-turn Response Selection in Retrieval-Based Chatbots</td><td>SMN</td></tr><tr><td>09&#x2F;29</td><td>APPLYING DEEP LEARNING TO ANSWER SELECTION: A STUDY AND AN OPEN TASK</td><td>Siam-CNN</td></tr></tbody></table><h2 id="10-月"><a href="#10-月" class="headerlink" title="10 月"></a>10 月</h2><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>10&#x2F;06</td><td>Learning an Effective Context-Response Matching Model with Self-Supervised Tasks for Retrieval-based Dialogues</td><td>BERT-SL</td></tr><tr><td>10&#x2F;07</td><td>Pre-train, Prompt, and Predict: A Systematic Survey of Prompting Methods in Natural Language Processing</td><td></td></tr><tr><td>10&#x2F;08</td><td>Exploiting Cloze Questions for Few Shot Text Classification and Natural Language Inference</td><td>PET</td></tr><tr><td>10&#x2F;09</td><td>GPT Understands, Too</td><td>P-Tuning</td></tr><tr><td>10&#x2F;09</td><td>SimCSE: Simple Contrastive Learning of Sentence Embeddings</td><td>SimCSE</td></tr><tr><td>10&#x2F;10</td><td>Structural Pre-training for Dialogue Comprehension</td><td>SPIDER</td></tr><tr><td>10&#x2F;11</td><td>What Makes for Good Views for Contrastive Learning?</td><td></td></tr><tr><td>10&#x2F;21</td><td>ConSERT: A Contrastive Framework for Self-Supervised Sentence Representation Transfer</td><td>ConSERT</td></tr><tr><td>10&#x2F;23</td><td>Fine-grained Post-training for Improving Retrieval-based Dialogue Systems</td><td>BERT-FP</td></tr><tr><td>10&#x2F;26</td><td>SEMANTIC RE-TUNING WITH CONTRASTIVE TENSION</td><td>CT</td></tr><tr><td>10&#x2F;27</td><td>PRE-TRAINING TASKS FOR EMBEDDING-BASED LARGE-SCALE RETRIEVAL</td><td></td></tr></tbody></table><h2 id="11-月"><a href="#11-月" class="headerlink" title="11 月"></a>11 月</h2><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>11&#x2F;3</td><td>Building an Efficient and Effective Retrieval-based Dialogue System</td><td>BE&#x2F;CE</td></tr></tbody></table><h2 id="12-月"><a href="#12-月" class="headerlink" title="12 月"></a>12 月</h2><p>才发现自己已经摆烂一个多月了。接下来重点放在代码实现上，读完论文一定要看代码。</p><table><thead><tr><th>日期</th><th>标题</th><th>备注</th></tr></thead><tbody><tr><td>12&#x2F;6</td><td>Prompt Tuning Can Be Comparable to Fine-tuning Universally Across Scales and Tasks</td><td>P-Tuning v2</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PyMongo 基本概念和操作</title>
    <link href="/mongo/pymongo-basic/"/>
    <url>/mongo/pymongo-basic/</url>
    
    <content type="html"><![CDATA[<h1 id="PyMongo-基本概念和操作"><a href="#PyMongo-基本概念和操作" class="headerlink" title="PyMongo 基本概念和操作"></a>PyMongo 基本概念和操作</h1><p>最近尝试用数据库来给数据集提前储存 encode 好的 embeddings，原本想用 Sqlite 的，但是想到各种储存列表、大数值向量都很麻烦，于是去试了试非关系型数据库 MongoDB，发现用的是真的方便真的爽。</p><p>本文通过 MongoDB 的 python 接口例子来说明常用的一些使用方法。</p><h2 id="MongoDB-基本概念"><a href="#MongoDB-基本概念" class="headerlink" title="MongoDB 基本概念"></a>MongoDB 基本概念</h2><p>一篇写的不错的知乎文章：<a href="https://zhuanlan.zhihu.com/p/87722764">https://zhuanlan.zhihu.com/p/87722764</a></p><h3 id="数据库基本模型"><a href="#数据库基本模型" class="headerlink" title="数据库基本模型"></a>数据库基本模型</h3><table><thead><tr><th>MongoDB 概念</th><th>对应的 SQL 概念</th><th>备注</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>一个数据库包含多个集合（collection）</td></tr><tr><td>collection</td><td>table</td><td>可以储存多个文档，且没有模式限制</td></tr><tr><td>document</td><td>row</td><td>由多个字段表示，使用的 BSON 格式（类似 JSON）</td></tr><tr><td>field</td><td>column</td><td>字段可储存任意数据格式，如列表</td></tr></tbody></table><h3 id="BSON-数据类型"><a href="#BSON-数据类型" class="headerlink" title="BSON 数据类型"></a>BSON 数据类型</h3><p>BSON，Binary JSON，不能说跟 JSON 很像，只能说是一模一样。（并不，实际上多了索引等数据，且支持的数据类型也更多）</p><figure class="highlight json"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;_id&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<span class="hljs-attr">&quot;first&quot;</span>: <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-attr">&quot;last&quot;</span>: <span class="hljs-string">&quot;Backus&quot;</span>&#125;,<br>    <span class="hljs-attr">&quot;contribs&quot;</span>: [<span class="hljs-string">&quot;Fortran&quot;</span>, <span class="hljs-string">&quot;ALGOL&quot;</span>, <span class="hljs-string">&quot;Backus-Naur Form&quot;</span>, <span class="hljs-string">&quot;FP&quot;</span>],<br>    <span class="hljs-attr">&quot;awards&quot;</span>: [<br>        &#123;<br>            <span class="hljs-attr">&quot;award&quot;</span>: <span class="hljs-string">&quot;W.W. McDowell Award&quot;</span>,<br>            <span class="hljs-attr">&quot;year&quot;</span>: <span class="hljs-number">1967</span>,<br>            <span class="hljs-attr">&quot;by&quot;</span>: <span class="hljs-string">&quot;IEEE Computer Society&quot;</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">&quot;award&quot;</span>: <span class="hljs-string">&quot;Draper Prize&quot;</span>,<br>            <span class="hljs-attr">&quot;year&quot;</span>: <span class="hljs-number">1993</span>,<br>            <span class="hljs-attr">&quot;by&quot;</span>: <span class="hljs-string">&quot;National Academy of Engineering&quot;</span><br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>_id</code> 字段是一条记录的主键，在 collection 中是唯一的，可以由系统自动生成（类型为 <code>ObjectId</code>），也可以自己指定。</p><h2 id="PyMongo-基本操作"><a href="#PyMongo-基本操作" class="headerlink" title="PyMongo 基本操作"></a>PyMongo 基本操作</h2><p>记得先安装并 import 哦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<br></code></pre></td></tr></table></figure><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><h4 id="连接数据库服务器（无密码）"><a href="#连接数据库服务器（无密码）" class="headerlink" title="连接数据库服务器（无密码）"></a>连接数据库服务器（无密码）</h4><p>默认端口号是 27017</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">client = pymongo.MongoClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">27017</span>)<br></code></pre></td></tr></table></figure><h4 id="获取具体的数据库、集合"><a href="#获取具体的数据库、集合" class="headerlink" title="获取具体的数据库、集合"></a>获取具体的数据库、集合</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">client = pymongo.MongoClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">27017</span>)<br><br><span class="hljs-comment"># 获取名字为 udc 的数据库</span><br>db = client[<span class="hljs-string">&quot;udc&quot;</span>]<br><br><span class="hljs-comment"># 获取数据库中两个集合</span><br>example_collection = db[<span class="hljs-string">&quot;example&quot;</span>]<br>candidate_collection = db[<span class="hljs-string">&quot;candidate&quot;</span>]<br></code></pre></td></tr></table></figure><p>如果数据库或集合未被创建，则会新建一个。（实际的创建行为会在写入第一个记录时才发生）</p><h3 id="CRUD-操作"><a href="#CRUD-操作" class="headerlink" title="CRUD 操作"></a>CRUD 操作</h3><p>以在某个 collection 上的查询为例子，操作非常简单，指定对应的字段名即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">example_collection.find_one(&#123;<span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-number">100012</span>&#125;)<br></code></pre></td></tr></table></figure><p>其他具体操作请查阅 MongoDB 官方文档：<a href="https://docs.mongodb.com/manual/crud/">https://docs.mongodb.com/manual/crud/</a></p><p>以及 pymongo 的示例：<a href="https://pymongo.readthedocs.io/en/stable/tutorial.html">https://pymongo.readthedocs.io/en/stable/tutorial.html</a></p><h3 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>聚合（aggregation）稍微复杂，重要的<strong>关联查询</strong>就是使用这种操作完成的。MongoDB 中，可以给一系列的聚合操作定义一个 pipeline，像流水线一样层层过滤和组装，得到最终结果。</p><p>流水线通常是一个字典列表， 列表中每一个字典都是一个聚合操作，字典的 key 就是下面这些 $ 开头的字符串，对应的 value 是具体的参数字典。PyMongo 的一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">pipeline = [<br>    &#123;<br>        <span class="hljs-string">&quot;$sample&quot;</span>: &#123;   <span class="hljs-comment"># 操作名称为 $sample</span><br>            <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">3</span>  <span class="hljs-comment"># 参数名 size 的值为 3</span><br>        &#125;<br>    &#125;,<br>    ...<br>]<br></code></pre></td></tr></table></figure><h4 id="常用的一些聚合操作类型"><a href="#常用的一些聚合操作类型" class="headerlink" title="常用的一些聚合操作类型"></a>常用的一些聚合操作类型</h4><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>$project</td><td>指定输出文档中的字段</td></tr><tr><td>$match</td><td>相当于 query 语句</td></tr><tr><td>$limit</td><td>限制传递给下一步的文档数量</td></tr><tr><td>$lookup</td><td>多表关联查询</td></tr><tr><td>$sample</td><td>随机取样</td></tr><tr><td>$group</td><td>根据 key 分组文档</td></tr><tr><td>$sort</td><td>根据指定的字段排序文档</td></tr></tbody></table><p>具体见：</p><ul><li><a href="https://docs.mongodb.com/manual/core/aggregation-pipeline/">https://docs.mongodb.com/manual/core/aggregation-pipeline/</a></li><li><a href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/">https://docs.mongodb.com/manual/meta/aggregation-quick-reference/</a></li></ul><h4 id="关联查询-lookup"><a href="#关联查询-lookup" class="headerlink" title="关联查询 $lookup"></a>关联查询 <code>$lookup</code></h4><p>语法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;$lookup&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;from&quot;</span>: <span class="hljs-string">&quot;candidate&quot;</span>,<br>    <span class="hljs-attr">&quot;localField&quot;</span>: <span class="hljs-string">&quot;candidate_ids&quot;</span>,<br>    <span class="hljs-attr">&quot;foreignField&quot;</span>: <span class="hljs-string">&quot;_id&quot;</span>,<br>    <span class="hljs-attr">&quot;as&quot;</span>: <span class="hljs-string">&quot;candidates&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>from</td><td>关联的外表</td></tr><tr><td>localField</td><td>本表的关联字段</td></tr><tr><td>foreignField</td><td>外表的关联字段</td></tr><tr><td>as</td><td>输出的字段值</td></tr></tbody></table><p>所以上面的语句就是我现在在 <code>example</code> 集合（本表）中，跑去看名为 <code>candidate</code> 的集合（外表），将本表中 <code>candidates_ids</code> 字段中与外表的 <code>_id</code> 字段进行关联，相同的值的外表文档输出到一个列表里，插入到本表文档中，字段名为 <code>candidates</code> 。</p><p>在我的例子中，我的 <code>candidates_ids </code> 本身就是一个列表，里面仅储存了另一个集合的主键（相当于外键），因此关联后返回一个列表，里面的元素是外表中的文档。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">_id:<span class="hljs-number">1100142</span><br>tag:<span class="hljs-string">&quot;dev&quot;</span><br>context:Array<br>response_id:<span class="hljs-string">&quot;9ZOANIYSNBUL&quot;</span><br>candidate_ids:Array<br>cadidates:Array<br></code></pre></td></tr></table></figure><h4 id="PyMongo-使用流水线进行聚合的示例"><a href="#PyMongo-使用流水线进行聚合的示例" class="headerlink" title="PyMongo 使用流水线进行聚合的示例"></a>PyMongo 使用流水线进行聚合的示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">pipeline = [<br>        &#123;<br>            <span class="hljs-string">&quot;$match&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-number">1105000</span><br>            &#125;<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;$sample&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;size&quot;</span>: <span class="hljs-number">5</span><br>            &#125;<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;$lookup&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-string">&quot;candidate&quot;</span>,<br>                <span class="hljs-string">&quot;localField&quot;</span>: <span class="hljs-string">&quot;candidate_ids&quot;</span>,<br>                <span class="hljs-string">&quot;foreignField&quot;</span>: <span class="hljs-string">&quot;_id&quot;</span>,<br>                <span class="hljs-string">&quot;as&quot;</span>: <span class="hljs-string">&quot;candidates&quot;</span><br>            &#125;<br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;$lookup&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;from&quot;</span>: <span class="hljs-string">&quot;candidate&quot;</span>,<br>                <span class="hljs-string">&quot;localField&quot;</span>: <span class="hljs-string">&quot;response_id&quot;</span>,<br>                <span class="hljs-string">&quot;foreignField&quot;</span>: <span class="hljs-string">&quot;_id&quot;</span>,<br>                <span class="hljs-string">&quot;as&quot;</span>: <span class="hljs-string">&quot;response&quot;</span><br>            &#125;<br>        &#125;<br>    ]<br><br>    <span class="hljs-keyword">with</span> example_collection.aggregate(pipeline, batchSize=batch_size) <span class="hljs-keyword">as</span> cursor:<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> cursor:<br>            <span class="hljs-built_in">print</span>(item[<span class="hljs-string">&quot;tag&quot;</span>])<br></code></pre></td></tr></table></figure><p>定义 <code>pipeline</code> 为聚合操作的列表，然后在 <code>example_collection</code> 集合上进行关联查询，返回一个 <code>cursor</code> 对象。可以直接遍历这个对象拿到值。</p><h3 id="cursor-对象"><a href="#cursor-对象" class="headerlink" title="cursor 对象"></a><code>cursor</code> 对象</h3><p>实际上是一个用于遍历 MongoDB 查询结果的工具。详见：<a href="https://pymongo.readthedocs.io/en/stable/api/pymongo/cursor.html">https://pymongo.readthedocs.io/en/stable/api/pymongo/cursor.html</a></p><p>具体用法有空另开一篇写，这篇就先到这儿了。</p>]]></content>
    
    
    <categories>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go build 命令用法</title>
    <link href="/programming/go-build/"/>
    <url>/programming/go-build/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-build-命令用法"><a href="#Go-build-命令用法" class="headerlink" title="Go build 命令用法"></a>Go build 命令用法</h1><h2 id="按文件打包"><a href="#按文件打包" class="headerlink" title="按文件打包"></a>按文件打包</h2><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">go build main.go utils.go<br></code></pre></td></tr></table></figure><h2 id="按包名打包"><a href="#按包名打包" class="headerlink" title="按包名打包"></a>按包名打包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go build go-message-pusher<br></code></pre></td></tr></table></figure><h2 id="打包到不同操作系统"><a href="#打包到不同操作系统" class="headerlink" title="打包到不同操作系统"></a>打包到不同操作系统</h2><p>设置两个环境变量：</p><ul><li><code>GOARCH</code> &#x3D; amd64</li><li><code>GOOS</code> &#x3D; linux | windows</li></ul><h2 id="其他附加参数"><a href="#其他附加参数" class="headerlink" title="其他附加参数"></a>其他附加参数</h2><table><thead><tr><th>参数</th><th>备注</th></tr></thead><tbody><tr><td>-o</td><td>指定编译输出的名称</td></tr><tr><td>-i</td><td>安装作为目标依赖的包</td></tr><tr><td>-v</td><td>编译时显示包名</td></tr><tr><td>-p n</td><td>开启并发编译，默认情况下该值为 CPU 逻辑核数</td></tr><tr><td>-a</td><td>强制重新构建</td></tr><tr><td>-x</td><td>打印编译时会用到的所有命令</td></tr><tr><td>-n</td><td>打印编译时会用到的所有命令，但不真正执行</td></tr><tr><td>-race</td><td>开启竞态检测</td></tr></tbody></table><h2 id="GoLand-中的设置示例"><a href="#GoLand-中的设置示例" class="headerlink" title="GoLand 中的设置示例"></a>GoLand 中的设置示例</h2><p><img src="https://i.loli.net/2021/08/21/peVkNE19O4GwClj.png"></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串转换整数</title>
    <link href="/leetcode/top-interview-questions-easy/string-to-integer-atoi/"/>
    <url>/leetcode/top-interview-questions-easy/string-to-integer-atoi/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串转换整数-atoi"><a href="#字符串转换整数-atoi" class="headerlink" title="字符串转换整数 (atoi)"></a>字符串转换整数 (atoi)</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnoilh/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnoilh/</a></p><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p><h2 id="有限状态机-FSM"><a href="#有限状态机-FSM" class="headerlink" title="有限状态机 (FSM)"></a>有限状态机 (FSM)</h2><p>字符串处理的题目往往涉及复杂的流程以及条件情况，如果直接上手写程序，一不小心就会写出极其臃肿的代码。臃肿还是其次，一堆 if-else 各种边界条件严格的想吐。。</p><p>使用有限状态机实现各种状态之间的转移。根据题目，容易画出来状态机图：</p><p><img src="https://i.loli.net/2021/08/06/3OLdx5pKkloamte.png"></p><p>状态机可以用一个状态转移表来实现。如图所示，行头是当前状态，列头是下一个输入，表中内容是跳转至的状态。直接将这个表编码进程序中，在状态为 in_number 时计数。</p><p><img src="https://i.loli.net/2021/08/06/XTm849u6plGHdSt.png"></p><p>对于 C++，居然可以用 long long 类型来计数，再去判断它跟 INT_MAX 和 INT_MIN 谁大谁小，属实有点无语。自己写程序的时候搞了半天。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Automaton</span> &#123;</span><br>    string state = <span class="hljs-string">&quot;start&quot;</span>;<br>    unordered_map&lt;string, vector&lt;string&gt;&gt; table = &#123;<br>        &#123;<span class="hljs-string">&quot;start&quot;</span>, &#123;<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;signed&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;signed&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;in_number&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;in_number&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;,<br>        &#123;<span class="hljs-string">&quot;end&quot;</span>, &#123;<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>&#125;&#125;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_col</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isspace</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;+&#x27;</span> <span class="hljs-keyword">or</span> c == <span class="hljs-string">&#x27;-&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> sign = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span> </span>&#123;<br>        state = table[state][<span class="hljs-built_in">get_col</span>(c)];<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-string">&quot;in_number&quot;</span>) &#123;<br>            ans = ans * <span class="hljs-number">10</span> + c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            ans = sign == <span class="hljs-number">1</span> ? <span class="hljs-built_in">min</span>(ans, (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MAX) : <span class="hljs-built_in">min</span>(ans, -(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MIN);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == <span class="hljs-string">&quot;signed&quot;</span>)<br>            sign = c == <span class="hljs-string">&#x27;+&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">myAtoi</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        Automaton automaton;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : str)<br>            automaton.<span class="hljs-built_in">get</span>(c);<br>        <span class="hljs-keyword">return</span> automaton.sign * automaton.ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证回文串</title>
    <link href="/leetcode/top-interview-questions-easy/valid-palindrome/"/>
    <url>/leetcode/top-interview-questions-easy/valid-palindrome/</url>
    
    <content type="html"><![CDATA[<h1 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xne8id/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xne8id/</a></p><p><a href="https://leetcode-cn.com/problems/valid-palindrome/">https://leetcode-cn.com/problems/valid-palindrome/</a></p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>左右指针，移动到合法位置（只能是字母、数字）后比较字符是否相同。</p><p>时间复杂度：<code>O(n)</code></p><p>空间复杂度：<code>O(1)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = s.<span class="hljs-built_in">length</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isalnum</span>(s[l])) &#123;<br>            ++l;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isalnum</span>(s[r])) &#123;<br>            --r;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">tolower</span>(s[l]) != <span class="hljs-built_in">tolower</span>(s[r])) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ++l;<br>        --r;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛选-判断"><a href="#筛选-判断" class="headerlink" title="筛选 + 判断"></a>筛选 + 判断</h2><p>比较蠢的方法，就不谈了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>双指针</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>玩 MineCraft 的 Fabric 服务器</title>
    <link href="/essay/minecraft-fabric-server/"/>
    <url>/essay/minecraft-fabric-server/</url>
    
    <content type="html"><![CDATA[<h1 id="玩-MineCraft-的-Fabric-服务器"><a href="#玩-MineCraft-的-Fabric-服务器" class="headerlink" title="玩 MineCraft 的 Fabric 服务器"></a>玩 MineCraft 的 Fabric 服务器</h1><p>MineCraft Java 版有两种常见的非官方服务器，Forge 和 Fabric，相当于是提供了官方接口之上再次的封装，让 mod 开发者更加方便编程。</p><p>网上有说法称 Fabric 服务器更小巧，且 Forge 已经比较老了，故最终选择了 Fabric。</p><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="安装-Fabric-服务器"><a href="#安装-Fabric-服务器" class="headerlink" title="安装 Fabric 服务器"></a>安装 Fabric 服务器</h3><p>可以完全参照 Fabric 官网的文档：<a href="https://fabricmc.net/wiki/player:tutorials:install_server">Installing a Fabric Server without a GUI</a>，按部就班即可。</p><p>注意，在按照文档的示例一通命名改名操作后，启动命令是<code>java -jar server.jar</code>，而非<code>java -jar vanilla.jar</code>，后者相当于原版服务器，mod 不会生效。</p><p>可以使用与官方服务器相同的参数来指定使用的内存大小。例如：<code>java -Xms1024M -Xmx1024M -jar server.jar</code></p><h3 id="安装-Mod"><a href="#安装-Mod" class="headerlink" title="安装 Mod"></a>安装 Mod</h3><p>一些 mod 是要求在服务器上安装，另一些则是需要在本地客户端上安装，还有一些是两者都要。安装 mod 时需要看清 mod 本身的说明。</p><p>服务端安装 mod，将 mod 的 jar 包直接放入游戏根目录的 <code>mods</code> 目录下，重启服务器即可。mod 本身可能会有设置，对应的配置文件在 <code>config</code> 目录中。</p><p><img src="https://i.loli.net/2021/08/04/Gh38n2fHJq6d9OK.png" alt="mods 和 config 目录示意图"></p><p>目前我在服务端安装的 mod：（1.17.1 版本可用）</p><ul><li>Fabric API</li><li>修改苦力怕爆炸的行为（environmentalcreepers）</li><li>一键砍树（FallingTree）</li><li>连锁挖矿（diggusmaximus）（客户端服务器都要装）</li></ul><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="安装-Fabric-客户端"><a href="#安装-Fabric-客户端" class="headerlink" title="安装 Fabric 客户端"></a>安装 Fabric 客户端</h3><p>在这里下载 Fabric Installer：<a href="https://fabricmc.net/use/">Installation for: Minecraft Launcher</a></p><p>对于我用的 Windows 系统，jar 包和 .exe 文件都可以，运行后按提示安装即可。最好使用默认目录，防止自己忘记。</p><h3 id="安装-Mod-1"><a href="#安装-Mod-1" class="headerlink" title="安装 Mod"></a>安装 Mod</h3><p>直接将jar包放到这个目录中：<code>C:\Users\你的用户名\AppData\Roaming\.minecraft\mods</code></p><p>目前我在客户端安装的 mod：（1.17.1 版本可用）</p><ul><li>Fabric API</li><li>钓鱼自动收杆（Autofish）</li><li>连锁挖矿（diggusmaximus）（客户端服务器都要装）</li><li>小地图（voxel map）（非常好用！！）</li><li>mod 管理菜单（mod menu）</li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MineCraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效字母异位词</title>
    <link href="/leetcode/top-interview-questions-easy/valid-anagram/"/>
    <url>/leetcode/top-interview-questions-easy/valid-anagram/</url>
    
    <content type="html"><![CDATA[<h1 id="有效字母异位词"><a href="#有效字母异位词" class="headerlink" title="有效字母异位词"></a>有效字母异位词</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn96us/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn96us/</a></p><p><a href="https://leetcode-cn.com/problems/valid-anagram/">https://leetcode-cn.com/problems/valid-anagram/</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>用一个哈希表储存字母出现次数。在字符串 <code>s</code> 中出现的 +1，在 <code>t</code> 中出现的 -1，最后看是不是全为 0 即可。</p><p>时间复杂度：<code>O(n)</code></p><p>空间复杂度：<code>O(|Σ|)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; m;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> &amp;c: s) &#123;<br>        m[c] += <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> &amp;c: t) &#123;<br>        m[c] -= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> curr = m.<span class="hljs-built_in">begin</span>(); curr != m.<span class="hljs-built_in">end</span>(); ++curr) &#123;<br>        <span class="hljs-keyword">if</span> (curr -&gt; second != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="排序后比较"><a href="#排序后比较" class="headerlink" title="排序后比较"></a>排序后比较</h2><p>排序后比较字符串是否相等。</p><p>时间复杂度：快速排序平均复杂度为 <code>O(nlogn)</code></p><p>空间复杂度：排序所需要的空间为 <code>O(logn)</code></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一个唯一字符</title>
    <link href="/leetcode/top-interview-questions-easy/first-unique-character-in-a-string/"/>
    <url>/leetcode/top-interview-questions-easy/first-unique-character-in-a-string/</url>
    
    <content type="html"><![CDATA[<h1 id="第一个唯一字符"><a href="#第一个唯一字符" class="headerlink" title="第一个唯一字符"></a>第一个唯一字符</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn5z8r/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xn5z8r/</a></p><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></p><h2 id="哈希表储存出现次数"><a href="#哈希表储存出现次数" class="headerlink" title="哈希表储存出现次数"></a>哈希表储存出现次数</h2><p>第一次遍历用哈希表统计出现次数，第二次遍历找到第一个出现次数为 1 的字符。</p><p>时间复杂度：<code>O(n)</code></p><p>空间复杂度：<code>O(|Σ|)</code> （需要最大为词表大小的空间来储存哈希表）</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; m;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c: s) &#123;<br>        m[c] += <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">length</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (m[s[i]] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表储存出现的索引"><a href="#哈希表储存出现的索引" class="headerlink" title="哈希表储存出现的索引"></a>哈希表储存出现的索引</h2><p>第一次遍历用哈希表储存索引，如果已经存在，就将索引值设为 -1 。第二次遍历，找出索引值最小的，返回。</p><p>时间、空间复杂度与上一个方法相同。</p><h2 id="哈希表储存出现索引-队列"><a href="#哈希表储存出现索引-队列" class="headerlink" title="哈希表储存出现索引 + 队列"></a>哈希表储存出现索引 + 队列</h2><p>用和方法二一样的哈希表储存索引值，用一个队列来跟踪哪些字符是只出现一次的。</p><p>在插入字符时，如果不存在（第一次出现），将插入的字符及其索引加入到队列尾。而如果插入了一个已经出现过的字符时，从头开始检查队列，如果头元素出现过多次（在哈希表中对应的值为 -1），就弹出。</p><p>其实就是使用队列来维持字符原本的顺序，如果队列头的字符出现了多次就踢掉。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; position;<br>    queue&lt;pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;&gt; q;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (!position.<span class="hljs-built_in">count</span>(s[i])) &#123;<br>            position[s[i]] = i;<br>            q.<span class="hljs-built_in">emplace</span>(s[i], i);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            position[s[i]] = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; position[q.<span class="hljs-built_in">front</span>().first] == <span class="hljs-number">-1</span>) &#123;<br>                q.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : q.<span class="hljs-built_in">front</span>().second;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度：遍历字符串 <code>O(n)</code> + 队列操作 <code>O(|Σ|)</code>  &#x3D; <code>O(n)</code></p><p>空间复杂度：<code>O(|Σ|)</code></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
      <tag>哈希表</tag>
      
      <tag>队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>干掉 Disqus 评论区广告</title>
    <link href="/blog/fuck-disqus-ads/"/>
    <url>/blog/fuck-disqus-ads/</url>
    
    <content type="html"><![CDATA[<h1 id="干掉Disqus评论区广告"><a href="#干掉Disqus评论区广告" class="headerlink" title="干掉Disqus评论区广告"></a>干掉Disqus评论区广告</h1><p>这 Disqus 评论区的广告真是越来越离谱了，虽然内容看着还行，但是评论上面六个大图下面也六个大图，都™要比我博客本身的内容还多了，不治治它它就真不知道什么是黑手。</p><p><img src="https://i.loli.net/2021/07/20/ATIczgZXp7SwLPf.png" alt="我啪的一下就点进去看了，很快啊"></p><p>这些广告会延迟加载，直接使用 css 隐藏的方法不好用。一般这个 ID 为 disqus_thread 的 div 通常有 2 到 3 个 iframe，一般第一个和第三个都是广告。这个函数会等待两秒，等广告加载出来后再把它隐藏掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> disqus = jQuery(<span class="hljs-string">&#x27;#disqus_thread&#x27;</span>);<br><br>disqus.ready(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (disqus.children().length &gt;= <span class="hljs-number">2</span>) &#123;<br>      <span class="hljs-keyword">const</span> comments = disqus.find(<span class="hljs-string">&#x27;iframe:nth-child(2)&#x27;</span>).detach();<br>      disqus.empty().append(comments);<br>    &#125;<br>  &#125;, <span class="hljs-number">2000</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>最后将这段脚本插入到自定义 js 中。对于我的 Fluid 主题，把 js 文件放在 source 文件夹下的任意地方，然后在配置文件中指定就好了。</p>]]></content>
    
    
    <categories>
      
      <category>博客建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>个人域名绑定 Github pages</title>
    <link href="/blog/add-domain/"/>
    <url>/blog/add-domain/</url>
    
    <content type="html"><![CDATA[<h1 id="个人域名绑定-Github-pages"><a href="#个人域名绑定-Github-pages" class="headerlink" title="个人域名绑定 Github pages"></a>个人域名绑定 Github pages</h1><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>我是在腾讯云上买的域名，按照指示按部就班就好，各种实名认证都搞好，审核速度还是挺快的。</p><h2 id="添加-DNS-解析记录"><a href="#添加-DNS-解析记录" class="headerlink" title="添加 DNS 解析记录"></a>添加 DNS 解析记录</h2><p>来到腾讯云的控制台，添加类型为 CNAME 的记录，指向自己原来的 GitHub Page 名<code>xxx.github.io</code>。</p><p>这里我添加的是 blog 子域名，记录值如下图所示。</p><p><img src="https://i.loli.net/2021/07/19/NXI9p5ymYvCxhBf.png" alt="这里我只用了 blog 子域名而没有直接解析主域名(@)"></p><h2 id="GitHub-pages相关设置"><a href="#GitHub-pages相关设置" class="headerlink" title="GitHub pages相关设置"></a>GitHub pages相关设置</h2><h3 id="添加-CNAME-文件"><a href="#添加-CNAME-文件" class="headerlink" title="添加 CNAME 文件"></a>添加 CNAME 文件</h3><p><strong>在博客源分支的<code>source</code>目录下创建名为 CNAME 的文件</strong>，内容为刚才添加了解析规则的域名。例如我的是：blog.gentlecomet.com。</p><p>由于我的博客使用的是 Hexo 以及 GitHub action 的自动部署，如果直接放在部署分支中，会在 push 源分支的时候被自动删掉，必须放在源分支的<code>source</code>目录下才行，这样部署的时候这个文件也会被正确地放到部署的分支中。</p><h3 id="设置-pages"><a href="#设置-pages" class="headerlink" title="设置 pages"></a>设置 pages</h3><p>在仓库的 Settings 里找到 Pages 选项卡，设置 custom domain 为 CNAME 中的域名，save 即可。最后把强制 HTTPS 打开就好了。</p><p><img src="https://i.loli.net/2021/07/19/RAjPHGbsDiNFzE2.png"></p><p>注意这一步实际上会自动添加一个 CNAME 文件在部署分支里。</p><h2 id="关于我的域名"><a href="#关于我的域名" class="headerlink" title="关于我的域名"></a>关于我的域名</h2><p>有选择困难症，想域名的时候想了好久。最后选了这个 gentle comet，neta 了我很喜欢的 YOASOBI 的一首歌 <strong>優しい彗星</strong> 的英文翻译，意为”温柔的彗星“。</p>]]></content>
    
    
    <categories>
      
      <category>博客建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>整数反转</title>
    <link href="/leetcode/top-interview-questions-easy/reverse-integer/"/>
    <url>/leetcode/top-interview-questions-easy/reverse-integer/</url>
    
    <content type="html"><![CDATA[<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnx13t/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnx13t/</a></p><p><a href="https://leetcode-cn.com/problems/reverse-integer/">https://leetcode-cn.com/problems/reverse-integer/</a></p><h2 id="逐位运算"><a href="#逐位运算" class="headerlink" title="逐位运算"></a>逐位运算</h2><p>使用<code>x % 10</code>取得个位数的值，将它加到临时值<code>ret</code>中，并且让<code>ret</code>倍增10。</p><p>使用<code>x /= 10</code>来去掉个位（C++）。</p><p><strong>用<code>INT_MIN / 10</code>和<code>INT_MAX / 10</code>来提前判断是否会越界</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (x != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (ret &lt; INT_MIN / <span class="hljs-number">10</span> || ret &gt; INT_MAX / <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> last = x % <span class="hljs-number">10</span>;<br>        x /= <span class="hljs-number">10</span>;<br>        ret = <span class="hljs-number">10</span> * ret + last;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反转字符串</title>
    <link href="/leetcode/top-interview-questions-easy/reverse-string/"/>
    <url>/leetcode/top-interview-questions-easy/reverse-string/</url>
    
    <content type="html"><![CDATA[<h1 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhbqj/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhbqj/</a></p><p><a href="https://leetcode-cn.com/problems/reverse-string/">https://leetcode-cn.com/problems/reverse-string/</a></p><h2 id="直接交换"><a href="#直接交换" class="headerlink" title="直接交换"></a>直接交换</h2><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n/<span class="hljs-number">2</span> ; ++i) &#123;<br>        <span class="hljs-built_in">swap</span>(s[i], s[n<span class="hljs-number">-1</span>-i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>官方题解是双指针，其实是差不多的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">char</span>&gt;&amp; s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>; left &lt; right; ++left, --right) &#123;<br>        <span class="hljs-built_in">swap</span>(s[left], s[right]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>字符串</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署自己的 MineCraft 服务器</title>
    <link href="/essay/deploy-minecraft-server/"/>
    <url>/essay/deploy-minecraft-server/</url>
    
    <content type="html"><![CDATA[<h1 id="部署自己的-MineCraft-服务器"><a href="#部署自己的-MineCraft-服务器" class="headerlink" title="部署自己的 MineCraft 服务器"></a>部署自己的 MineCraft 服务器</h1><p>放假在家突然想玩新版MC，买了个Java版和朋友联机玩。记录一下折腾过程。</p><h2 id="服务器的配置要求"><a href="#服务器的配置要求" class="headerlink" title="服务器的配置要求"></a>服务器的配置要求</h2><p>原本在朋友1核2G的服务器上玩，遇到了第三个玩家加入就会被踢出去的问题，而服务器内存和CPU并未过载，推测是带宽不足（为128KB）。可能出现的错误信息有：</p><ul><li>登入失败：身份验证目前正在停机维护</li><li>lost connection：timed out</li></ul><p><img src="https://i.loli.net/2021/07/19/NsQHjSEZBkLTnOz.png" alt="错误信息"></p><p>为了能愉快地玩耍，在阿里云上买了个所谓的轻量应用服务器，2核2G内存，关键是峰值带宽为5M。搞定以后解决了所有问题，3个人玩的很流畅。虽然每月限流1000GB，但还是完全够用。一年99，并且再续费一年似乎也是99，感觉挺不错的。</p><p><img src="https://i.loli.net/2021/07/19/LaSM8ypwVfiJmAI.png" alt="我买的服务器的配置"></p><h2 id="开放服务器端口"><a href="#开放服务器端口" class="headerlink" title="开放服务器端口"></a>开放服务器端口</h2><p>在阿里云的服务器控制台中设置防火墙规则，开放MC要用的<code>25565</code>端口。</p><p><img src="https://i.loli.net/2021/07/19/5x8Vbvz1nkrqmPf.png" alt="不知道用的是TCP还是UDP，那就全部开放"></p><h2 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h2><h3 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">apt install openjdk-16-jre-headless<br></code></pre></td></tr></table></figure><h3 id="安装screen"><a href="#安装screen" class="headerlink" title="安装screen"></a>安装screen</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt install screen<br></code></pre></td></tr></table></figure><h3 id="下载MC服务器程序"><a href="#下载MC服务器程序" class="headerlink" title="下载MC服务器程序"></a>下载MC服务器程序</h3><p>下载地址见：<a href="https://www.minecraft.net/en-us/download/server">DOWNLOAD THE MINECRAFT: JAVA EDITION SERVER</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://launcher.mojang.com/v1/objects/a16d67e5807f57fc4e550299cf20226194497dc2/server.jar<br></code></pre></td></tr></table></figure><p>就是一个jar包，用Java运行这个包就启动了服务器。</p><h2 id="启动游戏服务器"><a href="#启动游戏服务器" class="headerlink" title="启动游戏服务器"></a>启动游戏服务器</h2><h3 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h3><p>创建了名为mc的会话。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S mc<br></code></pre></td></tr></table></figure><h3 id="运行游戏服务器"><a href="#运行游戏服务器" class="headerlink" title="运行游戏服务器"></a>运行游戏服务器</h3><p>两个参数<code>-Xmx</code>和<code>-Xms</code>分别指定了最大内存和最小内存。（均为1024M）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xmx1024M -Xms1024M -jar minecraft_server.1.17.1.jar nogui<br></code></pre></td></tr></table></figure><p>成功启动后就能看到各种提示信息，此时可以输入各种服务器命令了。</p><p><img src="https://i.loli.net/2021/07/19/MOFGxlQfTH5X3gd.png" alt="启动成功"></p><h3 id="保留Screen并退出"><a href="#保留Screen并退出" class="headerlink" title="保留Screen并退出"></a>保留Screen并退出</h3><p><code>ctrl + A + D</code></p><h3 id="再次进入"><a href="#再次进入" class="headerlink" title="再次进入"></a>再次进入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -r mc<br></code></pre></td></tr></table></figure><h3 id="强行杀死"><a href="#强行杀死" class="headerlink" title="强行杀死"></a>强行杀死</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S mc -X quit<br></code></pre></td></tr></table></figure><p>更多screen的用法详见：<a href="https://www.huaweicloud.com/articles/6d91932d9a65d3cb45101886ac6fe53a.html">linux中screen命令的用法</a></p><h2 id="MineCraft服务器属性"><a href="#MineCraft服务器属性" class="headerlink" title="MineCraft服务器属性"></a>MineCraft服务器属性</h2><p>详见：<a href="https://minecraft.fandom.com/zh/wiki/Server.properties?variant=zh#Java.E7.89.88_3">Minecraft服务器属性</a></p><p>编辑<code>server.properties</code>文件。</p><h2 id="MineCraft后台命令"><a href="#MineCraft后台命令" class="headerlink" title="MineCraft后台命令"></a>MineCraft后台命令</h2><p>详见：<a href="https://minecraft.fandom.com/zh/wiki/%E5%91%BD%E4%BB%A4?variant=zh#.E5.91.BD.E4.BB.A4.E5.88.97.E8.A1.A8.E5.8F.8A.E5.85.B6.E6.A6.82.E8.BF.B0">命令列表及其概述</a></p><p>启动服务器后直接输入命令即可，无需以<code>/</code>开头。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MineCraft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转图像</title>
    <link href="/leetcode/top-interview-questions-easy/rotate-image/"/>
    <url>/leetcode/top-interview-questions-easy/rotate-image/</url>
    
    <content type="html"><![CDATA[<h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhhkv/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/xnhhkv/</a></p><p><a href="https://leetcode-cn.com/problems/rotate-image/">https://leetcode-cn.com/problems/rotate-image/</a></p><h2 id="使用临时矩阵"><a href="#使用临时矩阵" class="headerlink" title="使用临时矩阵"></a>使用临时矩阵</h2><p>注意到旋转后元素位置和原位置的关系：</p><ul><li>原本在第n行，旋转后变成倒数第n列</li><li>原本在第m列，旋转后变成第m行</li></ul><p>即：<code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code></p><p>使用一个临时数组，利用上面这个规律更新临时数组。最后再将原数组换成临时数组，达到“原地修改”的目的。</p><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间空间复杂度都是<code>O(n^2)​</code></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> temp = matrix;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; n; ++row) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; ++col) &#123;<br>            temp[col][n<span class="hljs-number">-1</span>-row] = matrix[row][col];<br>        &#125;<br>    &#125;<br><br>    matrix.<span class="hljs-built_in">swap</span>(temp);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原地旋转"><a href="#原地旋转" class="headerlink" title="原地旋转"></a>原地旋转</h2><p>直接在原地将每一个元素移动到它应该在的地方，并且把要被覆盖的元素也移动走。容易发现旋转一次，一个位置的元素对应了4个位置的变化，且它们之间组成一个环。因此用temp保存最后一个被覆盖的值，然后依次移动并覆盖即可。</p><p>这4个元素旋转一次后，<strong>相对于上一个位置</strong>的关系都是<code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code>。转换成<strong>相对于第一个位置</strong>（绝对位置）的关系：</p><ol><li><code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code></li><li><code>matrix[col][n-1-row] -&gt; matrix_new[n-1-row][n-1-col]</code></li><li><code>matrix[n-1-row][n-1-col] -&gt; matrix_new[n-1-col][row]</code></li><li><code>matrix[n-1-col][row] -&gt; matrix_new[row][col]</code></li></ol><p>如同上面说的，组成了一个循环。用一个<code>temp</code>变量保 存第一个丢失的值<code>matrix[row][col]</code>即可。</p><p>还有一个问题：需要遍历矩阵中的哪些元素？显然，一次这样的操作移动好了4个元素，因此当边长n为偶数时，可以将矩阵分成一样大小的4块，只需操作其中一块；</p><p><img src="https://i.loli.net/2021/07/17/zgGOmqE2jDtAr8P.png"></p><p>对于左上角的这一块，它的范围是：</p><ul><li>行：n&#x2F;2</li><li>列：n&#x2F;2</li></ul><p>如果边长n为奇数的时候呢？使用这种巧妙的方法：</p><p><img src="https://i.loli.net/2021/07/17/b9NjW7KMGdnDQt3.png"></p><p>对于左上角这一块，它的范围是：</p><ul><li>行：<code>n/2</code></li><li>列：<code>n/2 + 1</code></li></ul><p>综合起来可以写成：</p><ul><li>行：<code>n/2</code></li><li>列：<code>n/2 + n%2</code> （或者<code>(n+1)/2</code>）</li></ul><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(1)</code></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 注意for循环的范围</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; n/<span class="hljs-number">2</span>; ++row) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n/<span class="hljs-number">2</span> + n%<span class="hljs-number">2</span>; ++col) &#123;<br>            <span class="hljs-keyword">int</span> temp = matrix[row][col];<br>            matrix[row][col] = matrix[n<span class="hljs-number">-1</span>-col][row];<br>            matrix[n<span class="hljs-number">-1</span>-col][row] = matrix[n<span class="hljs-number">-1</span>-row][n<span class="hljs-number">-1</span>-col];<br>            matrix[n<span class="hljs-number">-1</span>-row][n<span class="hljs-number">-1</span>-col] = matrix[col][n<span class="hljs-number">-1</span>-row];<br>            matrix[col][n<span class="hljs-number">-1</span>-row] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用翻转来代替旋转"><a href="#使用翻转来代替旋转" class="headerlink" title="使用翻转来代替旋转"></a>使用翻转来代替旋转</h2><p>上下翻转，然后主对角线翻转，就能得到答案。</p><p><img src="https://i.loli.net/2021/07/17/xn5CS9HVprRDQMl.png"></p><p>这是根据之前的那个关键公式推断的：<code>matrix[row][col] -&gt; matrix_new[col][n-1-row]</code>。观察这个公式，主要是两点：</p><ol><li><code>row</code>变成了<code>n-1-row</code>（正数变成倒数）</li><li><code>row</code>和<code>col</code>交换（转置）</li></ol><p>而1可以用上下翻转得到，这样正数第n行就变成了倒数第n行；2可以通过转置得到，即行号变成列号。</p><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度：<code>O(n^2)</code></p><p>空间复杂度：<code>O(1)</code></p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 水平翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[n - i - <span class="hljs-number">1</span>][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 主对角线翻转</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j) &#123;<br>            <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>矩阵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有效的数独</title>
    <link href="/leetcode/top-interview-questions-easy/valid-sudoku/"/>
    <url>/leetcode/top-interview-questions-easy/valid-sudoku/</url>
    
    <content type="html"><![CDATA[<h1 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2f9gg/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2f9gg/</a></p><p><a href="https://leetcode-cn.com/problems/valid-sudoku">https://leetcode-cn.com/problems/valid-sudoku</a></p><h2 id="我的方法"><a href="#我的方法" class="headerlink" title="我的方法"></a>我的方法</h2><p>容易想到的是使用哈希表来记录一行&#x2F;一列&#x2F;一个方格内是否出现了重复值。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = board.<span class="hljs-built_in">size</span>();<br>    unordered_set&lt;<span class="hljs-keyword">char</span>&gt; row, col, grid;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(row.<span class="hljs-built_in">insert</span>(board[i][j]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (board[j][i] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(col.<span class="hljs-built_in">insert</span>(board[j][i]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i%<span class="hljs-number">3</span>==<span class="hljs-number">0</span> &amp;&amp; j%<span class="hljs-number">3</span>==<span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">3</span>; ++x) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-number">3</span>; ++y) &#123;<br>                        <span class="hljs-keyword">if</span> (board[i+x][j+y] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(grid.<span class="hljs-built_in">insert</span>(board[i+x][j+y]).second)) &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            grid.<span class="hljs-built_in">clear</span>();<br>        &#125;<br>        row.<span class="hljs-built_in">clear</span>();<br>        col.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>每一行和每一列是否有重复值比较好搞，但是如何在一次遍历中就记录方格里的值呢？</p><p>我的方法是判断遍历到的值是不是方格左上角的元素，是的话再遍历整个方格。这样实际上多了不必要的访问。</p><h2 id="更好的方法"><a href="#更好的方法" class="headerlink" title="更好的方法"></a>更好的方法</h2><p>如何在一次遍历就访问到方格里的元素呢？大家可能很好奇如何在一次遍历就访问到方格里的元素。方法就是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> m = j / <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br><span class="hljs-keyword">int</span> n = j % <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>小编也很奇怪，为什么可以这样呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = board.<span class="hljs-built_in">size</span>();<br>    unordered_set&lt;<span class="hljs-keyword">char</span>&gt; row, col, grid;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(row.<span class="hljs-built_in">insert</span>(board[i][j]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (board[j][i] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(col.<span class="hljs-built_in">insert</span>(board[j][i]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> m = j / <span class="hljs-number">3</span> + i / <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">int</span> n = j % <span class="hljs-number">3</span> + i % <span class="hljs-number">3</span> * <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">if</span> (board[m][n] != <span class="hljs-string">&#x27;.&#x27;</span> &amp;&amp; !(grid.<span class="hljs-built_in">insert</span>(board[m][n]).second)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        row.<span class="hljs-built_in">clear</span>();<br>        col.<span class="hljs-built_in">clear</span>();<br>        grid.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两数之和</title>
    <link href="/leetcode/top-interview-questions-easy/two-sum/"/>
    <url>/leetcode/top-interview-questions-easy/two-sum/</url>
    
    <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2jrse/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2jrse/</a></p><p><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>双重循环遍历，时间复杂度显然是<code>O(n^2)</code></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>在暴力法中，对于每一个<code>x</code>，都需要遍历一次整个数组来寻找<code>target - x</code>。</p><p>如何加快<code>target - x</code>的寻找速度？答案就是使用哈希表来储存<code>target - x</code>的值，这样寻找<code>target - x</code>的时间复杂度只有<code>O(1)</code>，总时间复杂度为<code>O(n)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">auto</span> p = m.<span class="hljs-built_in">find</span>(nums[i]);<br>        <span class="hljs-keyword">if</span> (p == m.<span class="hljs-built_in">end</span>()) &#123;<br>            m.<span class="hljs-built_in">insert</span>(&#123;target-nums[i], i&#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> &#123;i, p -&gt; second&#125;;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><p>这里使用了 C++ 11的新特性列表初始化 (initialiser_list)，可以用花括号来初始化vector、作为函数参数使用、直接返回。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化</span><br>std::vector&lt;std::string&gt; words = &#123;<span class="hljs-string">&quot;the&quot;</span>, <span class="hljs-string">&quot;mortar&quot;</span>, <span class="hljs-string">&quot;holding&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;together&quot;</span>&#125;; <br><br><span class="hljs-built_in">twoSum</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;, <span class="hljs-number">7</span>); <span class="hljs-comment">// 作为参数</span><br><br><span class="hljs-function">std::vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">numbers</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;  <span class="hljs-comment">// 作为返回值</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动零</title>
    <link href="/leetcode/top-interview-questions-easy/move-zeros/"/>
    <url>/leetcode/top-interview-questions-easy/move-zeros/</url>
    
    <content type="html"><![CDATA[<h1 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2ba4i/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2ba4i/</a></p><p><a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p><h2 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h2><p>使用左右两个指针，右指针一直移动，当指向的数非0时，与左指针交换，并移动左指针一次。</p><ul><li>左右指针一开始会在一起，如果当前的数非 0 ，它们交换也不会有变化</li><li>当遇到为 0 的数时，左指针停在 0 上，右指针会继续走，并将另一个非 0 的数交换过来</li></ul><p><strong>不会存在这样的情况</strong>：左右指针都非 0，交换导致相对顺序改变，因为右指针只会在遇到 0 的时候超越左指针，即左指针要么和右指针在一起，要么左指针指的是 0。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">while</span> (right &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (nums[right] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[left], nums[right]);<br>            ++left;<br>        &#125;<br>        ++right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加一</title>
    <link href="/leetcode/top-interview-questions-easy/plus-one/"/>
    <url>/leetcode/top-interview-questions-easy/plus-one/</url>
    
    <content type="html"><![CDATA[<h1 id="加一"><a href="#加一" class="headerlink" title="加一"></a>加一</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2cv1c/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2cv1c/</a></p><p><a href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></p><h2 id="严密的逻辑"><a href="#严密的逻辑" class="headerlink" title="严密的逻辑"></a>严密的逻辑</h2><p>考虑所有可能的情况即可：</p><ol><li>不用进位，直接加一</li><li>需要进位，非最高位，则置为 0 并执行高一位的操作</li><li>需要进位，是最高位，则置为 0 并在前面插入一个 1，直接返回</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">plusOne</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; digits)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> curr = digits.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (curr; curr &gt;= <span class="hljs-number">0</span>; --curr) &#123;<br>        <span class="hljs-keyword">if</span> (digits[curr] + <span class="hljs-number">1</span> == <span class="hljs-number">10</span>) &#123;<br>            digits[curr] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (curr == <span class="hljs-number">0</span>) &#123;<br>                digits.<span class="hljs-built_in">insert</span>(digits.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> digits;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            digits[curr] += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> digits;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用标准库容器</title>
    <link href="/programming/cpp-stl-containers/"/>
    <url>/programming/cpp-stl-containers/</url>
    
    <content type="html"><![CDATA[<h1 id="C-常用标准库容器"><a href="#C-常用标准库容器" class="headerlink" title="C++常用标准库容器"></a>C++常用标准库容器</h1><p><a href="https://www.geeksforgeeks.org/containers-cpp-stl/">https://www.geeksforgeeks.org/containers-cpp-stl/</a></p><h2 id="顺序容器-sequence-containers"><a href="#顺序容器-sequence-containers" class="headerlink" title="顺序容器 (sequence containers)"></a>顺序容器 (sequence containers)</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>可以动态扩展的列表</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br></code></pre></td></tr></table></figure><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th></tr></thead><tbody><tr><td>插入</td><td>v.insert(v.begin(), 3)</td></tr><tr><td>插入到最后面<br />插入到最前面</td><td>v.push_back(3)<br />v.push_front(3)</td></tr><tr><td>删除</td><td>v.erase(v.begin())<br />v.erase(v.begin(), v.end())</td></tr><tr><td>删除尾元素<br />删除头元素</td><td>v.pop_back()<br />v.pop_front()</td></tr><tr><td>计数</td><td>v.count(3)</td></tr></tbody></table><h2 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h2><p>关联容器可能会使用到的数据类型，定义在头文件<code>utility</code>中。具有两个数据成员，名字为<code>first</code>以及<code>second</code>。</p><h2 id="关联容器-associative-containers"><a href="#关联容器-associative-containers" class="headerlink" title="关联容器 (associative containers)"></a>关联容器 (associative containers)</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>map&lt;string, <span class="hljs-keyword">int</span>&gt; map;<br></code></pre></td></tr></table></figure><h4 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>插入</td><td>map.insert({“word”, 1})<br />map.insert(make_pair(“word”, 1))<br />map.insert(pair&lt;string, size_t&gt;(“word”, 1))</td><td></td></tr><tr><td>删除</td><td>map.erase(“word”)<br />map.erase(iterator)</td><td></td></tr><tr><td>查找</td><td>map.find(“word”)</td><td>返回指向第一个找到元素的迭代器<br />迭代器指向的类型为pair<br />若未找到，则返回尾后迭代器</td></tr><tr><td>计数</td><td>map.count(“word”)</td><td>计数值</td></tr></tbody></table><h4 id="下标操作"><a href="#下标操作" class="headerlink" title="下标操作"></a>下标操作</h4><p>map（以及unordered_map）可以使用下标运算符，获取关键字对应的<strong>值</strong>。</p><p>如果关键字不存在，会用这个关键字创建一个新的元素，并对关联的值初始化。因此不应该直接用下标操作来进行查找，应该使用<code>find()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">map[<span class="hljs-string">&quot;hello&quot;</span>] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 会插入一个关键字为hello的元素，且值为1</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：map 的<strong>下标操作</strong>返回的是关键字对应的值，而<strong>解引用 map 迭代器</strong>返回的是一个 <strong><code>pair</code></strong> 对象。</p><h2 id="无序关联容器-unordered-associative-containers"><a href="#无序关联容器-unordered-associative-containers" class="headerlink" title="无序关联容器 (unordered associative containers)"></a>无序关联容器 (unordered associative containers)</h2><p>使用哈希函数组织的关联容器，查找速度更快，时间复杂度平均<code>O(1)</code>，最坏<code>O(n)</code>。在关键字类型元素没有明显有序关系时，可以使用无序容器。</p><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">unordered_set&lt;<span class="hljs-keyword">int</span>&gt; uset;<br></code></pre></td></tr></table></figure><h4 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>插入</td><td>uset.insert(5)</td><td>一个pair，first成员为指向插入元素的迭代器；second指示是否成功插入，true为成功插入，false为不成功（已经存在一样的元素）</td></tr><tr><td>清空</td><td>uset.clear()</td><td>void</td></tr><tr><td>查询</td><td>uset.find(key)</td><td>指向找到元素的迭代器，或者尾后迭代器（没找到）</td></tr></tbody></table><h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>无序键值对</p><h4 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; umap;<br></code></pre></td></tr></table></figure><h4 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h4><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>插入</td><td>umap.insert({“word”, 1})<br />umap.insert(make_pair(“word”, 1))<br />umap.insert(pair&lt;string, size_t&gt;(“word”, 1))</td><td></td></tr><tr><td>查询</td><td>umap.find(“word”)</td><td></td></tr><tr><td>计数</td><td>umap.count(“word”)</td><td></td></tr></tbody></table><h2 id="容器适配器-container-adapters"><a href="#容器适配器-container-adapters" class="headerlink" title="容器适配器 (container adapters)"></a>容器适配器 (container adapters)</h2>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++常用泛型算法</title>
    <link href="/programming/cpp-generic-algorithms/"/>
    <url>/programming/cpp-generic-algorithms/</url>
    
    <content type="html"><![CDATA[<h1 id="C-常用泛型算法"><a href="#C-常用泛型算法" class="headerlink" title="C++常用泛型算法"></a>C++常用泛型算法</h1><p><a href="https://www.geeksforgeeks.org/c-magicians-stl-algorithms/">https://www.geeksforgeeks.org/c-magicians-stl-algorithms/</a></p><p><a href="https://en.cppreference.com/w/cpp/algorithm">https://en.cppreference.com/w/cpp/algorithm</a></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// 泛型算法</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span>   <span class="hljs-comment">// 数值泛型算法</span></span><br></code></pre></td></tr></table></figure><h2 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h2><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>查找</td><td>find(v.begin(), v.end(), value)</td><td>满足条件的迭代器，找不到则为尾后</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="写容器算法"><a href="#写容器算法" class="headerlink" title="写容器算法"></a>写容器算法</h2><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>交换元素</td><td>swap(v.begin(), v.end())</td><td>void</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="重排容器算法"><a href="#重排容器算法" class="headerlink" title="重排容器算法"></a>重排容器算法</h2><table><thead><tr><th>操作</th><th>函数</th><th>返回</th></tr></thead><tbody><tr><td>排序</td><td>sort(v.begin(), v.end())</td><td>void</td></tr><tr><td>将不重复的排在前面</td><td>unique(v.begin(), v.end())</td><td>一个指向不重复值范围末尾的迭代器</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个数组的交集 II</title>
    <link href="/leetcode/top-interview-questions-easy/intersection-of-two-arrays-ii/"/>
    <url>/leetcode/top-interview-questions-easy/intersection-of-two-arrays-ii/</url>
    
    <content type="html"><![CDATA[<h1 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2y0c2/</a></p><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/</a></p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>将数组排序后，使用双指针，值相同则加入并集，否则向后移动<strong>值比较小</strong>的那个指针，直到其中一方越界。</p><p>时间复杂度：排序为<code>O(nlogn + mlogm)</code>，双指针移动为<code>O(n + m)</code>，加起来就是<code>O(nlogn + mlogm)</code></p><p>空间复杂度：由于<code>vector</code>的大小是动态改变的，复杂度为<code>O(1)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(), nums1.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(), nums2.<span class="hljs-built_in">end</span>());<br><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; intersection;<br><br>    <span class="hljs-keyword">int</span> n1 = <span class="hljs-number">0</span>, n2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> ( n1 != nums1.<span class="hljs-built_in">size</span>() &amp;&amp; n2 != nums2.<span class="hljs-built_in">size</span>() ) &#123;<br>        <span class="hljs-keyword">if</span> (nums1[n1] == nums2[n2]) &#123;<br>            intersection.<span class="hljs-built_in">push_back</span>(nums1[n1]);<br>            ++n1;<br>            ++n2;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums1[n1] &gt; nums2[n2]) &#123;<br>            ++n2;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++n1;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> intersection;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希表来记录数字以及出现的次数。</p><ol><li>遍历较短的数组，依次将数字插入哈希表。</li><li>遍历较长的数组，查询哈希表中是否已有该元素。如果有，就将它加入并集中，并将哈希表中的计数减一；如果没有则无需采取任何操作。</li></ol><p>时间复杂度：遍历两个数组所用的时间<code>O(m + n)</code>，哈希表的插入和查询平均都是<code>O(1)</code>。</p><p>空间复杂度：创建了大小为较短数组长度的哈希表，因此是<code>O(min(m, n))</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() &lt; nums2.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">intersect</span>(nums2, nums1);<br><br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; m;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; intersection;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums1) &#123;<br>        ++m[x];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums2) &#123;<br>        <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">find</span>(x) != m.<span class="hljs-built_in">end</span>() &amp;&amp; (m.<span class="hljs-built_in">find</span>(x) -&gt; second) &gt; <span class="hljs-number">0</span>) &#123;<br>            --m[x];<br>            intersection.<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> intersection;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现时，可以不用<code>find(x)</code>来查找，直接利用<code>count(x)</code>来判断表中是否存该数字，计数减一后判断计数值是不是变成0了，是的话就从表中删去此元素。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>只出现一次的数字</title>
    <link href="/leetcode/top-interview-questions-easy/single-number/"/>
    <url>/leetcode/top-interview-questions-easy/single-number/</url>
    
    <content type="html"><![CDATA[<h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x21ib6/</a></p><p><a href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>使用哈希表，如果放入元素时候已经有了，就删掉它。最后剩下的就是只出现一次的元素。时间复杂度是<code>O(n)</code>，空间复杂度也是<code>O(n)</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(x)) &#123;<br>            s.<span class="hljs-built_in">erase</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            s.<span class="hljs-built_in">insert</span>(x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *(s.<span class="hljs-built_in">begin</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>数字按位进行异或运算。基于以下几点事实：</p><ul><li>任何数和自己做异或运算，结果为 0，即 a ⊕ a &#x3D; 0 。</li><li>任何数和 0 做异或运算，结果还是自己，即 a ⊕ 0 &#x3D; 0 。</li><li>异或运算中，满足交换律和结合律，a ⊕ b ⊕ a &#x3D; b ⊕ a ⊕ a &#x3D; b ⊕ ( a ⊕ a ) &#x3D; b ⊕ 0 &#x3D; b 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e: nums) ret ^= e;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-的位和逻辑运算操作符"><a href="#C-的位和逻辑运算操作符" class="headerlink" title="C++的位和逻辑运算操作符"></a>C++的位和逻辑运算操作符</h2><table><thead><tr><th>运算</th><th>位运算操作符 (bitwise)</th><th>逻辑运算符(logical)</th></tr></thead><tbody><tr><td>AND</td><td>&amp;</td><td>&amp;&amp;</td></tr><tr><td>OR</td><td>|</td><td>||</td></tr><tr><td>XOR</td><td>^</td><td></td></tr><tr><td>NOT</td><td>~</td><td>!</td></tr><tr><td>left shift</td><td>&lt;&lt;</td><td></td></tr><tr><td>right shift</td><td>&gt;&gt;</td><td></td></tr></tbody></table><p>参考链接：<a href="https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/">https://www.geeksforgeeks.org/bitwise-operators-in-c-cpp/</a></p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存在重复元素</title>
    <link href="/leetcode/top-interview-questions-easy/contain-duplicates/"/>
    <url>/leetcode/top-interview-questions-easy/contain-duplicates/</url>
    
    <content type="html"><![CDATA[<h1 id="存在重复元素"><a href="#存在重复元素" class="headerlink" title="存在重复元素"></a>存在重复元素</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x248f5/</a><br><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p><h2 id="排序后比较"><a href="#排序后比较" class="headerlink" title="排序后比较"></a>排序后比较</h2><p>先排序，然后比较相邻元素即可。使用C++的排序泛型算法<code>sort()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] == nums[i+<span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>将元素插入哈希表，如果插入时发现重复了，就可以返回了。</p><p>C++中，类似的功能可以用关联容器<code>unordered_set</code>实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x: nums) &#123;<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(x) != s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        s.<span class="hljs-built_in">insert</span>(x);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转数组</title>
    <link href="/leetcode/top-interview-questions-easy/rotate-array/"/>
    <url>/leetcode/top-interview-questions-easy/rotate-array/</url>
    
    <content type="html"><![CDATA[<h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2skh7/</a><br><a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></p><h2 id="临时数组"><a href="#临时数组" class="headerlink" title="临时数组"></a>临时数组</h2><p>最简单的方法，但是空间复杂为<code>O(n)</code>。</p><h2 id="环状替换"><a href="#环状替换" class="headerlink" title="环状替换"></a>环状替换</h2><p>如果直接将每个数字放至它<strong>最后的位置</strong>，这样被放置位置的元素会被覆盖从而丢失。</p><p>解决方法：从位置 0 开始，将它放到正确的位置（向右 k 位），然后<strong>把被覆盖的元素保存下来</strong>，再将它放到正确的位置（再向右 k 位），循环往复。</p><p>容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到（当 nums.length % k &#x3D; 0 时，只会遍历偶数位置然后回到开头），此时应该跳到下一个位置然后继续。至于怎么判断该不该跳，我还不是很懂，详见<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/">题解</a>。</p><h2 id="数组翻转"><a href="#数组翻转" class="headerlink" title="数组翻转"></a>数组翻转</h2><p><img src="https://i.loli.net/2021/07/17/xNXsC3YdFDwPa8O.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>            <span class="hljs-built_in">swap</span>(nums[start], nums[end]);<br>            start += <span class="hljs-number">1</span>;<br>            end -= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        k %= nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums, k, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>买卖股票的最佳时机 II</title>
    <link href="/leetcode/top-interview-questions-easy/best-time-to-buy-and-sell-stock-ii/"/>
    <url>/leetcode/top-interview-questions-easy/best-time-to-buy-and-sell-stock-ii/</url>
    
    <content type="html"><![CDATA[<h1 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2zsx1/</a><br><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="贪心法"><a href="#贪心法" class="headerlink" title="贪心法"></a>贪心法</h3><p>只看相邻的两天，只要后一天比前一天高，就是收益，非常简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> curr = prices.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>; curr != prices.<span class="hljs-built_in">end</span>(); ++curr) &#123;<br>        <span class="hljs-keyword">if</span> (*curr &gt; *(curr - <span class="hljs-number">1</span>))<br>            result += *curr - *(curr - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>刚做完一个双指针，指魔怔了，嗯是搞了个双指针。其实就是找到每一段递增区间的起点和终点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; prices)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (prices.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">auto</span> min = prices.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">auto</span> max = min;<br>    <span class="hljs-keyword">auto</span> end = prices.<span class="hljs-built_in">end</span>();<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (min != end &amp;&amp; max != end) &#123;<br>        <span class="hljs-keyword">while</span> ((min+<span class="hljs-number">1</span>) != end &amp;&amp; *min &gt; *(min + <span class="hljs-number">1</span>))<br>            ++min;<br>        max = min;<br>        <span class="hljs-keyword">while</span> ((max+<span class="hljs-number">1</span>) != end &amp;&amp; *max &lt; *(max + <span class="hljs-number">1</span>))<br>            ++max;<br>        result += *(max) - *(min);<br>        <span class="hljs-keyword">if</span> (min != end &amp;&amp; max != end) &#123;<br>            ++max;<br>            min = max;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>贪心算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何制作 Unravel 和 damedane 的 Deepfake 换脸视频</title>
    <link href="/essay/make-deepfake-meme/"/>
    <url>/essay/make-deepfake-meme/</url>
    
    <content type="html"><![CDATA[<h1 id="如何制作-Unravel-和-damedane-换脸视频"><a href="#如何制作-Unravel-和-damedane-换脸视频" class="headerlink" title="如何制作 Unravel 和 damedane 换脸视频"></a>如何制作 Unravel 和 damedane 换脸视频</h1><p>虽然这梗已经火了好久了，但是最近看多了，自己也想试着搞一个。奇怪的是知乎和B站居然搜不到教程，而上外网一下就找到了，于是写一个博客记录一下，顺便帮助有需要的人（虽然应该不会有人看我的博客）。</p><h2 id="准备照片和视频"><a href="#准备照片和视频" class="headerlink" title="准备照片和视频"></a>准备照片和视频</h2><h3 id="人脸照片"><a href="#人脸照片" class="headerlink" title="人脸照片"></a>人脸照片</h3><p>准备一张人脸照片（受害人），裁剪为长宽比例1：1，人脸最好在中间。这里请出明日方舟的制作人海猫络合物先生。<br><img src="/img/deepfake/oceancat.png" alt="Ocean Cat"></p><h3 id="母体视频"><a href="#母体视频" class="headerlink" title="母体视频"></a>母体视频</h3><p>如果是要制作damedane的，就不需要自己准备了，代码里已经预设好了。<br>Unravel的视频模板在这：<a href="https://www.kapwing.com/explore/unravel-tokyo-ghoul-meme-template">Unravel模板</a>，直接下载下来一会儿用。</p><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>这个翻唱Unravel的小姐姐YouTube视频在<a href="https://www.youtube.com/watch?v=Dsd9X_7WSd4">这里</a>，下面的评论都在感谢她提供了这么好的deepfake模板，真是令人哭笑不得。但是有一说一还是唱的挺好听的，就是不知道为什么一看她闭眼就想笑。<br><img src="/img/deepfake/comment.png" alt="thank you for the great deepfake template"></p><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><p>打开这个链接：<a href="https://colab.research.google.com/github/AliaksandrSiarohin/first-order-model/blob/master/demo.ipynb">Deepfake代码</a><br>依次点击两个代码块左边的运行按钮，滚动到页面底部，等待一会儿后就会出来图像界面。<br><img src="/img/deepfake/run_script.png" alt="依次点这两个播放按钮"><br>根据图形界面的指示，上传刚才准备好的图片和视频，点击<code>Generate</code>按钮就可以生成换脸视频了，需要等几分钟。如图所示，damedane的原版视频有预设了（奥巴马左边那位）。<br><img src="/img/deepfake/gui2.png" alt="海猫填充完毕"><br>生成完成后，下载下来即可。<br><img src="/img/deepfake/compare.png" alt="海猫的痛，你们懂吗"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>YouTube一搜Unravel就会有一个教程视频，然后找到了对应的文章。不过这个教程是快一年前的了，现在deepfake的脚本已经更新过了，不用这么麻烦了。<br><a href="https://www.youtube.com/watch?v=MXNBtws35WE&amp;t=518s">https://www.youtube.com/watch?v=MXNBtws35WE&amp;t=518s</a><br><a href="https://www.kapwing.com/resources/how-to-make-the-unravel-tokyo-ghoul-deepfake-meme/">https://www.kapwing.com/resources/how-to-make-the-unravel-tokyo-ghoul-deepfake-meme/</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>删除排序数组中的重复项</title>
    <link href="/leetcode/top-interview-questions-easy/remove-duplicates-from-sorted-array/"/>
    <url>/leetcode/top-interview-questions-easy/remove-duplicates-from-sorted-array/</url>
    
    <content type="html"><![CDATA[<h1 id="删除排序数组中的重复项"><a href="#删除排序数组中的重复项" class="headerlink" title="删除排序数组中的重复项"></a>删除排序数组中的重复项</h1><p><a href="https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/">https://leetcode-cn.com/leetbook/read/top-interview-questions-easy/x2gy9m/</a><br><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">auto</span> iter_first = a.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">auto</span> iter_second = iter_first + <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以直接对迭代器加减，得到指向下一个位置的迭代器</span><br><span class="hljs-keyword">auto</span> iter_last = a.<span class="hljs-built_in">end</span>();<br><br><span class="hljs-keyword">int</span> str = *iter_first;             <span class="hljs-comment">// 解引用迭代器得到它指向的值</span><br></code></pre></td></tr></table></figure><h3 id="遍历vector容器"><a href="#遍历vector容器" class="headerlink" title="遍历vector容器"></a>遍历<code>vector</code>容器</h3><p>范围<code>for</code>循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v: nums) &#123;<br>    v *= <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code>循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-keyword">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-keyword">auto</span> current = nums.<span class="hljs-built_in">begin</span>();<br><br><span class="hljs-keyword">while</span> (current != nums.<span class="hljs-built_in">end</span>()) &#123;    <span class="hljs-comment">// 使用!=号来比较迭代器，&gt;或&lt;号不一定都有实现</span><br>    ++current;                     <span class="hljs-comment">// 使用前置++来递增迭代器</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>使用左右两个指针，前后两两比较，在重复值的位置替换成不重复的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) <span class="hljs-comment">// i是右指针，j是左指针</span><br><span class="hljs-keyword">if</span> (nums[j] != nums[i]) nums[++j] = nums[i];<br><span class="hljs-keyword">return</span> ++j;<br>&#125;<br></code></pre></td></tr></table></figure><p>右指针一直右移，遇到和左指针不同的，就将它的值赋给左指针，并使左指针移动到下一位。</p><h3 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h3><p>遇见重复的元素就用<code>erase()</code>直接删除了，也是太简单粗暴了，感觉智商被题解碾压了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> curr = nums.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (curr != nums.<span class="hljs-built_in">end</span>()) &#123;<br>        <span class="hljs-keyword">if</span> (*curr == *(curr<span class="hljs-number">-1</span>)) &#123;<br>            curr = nums.<span class="hljs-built_in">erase</span>(curr);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++curr;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意增加或删除vector中的元素会改变end迭代器的值，所以<code>nums.end()</code>需要写在循环条件里，每次循环都调用。</p><h3 id="使用标准库函数std-unique-（作弊）"><a href="#使用标准库函数std-unique-（作弊）" class="headerlink" title="使用标准库函数std::unique()（作弊）"></a>使用标准库函数<code>std::unique()</code>（作弊）</h3><p><code>std::unique()</code>接受一对迭代器，将这两个迭代器范围内的元素不重复的排到前面，然后返回不重复区域的下一个位置的迭代器。最后用<code>erase()</code>将此位置到末尾的元素都删除即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    nums.<span class="hljs-built_in">erase</span>(std::<span class="hljs-built_in">unique</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()), nums.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>初级算法</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将 Hexo 部署到 Github 上</title>
    <link href="/blog/deploy-hexo-on-github/"/>
    <url>/blog/deploy-hexo-on-github/</url>
    
    <content type="html"><![CDATA[<h2 id="主要参考"><a href="#主要参考" class="headerlink" title="主要参考"></a>主要参考</h2><ul><li><a href="https://hexo.io/docs/github-pages">GitHub Pages</a></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h4 id="博客目录创建git仓库，推送至source分支"><a href="#博客目录创建git仓库，推送至source分支" class="headerlink" title="博客目录创建git仓库，推送至source分支"></a>博客目录创建git仓库，推送至source分支</h4><figure class="highlight ps"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs ps">git init<br>git add .<br>git commit<br>git branch <span class="hljs-literal">-M</span> source<br>git push origin source<br></code></pre></td></tr></table></figure><h4 id="更改-github-workflows-pages-yml"><a href="#更改-github-workflows-pages-yml" class="headerlink" title="更改.github/workflows/pages.yml"></a>更改<code>.github/workflows/pages.yml</code></h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">source</span>  <span class="hljs-comment"># 监听push事件的分支，是博客源文件的分支</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">pages:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">12.</span><span class="hljs-string">x</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;12.x&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">NPM</span> <span class="hljs-string">dependencies</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">path:</span> <span class="hljs-string">node_modules</span><br>          <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.OS</span> <span class="hljs-string">&#125;&#125;-npm-cache</span><br>          <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">            $&#123;&#123; runner.OS &#125;&#125;-npm-cache</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">github_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">publish_dir:</span> <span class="hljs-string">./public</span><br>          <span class="hljs-attr">publish_branch:</span> <span class="hljs-string">master</span>  <span class="hljs-comment"># 部署的分支，是Github Pages对应的目录</span><br></code></pre></td></tr></table></figure><p>注意一下分支名字即可。</p><h4 id="更改项目Github-Pages的源目录"><a href="#更改项目Github-Pages的源目录" class="headerlink" title="更改项目Github Pages的源目录"></a>更改项目Github Pages的源目录</h4><p>在项目的<code>Settings</code>页的<code>Pages</code>标签里，将源目录改为<code>master</code>，保存就好了。</p><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><p>这两个是Fluid主题给的教程，但是不太看得懂到底部署到哪儿去了，最后没有用。</p><ul><li><a href="https://hexo.fluid-dev.com/posts/actions-deploy/">利用 GitHub Actions 自动部署 Hexo 博客</a></li><li><a href="https://zkqiang.cn/posts/e8ed6836/">编写自己的 GitHub Action，体验自动化部署</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客，不知道起什么标题好</title>
    <link href="/essay/first-blog/"/>
    <url>/essay/first-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="第一篇博客，不知道起什么标题好"><a href="#第一篇博客，不知道起什么标题好" class="headerlink" title="第一篇博客，不知道起什么标题好"></a>第一篇博客，不知道起什么标题好</h1><p>总之就先随便写写吧。</p><h2 id="2021-年-6-月-8-日"><a href="#2021-年-6-月-8-日" class="headerlink" title="2021 年 6 月 8 日"></a>2021 年 6 月 8 日</h2><p>今天是 2021 年 6 月 8 日，是高考的最后一天。1461天之前的我，现在可能正在考场里检查着自己的英语试卷吧。四年时光如同白驹过隙，转眼间就已经快要毕业了。</p><h2 id="突然开始写博客"><a href="#突然开始写博客" class="headerlink" title="突然开始写博客"></a>突然开始写博客</h2><p>作为一个计算机系的学生，居然在临近毕业的时候才开始捣鼓博客，属实有些贻笑大方。无论如何，算是个开始吧。研究生的生活已经开始，希望这个博客能够多少留下一点印迹吧。</p><h2 id="Be-Happy"><a href="#Be-Happy" class="headerlink" title="Be Happy"></a>Be Happy</h2><p>算是人生信条吧，做人最重要就是开心。当然，也要为了以后能一直开心下去。</p><h2 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h2><p>其实本科四年最大的遗憾就是并没有真正地学好一门技术。原以为只需要按部就班做好课内的工作就可以了，结果来说确实做的还可以，各种考试成绩都还行，但是除此以外好像也就没了。要说四年里最大的收获，可能就是我明白了自己真正喜欢什么、不喜欢什么。</p><p>大三与大四之间的暑假，在保研名额还没完全决定的时候，其实为找工作焦虑过一小段时间。编程语言没深入过，没有什么项目，学院给的实习机会也没有报名。</p><p>后来决定要了这个保研名额，其实也是走了一个退路。希望多出来的这两年时间，能够让我为工作做好充足的准备吧。</p><h2 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h2><p>希望以后还是能在离家近的地方工作，所以 TX 是个不错的目标。由于研究方向与算法岗完全不搭边儿，可以安心地准备找开发岗的工作了。先把 C++ 和 Go 学好吧。</p><p>当然，考公才是我心中最佳的选择，无奈考公也卷，而且考不上就是考不上了，不像给资本家打工那样可以退而求其次。所以只能做两手准备了，现在先把字练好吧。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我自认为自己是典型的三分钟热度，只希望这不是最后一篇博客，无论写点什么，都能够坚持下去。就酱。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
